{"meta":{"title":"SonGoKu の Blog","subtitle":"学吧老哥，学无止境","description":"勤练带来力量","author":"Son GoKu","url":"https://azxkenzo.github.io","root":"/"},"pages":[],"posts":[{"title":"Android - SystemUI - MediaControl","slug":"Android-SystemUI-MediaControl","date":"2023-07-18T03:08:00.000Z","updated":"2023-07-18T04:22:50.350Z","comments":true,"path":"2023/07/18/Android-SystemUI-MediaControl/","link":"","permalink":"https://azxkenzo.github.io/2023/07/18/Android-SystemUI-MediaControl/","excerpt":"","text":"媒体控制的相关类和方法： MediaHost MediaHostStateHolder MediaHierarchyManager MediaDataManager MediaHostStatesManager com.android.systemui.util.Utils#useQsMediaPlayer MediaHostMediaHost 由 dagger 注入，有 4 个 Provider，分别对应 4 个显示位置，每个位置的 MediaHost 都是单例的。 1234567891011121314151617181920212223242526272829303132333435363738@Provides@SysUISingleton@Named(QS_PANEL)static MediaHost providesQSMediaHost(MediaHost.MediaHostStateHolder stateHolder, MediaHierarchyManager hierarchyManager, MediaDataManager dataManager, MediaHostStatesManager statesManager) &#123; return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager);&#125;/** */@Provides@SysUISingleton@Named(QUICK_QS_PANEL)static MediaHost providesQuickQSMediaHost(MediaHost.MediaHostStateHolder stateHolder, MediaHierarchyManager hierarchyManager, MediaDataManager dataManager, MediaHostStatesManager statesManager) &#123; return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager);&#125;/** */@Provides@SysUISingleton@Named(KEYGUARD)static MediaHost providesKeyguardMediaHost(MediaHost.MediaHostStateHolder stateHolder, MediaHierarchyManager hierarchyManager, MediaDataManager dataManager, MediaHostStatesManager statesManager) &#123; return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager);&#125;/** */@Provides@SysUISingleton@Named(DREAM)static MediaHost providesDreamMediaHost(MediaHost.MediaHostStateHolder stateHolder, MediaHierarchyManager hierarchyManager, MediaDataManager dataManager, MediaHostStatesManager statesManager) &#123; return new MediaHost(stateHolder, hierarchyManager, dataManager, statesManager);&#125; 初始化： 1234567// class QuickQSPanelControllerprotected void onInit() &#123; super.onInit(); updateMediaExpansion(); mMediaHost.setShowsOnlyActiveMedia(true); mMediaHost.init(MediaHierarchyManager.LOCATION_QQS);&#125; 123456789// class QSPanelControllerpublic void onInit() &#123; super.onInit(); mMediaHost.setExpansion(MediaHostState.EXPANDED); mMediaHost.setShowsOnlyActiveMedia(false); mMediaHost.init(MediaHierarchyManager.LOCATION_QS); mQsCustomizerController.init(); mBrightnessSliderController.init();&#125; init()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950fun init(@MediaLocation location: Int) &#123; if (inited) &#123; return &#125; inited = true this.location = location hostView = mediaHierarchyManager.register(this) // Listen by default, as the host might not be attached by our clients, until // they get a visibility change. We still want to stay up to date in that case! setListeningToMediaData(true) hostView.addOnAttachStateChangeListener( object : OnAttachStateChangeListener &#123; override fun onViewAttachedToWindow(v: View?) &#123; setListeningToMediaData(true) updateViewVisibility() &#125; override fun onViewDetachedFromWindow(v: View?) &#123; setListeningToMediaData(false) &#125; &#125; ) // Listen to measurement updates and update our state with it hostView.measurementManager = object : UniqueObjectHostView.MeasurementManager &#123; override fun onMeasure(input: MeasurementInput): MeasurementOutput &#123; // Modify the measurement to exactly match the dimensions if ( View.MeasureSpec.getMode(input.widthMeasureSpec) == View.MeasureSpec.AT_MOST ) &#123; input.widthMeasureSpec = View.MeasureSpec.makeMeasureSpec( View.MeasureSpec.getSize(input.widthMeasureSpec), View.MeasureSpec.EXACTLY ) &#125; // This will trigger a state change that ensures that we now have a state // available state.measurementInput = input return mediaHostStatesManager.updateCarouselDimensions(location, state) &#125; &#125; // Whenever the state changes, let our state manager know state.changedListener = &#123; mediaHostStatesManager.updateHostState(location, state) &#125; updateViewVisibility()&#125; 调用 mediaHierarchyManager.register() 创建容器 view - UniqueObjectHostView 调用 setListeningToMediaData()，向 MediaDataManager 添加 Listener listener123456789101112131415161718192021222324252627282930313233private val listener = object : MediaDataManager.Listener &#123; override fun onMediaDataLoaded( key: String, oldKey: String?, data: MediaData, immediately: Boolean, receivedSmartspaceCardLatency: Int, isSsReactivated: Boolean ) &#123; if (immediately) &#123; updateViewVisibility() &#125; &#125; override fun onSmartspaceMediaDataLoaded( key: String, data: SmartspaceMediaData, shouldPrioritize: Boolean ) &#123; updateViewVisibility() &#125; override fun onMediaDataRemoved(key: String) &#123; updateViewVisibility() &#125; override fun onSmartspaceMediaDataRemoved(key: String, immediately: Boolean) &#123; if (immediately) &#123; updateViewVisibility() &#125; &#125; &#125; 12345678910111213fun updateViewVisibility() &#123; state.visible = if (showsOnlyActiveMedia) &#123; mediaDataManager.hasActiveMediaOrRecommendation() &#125; else &#123; mediaDataManager.hasAnyMediaOrRecommendation() &#125; val newVisibility = if (visible) View.VISIBLE else View.GONE if (newVisibility != hostView.visibility) &#123; hostView.visibility = newVisibility visibleChangedListeners.forEach &#123; it.invoke(visible) &#125; &#125;&#125; QSPanelControllerBase 在 onViewAttached() 中把 listener 添加到了 MediaHost 的 visibleChangedListeners 里。 12345678910111213141516protected void onViewAttached() &#123; mQsTileRevealController = createTileRevealController(); if (mQsTileRevealController != null) &#123; mQsTileRevealController.setExpansion(mRevealExpansion); &#125; mMediaHost.addVisibilityChangeListener(mMediaHostVisibilityListener); // here mView.addOnConfigurationChangedListener(mOnConfigurationChangedListener); mHost.addCallback(mQSHostCallback); setTiles(); mLastOrientation = getResources().getConfiguration().orientation; mQSLogger.logOnViewAttached(mLastOrientation, mView.getDumpableTag()); switchTileLayout(true); mDumpManager.registerDumpable(mView.getDumpableTag(), this);&#125; MediaDataManager初始化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475init &#123; dumpManager.registerDumpable(TAG, this) // Initialize the internal processing pipeline. The listeners at the front of the pipeline // are set as internal listeners so that they receive events. From there, events are // propagated through the pipeline. The end of the pipeline is currently mediaDataFilter, // so it is responsible for dispatching events to external listeners. To achieve this, // external listeners that are registered with [MediaDataManager.addListener] are actually // registered as listeners to mediaDataFilter. addInternalListener(mediaTimeoutListener) addInternalListener(mediaResumeListener) addInternalListener(mediaSessionBasedFilter) mediaSessionBasedFilter.addListener(mediaDeviceManager) mediaSessionBasedFilter.addListener(mediaDataCombineLatest) mediaDeviceManager.addListener(mediaDataCombineLatest) mediaDataCombineLatest.addListener(mediaDataFilter) // Set up links back into the pipeline for listeners that need to send events upstream. mediaTimeoutListener.timeoutCallback = &#123; key: String, timedOut: Boolean -&gt; setTimedOut(key, timedOut) &#125; mediaTimeoutListener.stateCallback = &#123; key: String, state: PlaybackState -&gt; updateState(key, state) &#125; mediaTimeoutListener.sessionCallback = &#123; key: String -&gt; onSessionDestroyed(key) &#125; mediaResumeListener.setManager(this) mediaDataFilter.mediaDataManager = this val suspendFilter = IntentFilter(Intent.ACTION_PACKAGES_SUSPENDED) broadcastDispatcher.registerReceiver(appChangeReceiver, suspendFilter, null, UserHandle.ALL) val uninstallFilter = IntentFilter().apply &#123; addAction(Intent.ACTION_PACKAGE_REMOVED) addAction(Intent.ACTION_PACKAGE_RESTARTED) addDataScheme(&quot;package&quot;) &#125; // BroadcastDispatcher does not allow filters with data schemes context.registerReceiver(appChangeReceiver, uninstallFilter) // Register for Smartspace data updates. smartspaceMediaDataProvider.registerListener(this) smartspaceSession = smartspaceManager.createSmartspaceSession( SmartspaceConfig.Builder(context, SMARTSPACE_UI_SURFACE_LABEL).build() ) smartspaceSession?.let &#123; it.addOnTargetsAvailableListener( // Use a main uiExecutor thread listening to Smartspace updates instead of using // the existing background executor. // SmartspaceSession has scheduled routine updates which can be unpredictable on // test simulators, using the backgroundExecutor makes it&#x27;s hard to test the threads // numbers. uiExecutor, SmartspaceSession.OnTargetsAvailableListener &#123; targets -&gt; smartspaceMediaDataProvider.onTargetsAvailable(targets) &#125; ) &#125; smartspaceSession?.let &#123; it.requestSmartspaceUpdate() &#125; tunerService.addTunable( object : TunerService.Tunable &#123; override fun onTuningChanged(key: String?, newValue: String?) &#123; allowMediaRecommendations = allowMediaRecommendations(context) if (!allowMediaRecommendations) &#123; dismissSmartspaceRecommendation( key = smartspaceMediaData.targetId, delay = 0L ) &#125; &#125; &#125;, Settings.Secure.MEDIA_CONTROLS_RECOMMENDATION )&#125; 调用 addInternalListener() 添加 listener 数据加载过程123456789101112131415161718192021fun onNotificationAdded(key: String, sbn: StatusBarNotification) &#123; if (useQsMediaPlayer &amp;&amp; isMediaNotification(sbn)) &#123; var logEvent = false Assert.isMainThread() val oldKey = findExistingEntry(key, sbn.packageName) if (oldKey == null) &#123; val instanceId = logger.getNewInstanceId() val temp = LOADING.copy(packageName = sbn.packageName, instanceId = instanceId) mediaEntries.put(key, temp) logEvent = true &#125; else if (oldKey != key) &#123; // Resume -&gt; active conversion; move to new key val oldData = mediaEntries.remove(oldKey)!! logEvent = true mediaEntries.put(key, oldData) &#125; loadMediaData(key, sbn, oldKey, logEvent) &#125; else &#123; onNotificationRemoved(key) &#125;&#125; 当有新 Notification 添加时，检查 useQsMediaPlayer 和 isMediaNotification()，然后调用 loadMediaData() 12345678private fun loadMediaData( key: String, sbn: StatusBarNotification, oldKey: String?, logEvent: Boolean = false) &#123; backgroundExecutor.execute &#123; loadMediaDataInBg(key, sbn, oldKey, logEvent) &#125;&#125; backgroundExecutor 中执行 loadMediaDataInBg() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105fun loadMediaDataInBg( key: String, sbn: StatusBarNotification, oldKey: String?, logEvent: Boolean = false) &#123; val token = sbn.notification.extras.getParcelable(...) if (token == null) &#123; return &#125; val mediaController = mediaControllerFactory.create(token) val metadata = mediaController.metadata val notif: Notification = sbn.notification val appInfo = ... // Album art var artworkBitmap = metadata?.let &#123; loadBitmapFromUri(it) &#125; if (artworkBitmap == null) &#123; artworkBitmap = metadata?.getBitmap(MediaMetadata.METADATA_KEY_ART) &#125; if (artworkBitmap == null) &#123; artworkBitmap = metadata?.getBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART) &#125; val artWorkIcon = if (artworkBitmap == null) &#123; notif.getLargeIcon() &#125; else &#123; Icon.createWithBitmap(artworkBitmap) &#125; // App name val appName = getAppName(sbn, appInfo) // App Icon val smallIcon = sbn.notification.smallIcon // Song name var song: CharSequence? = metadata?.getString(MediaMetadata.METADATA_KEY_DISPLAY_TITLE) if (song == null) &#123; song = metadata?.getString(MediaMetadata.METADATA_KEY_TITLE) &#125; if (song == null) &#123; song = HybridGroupManager.resolveTitle(notif) &#125; // Explicit Indicator var isExplicit = false if (mediaFlags.isExplicitIndicatorEnabled()) &#123; val mediaMetadataCompat = MediaMetadataCompat.fromMediaMetadata(metadata) isExplicit = mediaMetadataCompat?.getLong(MediaConstants.METADATA_KEY_IS_EXPLICIT) == MediaConstants.METADATA_VALUE_ATTRIBUTE_PRESENT &#125; // Artist name var artist: CharSequence? = metadata?.getString(MediaMetadata.METADATA_KEY_ARTIST) if (artist == null) &#123; artist = HybridGroupManager.resolveText(notif) &#125; // Device name (used for remote cast notifications) var device: MediaDeviceData? = null if (isRemoteCastNotification(sbn)) &#123; ... &#125; // Control buttons // If flag is enabled and controller has a PlaybackState, create actions from session info // Otherwise, use the notification actions var actionIcons: List&lt;MediaAction&gt; = emptyList() var actionsToShowCollapsed: List&lt;Int&gt; = emptyList() val semanticActions = createActionsFromState(sbn.packageName, mediaController, sbn.user) if (semanticActions == null) &#123; val actions = createActionsFromNotification(sbn) actionIcons = actions.first actionsToShowCollapsed = actions.second &#125; val playbackLocation = if (isRemoteCastNotification(sbn)) MediaData.PLAYBACK_CAST_REMOTE else if ( mediaController.playbackInfo?.playbackType == MediaController.PlaybackInfo.PLAYBACK_TYPE_LOCAL ) MediaData.PLAYBACK_LOCAL else MediaData.PLAYBACK_CAST_LOCAL val isPlaying = mediaController.playbackState?.let &#123; isPlayingState(it.state) &#125; ?: null val currentEntry = mediaEntries.get(key) val instanceId = currentEntry?.instanceId ?: logger.getNewInstanceId() val appUid = appInfo?.uid ?: Process.INVALID_UID val lastActive = systemClock.elapsedRealtime() foregroundExecutor.execute &#123; val resumeAction: Runnable? = mediaEntries[key]?.resumeAction val hasCheckedForResume = mediaEntries[key]?.hasCheckedForResume == true val active = mediaEntries[key]?.active ?: true onMediaDataLoaded( key, oldKey, MediaData(...) ) &#125;&#125; 构造好 MediaData 后，在 foregroundExecutor 中调用 onMediaDataLoaded() 123456789fun onMediaDataLoaded(key: String, oldKey: String?, data: MediaData) = traceSection(&quot;MediaDataManager#onMediaDataLoaded&quot;) &#123; Assert.isMainThread() if (mediaEntries.containsKey(key)) &#123; // Otherwise this was removed already mediaEntries.put(key, data) notifyMediaDataLoaded(key, oldKey, data) &#125; &#125; 123private fun notifyMediaDataLoaded(key: String, oldKey: String?, info: MediaData) &#123; internalListeners.forEach &#123; it.onMediaDataLoaded(key, oldKey, info) &#125;&#125; MediaHierarchyManagermediaFrame12private val mediaFrame get() = mediaCarouselController.mediaFrame applyState()12345678910111213141516171819202122232425262728293031323334private fun applyState( bounds: Rect, alpha: Float, immediately: Boolean = false, clipBounds: Rect = EMPTY_RECT) = traceSection(&quot;MediaHierarchyManager#applyState&quot;) &#123; currentBounds.set(bounds) currentClipping = clipBounds carouselAlpha = if (isCurrentlyFading()) alpha else 1.0f val onlyUseEndState = !isCurrentlyInGuidedTransformation() || isCurrentlyFading() val startLocation = if (onlyUseEndState) -1 else previousLocation val progress = if (onlyUseEndState) 1.0f else getTransformationProgress() val endLocation = resolveLocationForFading() mediaCarouselController.setCurrentState( startLocation, endLocation, progress, immediately ) updateHostAttachment() if (currentAttachmentLocation == IN_OVERLAY) &#123; // Setting the clipping on the hierarchy of `mediaFrame` does not work if (!currentClipping.isEmpty) &#123; currentBounds.intersect(currentClipping) &#125; mediaFrame.setLeftTopRightBottom( currentBounds.left, currentBounds.top, currentBounds.right, currentBounds.bottom ) &#125; &#125; 调用 updateHostAttachment() 把 mediaFrame 添加到 hostView 中 updateHostAttachment()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private fun updateHostAttachment() = traceSection(&quot;MediaHierarchyManager#updateHostAttachment&quot;) &#123; var newLocation = resolveLocationForFading() // Don&#x27;t use the overlay when fading or when we don&#x27;t have active media var canUseOverlay = !isCurrentlyFading() &amp;&amp; hasActiveMediaOrRecommendation if (isCrossFadeAnimatorRunning) &#123; if ( getHost(newLocation)?.visible == true &amp;&amp; getHost(newLocation)?.hostView?.isShown == false &amp;&amp; newLocation != desiredLocation ) &#123; // We&#x27;re crossfading but the view is already hidden. Let&#x27;s move to the overlay // instead. This happens when animating to the full shade using a button click. canUseOverlay = true &#125; &#125; val inOverlay = isTransitionRunning() &amp;&amp; rootOverlay != null &amp;&amp; canUseOverlay newLocation = if (inOverlay) IN_OVERLAY else newLocation if (currentAttachmentLocation != newLocation) &#123; currentAttachmentLocation = newLocation // Remove the carousel from the old host (mediaFrame.parent as ViewGroup?)?.removeView(mediaFrame) // Add it to the new one if (inOverlay) &#123; rootOverlay!!.add(mediaFrame) &#125; else &#123; val targetHost = getHost(newLocation)!!.hostView // This will either do a full layout pass and remeasure, or it will bypass // that and directly set the mediaFrame&#x27;s bounds within the premeasured host. targetHost.addView(mediaFrame) // 把 mediaFrame 添加到 hostView &#125; if (isCrossFadeAnimatorRunning) &#123; // When cross-fading with an animation, we only notify the media carousel of the // location change, once the view is reattached to the new place and not // immediately // when the desired location changes. This callback will update the measurement // of the carousel, only once we&#x27;ve faded out at the old location and then // reattach // to fade it in at the new location. mediaCarouselController.onDesiredLocationChanged( newLocation, getHost(newLocation), animate = false ) &#125; &#125; &#125; 把 mediaFrame 添加到 hostView MediaCarouselControllermediaFrame123456789101112mediaFrame = inflateMediaCarousel()private fun inflateMediaCarousel(): ViewGroup &#123; val mediaCarousel = LayoutInflater.from(context) .inflate(R.layout.media_carousel, UniqueObjectHostView(context), false) as ViewGroup // Because this is inflated when not attached to the true view hierarchy, it resolves some // potential issues to force that the layout direction is defined by the locale // (rather than inherited from the parent, which would resolve to LTR when unattached). mediaCarousel.layoutDirection = View.LAYOUT_DIRECTION_LOCALE return mediaCarousel&#125; mediaFrame 使用的布局是 R.layout.media_carousel 初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879init &#123; mediaFrame = inflateMediaCarousel() mediaCarousel = mediaFrame.requireViewById(R.id.media_carousel_scroller) pageIndicator = mediaFrame.requireViewById(R.id.media_page_indicator) mediaContent = mediaCarousel.requireViewById(R.id.media_carousel) mediaManager.addListener( object : MediaDataManager.Listener &#123; override fun onMediaDataLoaded( key: String, oldKey: String?, data: MediaData, immediately: Boolean, receivedSmartspaceCardLatency: Int, isSsReactivated: Boolean ) &#123; debugLogger.logMediaLoaded(key, data.active) if (addOrUpdatePlayer(key, oldKey, data, isSsReactivated)) &#123; // Log card received if a new resumable media card is added MediaPlayerData.getMediaPlayer(key)?.let &#123; /* ktlint-disable max-line-length */ logSmartspaceCardReported(...) /* ktlint-disable max-line-length */ &#125; if ( mediaCarouselScrollHandler.visibleToUser &amp;&amp; mediaCarouselScrollHandler.visibleMediaIndex == MediaPlayerData.getMediaPlayerIndex(key) ) &#123; logSmartspaceImpression(mediaCarouselScrollHandler.qsExpanded) &#125; &#125; else if (receivedSmartspaceCardLatency != 0) &#123; // Log resume card received if resumable media card is reactivated and // resume card is ranked first MediaPlayerData.players().forEachIndexed &#123; index, it -&gt; if (it.recommendationViewHolder == null) &#123; it.mSmartspaceId = SmallHash.hash( it.mUid + systemClock.currentTimeMillis().toInt() ) it.mIsImpressed = false /* ktlint-disable max-line-length */ logSmartspaceCardReported(...) /* ktlint-disable max-line-length */ &#125; &#125; // If media container area already visible to the user, log impression for // reactivated card. if ( mediaCarouselScrollHandler.visibleToUser &amp;&amp; !mediaCarouselScrollHandler.qsExpanded ) &#123; logSmartspaceImpression(mediaCarouselScrollHandler.qsExpanded) &#125; &#125; val canRemove = data.isPlaying?.let &#123; !it &#125; ?: data.isClearable &amp;&amp; !data.active if (canRemove &amp;&amp; !Utils.useMediaResumption(context)) &#123; // This view isn&#x27;t playing, let&#x27;s remove this! This happens e.g. when // dismissing/timing out a view. We still have the data around because // resumption could be on, but we should save the resources and release // this. if (isReorderingAllowed) &#123; onMediaDataRemoved(key) &#125; else &#123; keysNeedRemoval.add(key) &#125; &#125; else &#123; keysNeedRemoval.remove(key) &#125; &#125; ...... &#125; )&#125; 在 onMediaDataLoaded() 回调中调用 addOrUpdatePlayer() 添加 player addOrUpdatePlayer()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576private fun addOrUpdatePlayer( key: String, oldKey: String?, data: MediaData, isSsReactivated: Boolean): Boolean = traceSection(&quot;MediaCarouselController#addOrUpdatePlayer&quot;) &#123; MediaPlayerData.moveIfExists(oldKey, key) val existingPlayer = MediaPlayerData.getMediaPlayer(key) val curVisibleMediaKey = MediaPlayerData.visiblePlayerKeys() .elementAtOrNull(mediaCarouselScrollHandler.visibleMediaIndex) if (existingPlayer == null) &#123; val newPlayer = mediaControlPanelFactory.get() newPlayer.attachPlayer( MediaViewHolder.create(LayoutInflater.from(context), mediaContent) ) newPlayer.mediaViewController.sizeChangedListener = this::updateCarouselDimensions val lp = LinearLayout.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT ) newPlayer.mediaViewHolder?.player?.setLayoutParams(lp) newPlayer.bindPlayer(data, key) newPlayer.setListening( mediaCarouselScrollHandler.visibleToUser &amp;&amp; currentlyExpanded ) MediaPlayerData.addMediaPlayer( key, data, newPlayer, systemClock, isSsReactivated, debugLogger ) updatePlayerToState(newPlayer, noAnimation = true) // Media data added from a recommendation card should starts playing. if ( (shouldScrollToKey &amp;&amp; data.isPlaying == true) || (!shouldScrollToKey &amp;&amp; data.active) ) &#123; reorderAllPlayers(curVisibleMediaKey, key) &#125; else &#123; needsReordering = true &#125; &#125; else &#123; existingPlayer.bindPlayer(data, key) MediaPlayerData.addMediaPlayer( key, data, existingPlayer, systemClock, isSsReactivated, debugLogger ) val packageName = MediaPlayerData.smartspaceMediaData?.packageName ?: String() // In case of recommendations hits. // Check the playing status of media player and the package name. // To make sure we scroll to the right app&#x27;s media player. if ( isReorderingAllowed || shouldScrollToKey &amp;&amp; data.isPlaying == true &amp;&amp; packageName == data.packageName ) &#123; reorderAllPlayers(curVisibleMediaKey, key) &#125; else &#123; needsReordering = true &#125; &#125; updatePageIndicator() mediaCarouselScrollHandler.onPlayersChanged() mediaFrame.requiresRemeasuring = true return existingPlayer == null &#125; 创建 MediaControlPanel 调用 MediaViewHolder.create() 创建 MediaViewHolder，并调用 MediaControlPanel.attachPlayer() 附加到 MediaControlPanel 中 调用 MediaControlPanel.bindPlayer() 绑定数据 reorderAllPlayers123456789101112131415161718192021222324252627private fun reorderAllPlayers( previousVisiblePlayerKey: MediaPlayerData.MediaSortKey?, key: String? = null) &#123; mediaContent.removeAllViews() for (mediaPlayer in MediaPlayerData.players()) &#123; mediaPlayer.mediaViewHolder?.let &#123; mediaContent.addView(it.player) &#125; ?: mediaPlayer.recommendationViewHolder?.let &#123; mediaContent.addView(it.recommendations) &#125; &#125; mediaCarouselScrollHandler.onPlayersChanged() MediaPlayerData.updateVisibleMediaPlayers() // Automatically scroll to the active player if needed if (shouldScrollToKey) &#123; shouldScrollToKey = false val mediaIndex = key?.let &#123; MediaPlayerData.getMediaPlayerIndex(it) &#125; ?: -1 if (mediaIndex != -1) &#123; previousVisiblePlayerKey?.let &#123; val previousVisibleIndex = MediaPlayerData.playerKeys().indexOfFirst &#123; key -&gt; it == key &#125; mediaCarouselScrollHandler.scrollToPlayer(previousVisibleIndex, mediaIndex) &#125; ?: mediaCarouselScrollHandler.scrollToPlayer(destIndex = mediaIndex) &#125; &#125;&#125; 调用 mediaContent.addView(it.player) MediaControlPanelMediaViewHolder12345/** Holder class for media player view */class MediaViewHolder constructor(itemView: View) &#123; val player = itemView as TransitionLayout ...... create()12345678910111213@JvmStaticfun create(inflater: LayoutInflater, parent: ViewGroup): MediaViewHolder &#123; val mediaView = inflater.inflate(R.layout.media_session_view, parent, false) mediaView.setLayerType(View.LAYER_TYPE_HARDWARE, null) // Because this media view (a TransitionLayout) is used to measure and layout the views // in various states before being attached to its parent, we can&#x27;t depend on the default // LAYOUT_DIRECTION_INHERIT to correctly resolve the ltr direction. mediaView.layoutDirection = View.LAYOUT_DIRECTION_LOCALE return MediaViewHolder(mediaView).apply &#123; // Media playback is in the direction of tape, not time, so it stays LTR seekBar.layoutDirection = View.LAYOUT_DIRECTION_LTR &#125;&#125; MediaViewHolder 用的布局是 R.layout.media_session_view QSPanelControllerBaseQSPanelControllerBase 在 onViewAttached() 中把 listener 添加到了 MediaHost 的 visibleChangedListeners 里。 1234567private final Function1&lt;Boolean, Unit&gt; mMediaHostVisibilityListener = (visible) -&gt; &#123; if (mMediaVisibilityChangedListener != null) &#123; mMediaVisibilityChangedListener.accept(visible); &#125; switchTileLayout(false); return null;&#125;; 12345678910111213141516boolean switchTileLayout(boolean force) &#123; /* Whether or not the panel currently contains a media player. */ boolean horizontal = shouldUseHorizontalLayout(); if (horizontal != mUsingHorizontalLayout || force) &#123; mQSLogger.logSwitchTileLayout(horizontal, mUsingHorizontalLayout, force, mView.getDumpableTag()); mUsingHorizontalLayout = horizontal; mView.setUsingHorizontalLayout(mUsingHorizontalLayout, mMediaHost.getHostView(), force); updateMediaDisappearParameters(); if (mUsingHorizontalLayoutChangedListener != null) &#123; mUsingHorizontalLayoutChangedListener.run(); &#125; return true; &#125; return false;&#125; 调用 setUsingHorizontalLayout() QSPanel123456789101112131415void setUsingHorizontalLayout(boolean horizontal, ViewGroup mediaHostView, boolean force) &#123; if (horizontal != mUsingHorizontalLayout || force) &#123; Log.d(getDumpableTag(), &quot;setUsingHorizontalLayout: &quot; + horizontal + &quot;, &quot; + force); mUsingHorizontalLayout = horizontal; ViewGroup newParent = horizontal ? mHorizontalContentContainer : this; switchAllContentToParent(newParent, mTileLayout); reAttachMediaHost(mediaHostView, horizontal); if (needsDynamicRowsAndColumns()) &#123; mTileLayout.setMinRows(horizontal ? 2 : 1); mTileLayout.setMaxColumns(horizontal ? 2 : 4); &#125; updateMargins(mediaHostView); mHorizontalLinearLayout.setVisibility(horizontal ? View.VISIBLE : View.GONE); &#125;&#125; 调用 reAttachMediaHost() 1234567891011121314151617181920212223242526272829private void reAttachMediaHost(ViewGroup hostView, boolean horizontal) &#123; if (!mUsingMediaPlayer) &#123; return; &#125; mMediaHostView = hostView; ViewGroup newParent = horizontal ? mHorizontalLinearLayout : this; ViewGroup currentParent = (ViewGroup) hostView.getParent(); Log.d(getDumpableTag(), &quot;Reattaching media host: &quot; + horizontal + &quot;, current &quot; + currentParent + &quot;, new &quot; + newParent); if (currentParent != newParent) &#123; if (currentParent != null) &#123; currentParent.removeView(hostView); &#125; newParent.addView(hostView); LinearLayout.LayoutParams layoutParams = (LayoutParams) hostView.getLayoutParams(); layoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT; layoutParams.width = horizontal ? 0 : ViewGroup.LayoutParams.MATCH_PARENT; layoutParams.weight = horizontal ? 1f : 0; // Add any bottom margin, such that the total spacing is correct. This is only // necessary if the view isn&#x27;t horizontal, since otherwise the padding is // carried in the parent of this view (to ensure correct vertical alignment) layoutParams.bottomMargin = !horizontal || displayMediaMarginsOnMedia() ? Math.max(mMediaTotalBottomMargin - getPaddingBottom(), 0) : 0; layoutParams.topMargin = mediaNeedsTopMargin() &amp;&amp; !horizontal ? mMediaTopMargin : 0; // Call setLayoutParams explicitly to ensure that requestLayout happens hostView.setLayoutParams(layoutParams); &#125;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - SystemUI - QuickSettings","slug":"Android-SystemUI-QuickSettings","date":"2023-07-02T00:38:11.000Z","updated":"2023-07-18T01:59:18.315Z","comments":true,"path":"2023/07/02/Android-SystemUI-QuickSettings/","link":"","permalink":"https://azxkenzo.github.io/2023/07/02/Android-SystemUI-QuickSettings/","excerpt":"","text":"基于 AOSP Android 13 源码 CentralSurfacesUI 相关的 CoreStartable - CentralSurfaces，CentralSurfaces 的实现类 - CentralSurfacesImpl。 CoreStartable 的核心方法是 start()。看看 CentralSurfacesImpl 的 start() 里面做了什么。 1234567891011121314151617181920// class CentralSurfacesImplpublic void start() &#123; mScreenLifecycle.addObserver(mScreenObserver); mWakefulnessLifecycle.addObserver(mWakefulnessObserver); mUiModeManager=mContext.getSystemService(UiModeManager.class); if(mBubblesOptional.isPresent())&#123; mBubblesOptional.get().setExpandListener(mBubbleExpandListener); &#125; // Do not restart System UI when the bugreport flag changes. mFeatureFlags.addListener(Flags.LEAVE_SHADE_OPEN_FOR_BUGREPORT,event-&gt;&#123; event.requestNoRestart(); &#125;); ...... createAndAddWindows(result); ......&#125; createAndAddWindows() 方法比较重要。先调用 makeStatusBarView() 初始化各个控件；然后调用 NotificationShadeWindowController.attach() 把 View 附加到 WindowManager 上。 123456// class CentralSurfacesImplpublic void createAndAddWindows(@Nullable RegisterStatusBarResult result) &#123; makeStatusBarView(result); mNotificationShadeWindowController.attach(); mStatusBarWindowController.attach();&#125; makeStatusBarView() 中把用来显示 QS 的容器 R.id.qs_frame 替换成 fragment。这里使用的 fragment 是 QSFragment。 123456789101112131415161718192021222324252627282930313233343536// class CentralSurfacesImplprotected void makeStatusBarView(@Nullable RegisterStatusBarResult result) &#123; ...... final View container = mNotificationShadeWindowView.findViewById(R.id.qs_frame); if (container != null) &#123; FragmentHostManager fragmentHostManager = mFragmentService.getFragmentHostManager(container); ExtensionFragmentListener.attachExtensonToFragment( mFragmentService, container, QS.TAG, R.id.qs_frame, mExtensionController .newExtension(QS.class) .withPlugin(QS.class) .withDefault(this::createDefaultQSFragment) .build()); mBrightnessMirrorController = new BrightnessMirrorController( mNotificationShadeWindowView, mNotificationPanelViewController, mNotificationShadeDepthControllerLazy.get(), mBrightnessSliderFactory, (visible) -&gt; &#123; mBrightnessMirrorVisible = visible; updateScrimController(); &#125;); fragmentHostManager.addTagListener(QS.TAG, (tag, f) -&gt; &#123; QS qs = (QS) f; if (qs instanceof QSFragment) &#123; mQSPanelController = ((QSFragment) qs).getQSPanelController(); ((QSFragment) qs).setBrightnessMirrorController(mBrightnessMirrorController); &#125; &#125;); &#125;&#125; R.id.qs_frame 所在的布局为 R.layout.super_notification_shade，通过 Dagger 注入的。 12345678910111213// class StatusBarViewModule@Providespublic static NotificationShadeWindowView providesNotificationShadeWindowView( LayoutInflater layoutInflater) &#123; NotificationShadeWindowView notificationShadeWindowView = (NotificationShadeWindowView) layoutInflater.inflate(R.layout.super_notification_shade, /* root= */ null); if (notificationShadeWindowView == null) &#123; throw new IllegalStateException( &quot;R.layout.super_notification_shade could not be properly inflated&quot;); &#125; return notificationShadeWindowView;&#125; QSFragmentQSFragment 使用的布局是 R.layout.qs_panel。 123456789101112// class QSFragmentpublic View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) &#123; try &#123; Trace.beginSection(&quot;QSFragment#onCreateView&quot;); inflater = inflater.cloneInContext(new ContextThemeWrapper(getContext(), R.style.Theme_SystemUI_QuickSettings)); return inflater.inflate(R.layout.qs_panel, container, false); &#125; finally &#123; Trace.endSection(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;com.android.systemui.qs.QSContainerImpl xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/quick_settings_container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:clipToPadding=&quot;false&quot; android:clipChildren=&quot;false&quot;&gt; &lt;com.android.systemui.qs.NonInterceptingScrollView android:id=&quot;@+id/expanded_qs_scroll_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:elevation=&quot;@dimen/qs_panel_elevation&quot; android:importantForAccessibility=&quot;no&quot; android:scrollbars=&quot;none&quot; android:clipChildren=&quot;false&quot; android:clipToPadding=&quot;false&quot; android:layout_weight=&quot;1&quot;&gt; &lt;com.android.systemui.qs.QSPanel android:id=&quot;@+id/quick_settings_panel&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/transparent&quot; android:focusable=&quot;true&quot; android:accessibilityTraversalBefore=&quot;@android:id/edit&quot; android:clipToPadding=&quot;false&quot; android:clipChildren=&quot;false&quot;&gt; &lt;include layout=&quot;@layout/qs_footer_impl&quot; /&gt; &lt;/com.android.systemui.qs.QSPanel&gt; &lt;/com.android.systemui.qs.NonInterceptingScrollView&gt; &lt;include layout=&quot;@layout/quick_status_bar_expanded_header&quot; /&gt; &lt;include layout=&quot;@layout/footer_actions&quot; android:id=&quot;@+id/qs_footer_actions&quot; android:layout_height=&quot;@dimen/footer_actions_height&quot; android:layout_width=&quot;match_parent&quot; android:layout_gravity=&quot;bottom&quot; /&gt; &lt;include android:id=&quot;@+id/qs_customize&quot; layout=&quot;@layout/qs_customize_panel&quot; android:visibility=&quot;gone&quot; /&gt;&lt;/com.android.systemui.qs.QSContainerImpl&gt; 其中，@layout/qs_footer_impl 是 QS 展开状态下磁贴下方的构建版本文本、指示器和磁贴编辑按钮那一栏； @layout/quick_status_bar_expanded_header 是非展开状态下显示磁贴的布局； 展开状态下 @layout/quick_status_bar_expanded_header 显示的内容会隐藏，磁贴上面显示的内容由 R.layout.combined_qs_header 控制。R.layout.combined_qs_header 是替换了 status_bar_expanded 布局中的 qs_header_stub ViewStub 而来的。 @layout/footer_actions 是展开状态下底部的功能栏，包括设置、电源等。 @layout/qs_customize_panel 是磁贴显示的自定义界面。 QSFragment 的 onViewCreated() 方法，各控件的初始化都在这里面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// class QSFragmentpublic void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; QSFragmentComponent qsFragmentComponent = mQsComponentFactory.create(this); mQSPanelController = qsFragmentComponent.getQSPanelController(); mQuickQSPanelController = qsFragmentComponent.getQuickQSPanelController(); mQSPanelController.init(); mQuickQSPanelController.init(); mQSFooterActionsViewModel = mFooterActionsViewModelFactory.create(/* lifecycleOwner */ this); bindFooterActionsView(view); mFooterActionsController.init(); mQSPanelScrollView = view.findViewById(R.id.expanded_qs_scroll_view); mQSPanelScrollView.addOnLayoutChangeListener( (v, left, top, right, bottom, oldLeft, oldTop, oldRight, oldBottom) -&gt; &#123; updateQsBounds(); &#125;); mQSPanelScrollView.setOnScrollChangeListener( (v, scrollX, scrollY, oldScrollX, oldScrollY) -&gt; &#123; // Lazily update animators whenever the scrolling changes mQSAnimator.requestAnimatorUpdate(); if (mScrollListener != null) &#123; mScrollListener.onQsPanelScrollChanged(scrollY); &#125; &#125;); mHeader = view.findViewById(R.id.header); mFooter = qsFragmentComponent.getQSFooter(); mQSContainerImplController = qsFragmentComponent.getQSContainerImplController(); mQSContainerImplController.init(); mContainer = mQSContainerImplController.getView(); mDumpManager.registerDumpable(mContainer.getClass().getName(), mContainer); mQSAnimator = qsFragmentComponent.getQSAnimator(); mQSSquishinessController = qsFragmentComponent.getQSSquishinessController(); mQSCustomizerController = qsFragmentComponent.getQSCustomizerController(); mQSCustomizerController.init(); mQSCustomizerController.setQs(this); if (savedInstanceState != null) &#123; setQsVisible(savedInstanceState.getBoolean(EXTRA_VISIBLE)); setExpanded(savedInstanceState.getBoolean(EXTRA_EXPANDED)); setListening(savedInstanceState.getBoolean(EXTRA_LISTENING)); setEditLocation(view); mQSCustomizerController.restoreInstanceState(savedInstanceState); if (mQsExpanded) &#123; mQSPanelController.getTileLayout().restoreInstanceState(savedInstanceState); &#125; &#125; mStatusBarStateController.addCallback(this); onStateChanged(mStatusBarStateController.getState()); view.addOnLayoutChangeListener( (v, left, top, right, bottom, oldLeft, oldTop, oldRight, oldBottom) -&gt; &#123; boolean sizeChanged = (oldTop - oldBottom) != (top - bottom); if (sizeChanged) &#123; setQsExpansion(mLastQSExpansion, mLastPanelFraction, mLastHeaderTranslation, mSquishinessFraction); &#125; &#125;); mQSPanelController.setUsingHorizontalLayoutChangeListener( () -&gt; &#123; // The hostview may be faded out in the horizontal layout. Let&#x27;s make sure to // reset the alpha when switching layouts. This is fine since the animator will // update the alpha if it&#x27;s not supposed to be 1.0f mQSPanelController.getMediaHost().getHostView().setAlpha(1.0f); mQSAnimator.requestAnimatorUpdate(); &#125;); mTunerService.addTunable(this, QS_TRANSPARENCY);&#125; 这里使用了各种 Controller 类来对布局进行控制。与 QS 相关的主要是 mQSPanelController 和 mQuickQSPanelController。这里调用它们的 init() 方法进行初始化。 QuickQSPanelController未展开QS对应的 Controller 是 QuickQSPanelController。QuickQSPanelController 的最顶层父类是 ViewController。 12345678910111213// class ViewControllerpublic void init() &#123; if (mInited) &#123; return; &#125; onInit(); mInited = true; if (isAttachedToWindow()) &#123; mOnAttachStateListener.onViewAttachedToWindow(mView); &#125; addOnAttachStateChangeListener(mOnAttachStateListener);&#125; mOnAttachStateListener 的 onViewAttachedToWindow() 会调用 onViewAttached()。 1234567// class QuickQSPanelControllerprotected void onInit() &#123; super.onInit(); updateMediaExpansion(); mMediaHost.setShowsOnlyActiveMedia(true); mMediaHost.init(MediaHierarchyManager.LOCATION_QQS);&#125; 1234567891011121314151617// class QSPanelControllerBaseprotected void onViewAttached() &#123; mQsTileRevealController = createTileRevealController(); if (mQsTileRevealController != null) &#123; mQsTileRevealController.setExpansion(mRevealExpansion); &#125; mMediaHost.addVisibilityChangeListener(mMediaHostVisibilityListener); mView.addOnConfigurationChangedListener(mOnConfigurationChangedListener); mHost.addCallback(mQSHostCallback); setTiles(); mLastOrientation = getResources().getConfiguration().orientation; mQSLogger.logOnViewAttached(mLastOrientation, mView.getDumpableTag()); switchTileLayout(true); mDumpManager.registerDumpable(mView.getDumpableTag(), this);&#125; 这里主要做了以下几件事： 为 mHost 设置回调 mQSHostCallback，mQSHostCallback 会调用 setTiles()； 调用 setTiles() 设置要显示的 tile； 调用 switchTileLayout() 将承载 tile 的容器添加到 view tree 中 setTiles()1234567891011// class QuickQSPanelControllerpublic void setTiles() &#123; List&lt;QSTile&gt; tiles = new ArrayList&lt;&gt;(); for (QSTile tile : mHost.getTiles()) &#123; tiles.add(tile); if (tiles.size() == mView.getNumQuickTiles()) &#123; break; &#125; &#125; super.setTiles(tiles, /* collapsedView */ true);&#125; 调用 QSHost 的 getTiles() 获取所有 tile。QSHost 的实现类是 QSTileHost。 保留 mView.getNumQuickTiles() 数量的 tile 调用 super.setTiles(tiles, /* collapsedView */ true) switchTileLayout()1234567891011121314151617// class QSPanelControllerBaseboolean switchTileLayout(boolean force) &#123; /* Whether or not the panel currently contains a media player. */ boolean horizontal = shouldUseHorizontalLayout(); if (horizontal != mUsingHorizontalLayout || force) &#123; mQSLogger.logSwitchTileLayout(horizontal, mUsingHorizontalLayout, force, mView.getDumpableTag()); mUsingHorizontalLayout = horizontal; mView.setUsingHorizontalLayout(mUsingHorizontalLayout, mMediaHost.getHostView(), force); updateMediaDisappearParameters(); if (mUsingHorizontalLayoutChangedListener != null) &#123; mUsingHorizontalLayoutChangedListener.run(); &#125; return true; &#125; return false;&#125; 调用 mView.setUsingHorizontalLayout()，QuickQSPanelController 的 mView 是 QuickQSPanel。 QSTileHost1234// class QSTileHostpublic Collection&lt;QSTile&gt; getTiles() &#123; return mTiles.values();&#125; onTuningChanged()往 mTiles 中填充数据的过程发生在 onTuningChanged() 中。onTuningChanged() 是 TunerService 的回调。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// class QSTileHostpublic void onTuningChanged(String key, String newValue) &#123; if (!TILES_SETTING.equals(key)) &#123; return; &#125; if (newValue == null &amp;&amp; UserManager.isDeviceInDemoMode(mContext)) &#123; newValue = mContext.getResources().getString(R.string.quick_settings_tiles_retail_mode); &#125; final List&lt;String&gt; tileSpecs = loadTileSpecs(mContext, newValue); int currentUser = mUserTracker.getUserId(); if (currentUser != mCurrentUser) &#123; mUserContext = mUserTracker.getUserContext(); if (mAutoTiles != null) &#123; mAutoTiles.changeUser(UserHandle.of(currentUser)); &#125; &#125; if (tileSpecs.equals(mTileSpecs) &amp;&amp; currentUser == mCurrentUser) return; Log.d(TAG, &quot;Recreating tiles: &quot; + tileSpecs); mTiles.entrySet().stream().filter(tile -&gt; !tileSpecs.contains(tile.getKey())).forEach( tile -&gt; &#123; Log.d(TAG, &quot;Destroying tile: &quot; + tile.getKey()); mQSLogger.logTileDestroyed(tile.getKey(), &quot;Tile removed&quot;); tile.getValue().destroy(); &#125;); final LinkedHashMap&lt;String, QSTile&gt; newTiles = new LinkedHashMap&lt;&gt;(); for (String tileSpec : tileSpecs) &#123; QSTile tile = mTiles.get(tileSpec); if (tile != null &amp;&amp; (!(tile instanceof CustomTile) || ((CustomTile) tile).getUser() == currentUser)) &#123; if (tile.isAvailable()) &#123; if (DEBUG) Log.d(TAG, &quot;Adding &quot; + tile); tile.removeCallbacks(); if (!(tile instanceof CustomTile) &amp;&amp; mCurrentUser != currentUser) &#123; tile.userSwitch(currentUser); &#125; newTiles.put(tileSpec, tile); mQSLogger.logTileAdded(tileSpec); &#125; else &#123; tile.destroy(); Log.d(TAG, &quot;Destroying not available tile: &quot; + tileSpec); mQSLogger.logTileDestroyed(tileSpec, &quot;Tile not available&quot;); &#125; &#125; else &#123; // This means that the tile is a CustomTile AND the user is different, so let&#x27;s // destroy it if (tile != null) &#123; tile.destroy(); Log.d(TAG, &quot;Destroying tile for wrong user: &quot; + tileSpec); mQSLogger.logTileDestroyed(tileSpec, &quot;Tile for wrong user&quot;); &#125; Log.d(TAG, &quot;Creating tile: &quot; + tileSpec); try &#123; tile = createTile(tileSpec); if (tile != null) &#123; tile.setTileSpec(tileSpec); if (tile.isAvailable()) &#123; newTiles.put(tileSpec, tile); mQSLogger.logTileAdded(tileSpec); &#125; else &#123; tile.destroy(); Log.d(TAG, &quot;Destroying not available tile: &quot; + tileSpec); mQSLogger.logTileDestroyed(tileSpec, &quot;Tile not available&quot;); &#125; &#125; else &#123; Log.d(TAG, &quot;No factory for a spec: &quot; + tileSpec); &#125; &#125; catch (Throwable t) &#123; Log.w(TAG, &quot;Error creating tile for spec: &quot; + tileSpec, t); &#125; &#125; &#125; mCurrentUser = currentUser; List&lt;String&gt; currentSpecs = new ArrayList&lt;&gt;(mTileSpecs); mTileSpecs.clear(); mTileSpecs.addAll(newTiles.keySet()); // Only add the valid (available) tiles. mTiles.clear(); mTiles.putAll(newTiles); if (newTiles.isEmpty() &amp;&amp; !tileSpecs.isEmpty()) &#123; // If we didn&#x27;t manage to create any tiles, set it to empty (default) Log.d(TAG, &quot;No valid tiles on tuning changed. Setting to default.&quot;); changeTilesByUser(currentSpecs, loadTileSpecs(mContext, &quot;&quot;)); &#125; else &#123; String resolvedTiles = TextUtils.join(&quot;,&quot;, mTileSpecs); if (!resolvedTiles.equals(newValue)) &#123; // If the resolved tiles (those we actually ended up with) are different than // the ones that are in the setting, update the Setting. saveTilesToSettings(mTileSpecs); &#125; mTilesListDirty = false; for (int i = 0; i &lt; mCallbacks.size(); i++) &#123; mCallbacks.get(i).onTilesChanged(); &#125; &#125;&#125; 调用 loadTileSpecs() 加载 TileSpec。 在必要时，调用 createTile() 创建 tile 调用 mCallbacks 的 onTilesChanged() loadTileSpecs()123456789101112131415161718192021222324252627282930313233343536// class QSTileHostprotected static List&lt;String&gt; loadTileSpecs(Context context, String tileList) &#123; final Resources res = context.getResources(); if (TextUtils.isEmpty(tileList)) &#123; tileList = res.getString(R.string.quick_settings_tiles); if (DEBUG) Log.d(TAG, &quot;Loaded tile specs from default config: &quot; + tileList); &#125; else &#123; if (DEBUG) Log.d(TAG, &quot;Loaded tile specs from setting: &quot; + tileList); &#125; final ArrayList&lt;String&gt; tiles = new ArrayList&lt;String&gt;(); boolean addedDefault = false; Set&lt;String&gt; addedSpecs = new ArraySet&lt;&gt;(); for (String tile : tileList.split(&quot;,&quot;)) &#123; tile = tile.trim(); if (tile.isEmpty()) continue; if (tile.equals(&quot;default&quot;)) &#123; if (!addedDefault) &#123; List&lt;String&gt; defaultSpecs = QSHost.getDefaultSpecs(context); for (String spec : defaultSpecs) &#123; if (!addedSpecs.contains(spec)) &#123; tiles.add(spec); addedSpecs.add(spec); &#125; &#125; addedDefault = true; &#125; &#125; else &#123; if (!addedSpecs.contains(tile)) &#123; tiles.add(tile); addedSpecs.add(tile); &#125; &#125; &#125; return tiles;&#125; 这里会加载默认 TileSpec 和其他 TileSpec。默认 TileSpec 通过 QSHost.getDefaultSpecs() 获取。默认 TileSpec 写在了 R.string.quick_settings_tiles_default 中。 123&lt;string name=&quot;quick_settings_tiles_default&quot; translatable=&quot;false&quot;&gt; internet,bt,flashlight,dnd,alarm,airplane,nfc,rotation,battery,controls,wallet,cast,screenrecord&lt;/string&gt; createTile()12345678910// class QSTileHostpublic QSTile createTile(String tileSpec) &#123; for (int i = 0; i &lt; mQsFactories.size(); i++) &#123; QSTile t = mQsFactories.get(i).createTile(tileSpec); if (t != null) &#123; return t; &#125; &#125; return null;&#125; 调用 QSFactory 的 createTile() 创建磁贴。QSFactory 的实现类是 QSFactoryImpl。 1234567891011121314151617181920212223242526272829// class QSFactoryImplpublic final QSTile createTile(String tileSpec) &#123; QSTileImpl tile = createTileInternal(tileSpec); if (tile != null) &#123; tile.initialize(); tile.postStale(); // Tile was just created, must be stale. &#125; return tile;&#125;protected QSTileImpl createTileInternal(String tileSpec) &#123; // Stock tiles. if (mTileMap.containsKey(tileSpec) // We should not return a Garbage Monitory Tile if the build is not Eng &amp;&amp; (!tileSpec.equals(GarbageMonitor.MemoryTile.TILE_SPEC) || Build.IS_ENG)) &#123; return mTileMap.get(tileSpec).get(); &#125; // Custom tiles if (tileSpec.startsWith(CustomTile.PREFIX)) &#123; return CustomTile.create( mCustomTileBuilderProvider.get(), tileSpec, mQsHostLazy.get().getUserContext()); &#125; // Broken tiles. Log.w(TAG, &quot;No stock tile spec: &quot; + tileSpec); return null;&#125; 这里把 tile 分为了三类：Stock、Custom 和 Broken。Stock 为系统预制的 tile；Custom 为 App 自定义的 tile。Stock tile 从 mTileMap 中获取。mTileMap 中的数据是使用 Dagger 注入的。 QSFactoryImpl 的注释中说明了创建默认 tile 的方法。 12345要在 SystemUI 中创建新 tile，tile 类应扩展 &#123;@link QSTileImpl&#125; 并具有一个 public static final 字段 - TILE_SPEC，该字段充当该 tile 的唯一键。 （例如&#123;@link com.android.systemui.qs.tiles.DreamTile#TILE_SPEC&#125;）之后，创建或查找现有的 Module 类来容纳 tile 的 binding 方法（例如 &#123;@link com.android.systemui.accessibility.AccessibilityModule&#125;）。 如果创建新 Module，请将 Module 添加到 SystemUI dagger graph 中，方法是将其包含在适当的 Module 中。 createTileView()1234567891011// class QSTileHostpublic QSTileView createTileView(Context themedContext, QSTile tile, boolean collapsedView) &#123; for (int i = 0; i &lt; mQsFactories.size(); i++) &#123; QSTileView view = mQsFactories.get(i) .createTileView(themedContext, tile, collapsedView); if (view != null) &#123; return view; &#125; &#125; throw new RuntimeException(&quot;Default factory didn&#x27;t create view for &quot; + tile.getTileSpec());&#125; 12345// class QSFactoryImplpublic QSTileView createTileView(Context context, QSTile tile, boolean collapsedView) &#123; QSIconView icon = tile.createTileView(context); return new QSTileViewImpl(context, icon, collapsedView);&#125; QSPanelControllerBaseQuickQSPanelController 的 setTiles() 中，在获取到指定数量的 tile 后，就调用父类 QSPanelControllerBase 的 setTiles()。 12345678910111213141516// class QSPanelControllerBasepublic void setTiles(Collection&lt;QSTile&gt; tiles, boolean collapsedView) &#123; if (!collapsedView &amp;&amp; mQsTileRevealController != null) &#123; mQsTileRevealController.updateRevealedTiles(tiles); &#125; for (QSPanelControllerBase.TileRecord record : mRecords) &#123; mView.removeTile(record); record.tile.removeCallback(record.callback); &#125; mRecords.clear(); mCachedSpecs = &quot;&quot;; for (QSTile tile : tiles) &#123; addTile(tile, collapsedView); &#125;&#125; 先清空 ArrayList&lt;TileRecord&gt; 中的数据，再遍历调用 addTile()。 12345678910111213141516// class QSPanelControllerBaseprivate void addTile(final QSTile tile, boolean collapsedView) &#123; final TileRecord r = new TileRecord(tile, mHost.createTileView(getContext(), tile, collapsedView)); try &#123; QSTileViewImpl qsTileView = (QSTileViewImpl) (r.tileView); if (qsTileView != null) &#123; qsTileView.setQsLogger(mQSLogger); &#125; &#125; catch (ClassCastException e) &#123; Log.e(TAG, &quot;Failed to cast QSTileView to QSTileViewImpl&quot;, e); &#125; mView.addTile(r); mRecords.add(r); mCachedSpecs = getTilesSpecs();&#125; 调用 mHost.createTileView() 创建 QSTileView，然后构建 TileRecord 调用 mView.addTile() QSPanelsetUsingHorizontalLayout()调用 setUsingHorizontalLayout() 将承载 tile 的容器添加到 view tree 中 12345678910111213141516// class QSPanelvoid setUsingHorizontalLayout(boolean horizontal, ViewGroup mediaHostView, boolean force) &#123; if (horizontal != mUsingHorizontalLayout || force) &#123; Log.d(getDumpableTag(), &quot;setUsingHorizontalLayout: &quot; + horizontal + &quot;, &quot; + force); mUsingHorizontalLayout = horizontal; ViewGroup newParent = horizontal ? mHorizontalContentContainer : this; switchAllContentToParent(newParent, mTileLayout); reAttachMediaHost(mediaHostView, horizontal); if (needsDynamicRowsAndColumns()) &#123; mTileLayout.setMinRows(horizontal ? 2 : 1); mTileLayout.setMaxColumns(horizontal ? 2 : 4); &#125; updateMargins(mediaHostView); mHorizontalLinearLayout.setVisibility(horizontal ? View.VISIBLE : View.GONE); &#125;&#125; 调用 switchAllContentToParent(newParent, mTileLayout) 12345678910111213private void switchAllContentToParent(ViewGroup parent, QSTileLayout newLayout) &#123; int index = parent == this ? mMovableContentStartIndex : 0; // Let&#x27;s first move the tileLayout to the new parent, since that should come first. switchToParent((View) newLayout, parent, index); index++; if (mFooter != null) &#123; // Then the footer with the settings switchToParent(mFooter, parent, index); index++; &#125;&#125; 1234567891011121314151617181920212223static void switchToParent(View child, ViewGroup parent, int index, String tag) &#123; if (parent == null) &#123; Log.w(tag, &quot;Trying to move view to null parent&quot;, new IllegalStateException()); return; &#125; ViewGroup currentParent = (ViewGroup) child.getParent(); if (currentParent != parent) &#123; if (currentParent != null) &#123; currentParent.removeView(child); &#125; parent.addView(child, index); return; &#125; // Same parent, we are just changing indices int currentIndex = parent.indexOfChild(child); if (currentIndex == index) &#123; // We want to be in the same place. Nothing to do here return; &#125; parent.removeView(child); parent.addView(child, index);&#125; addTile()调用 addTile() 添加磁贴。 12345678910111213141516171819// class QSPanelvoid addTile(QSPanelControllerBase.TileRecord tileRecord) &#123; final QSTile.Callback callback = new QSTile.Callback() &#123; @Override public void onStateChanged(QSTile.State state) &#123; drawTile(tileRecord, state); &#125; &#125;; tileRecord.tile.addCallback(callback); tileRecord.callback = callback; tileRecord.tileView.init(tileRecord.tile); tileRecord.tile.refreshState(); if (mTileLayout != null) &#123; mTileLayout.addTile(tileRecord); tileClickListener(tileRecord.tile, tileRecord.tileView); &#125;&#125; 为 tile 设置 callback，即 drawTile(tileRecord, state) 调用 tileView 的 init()，对 QSTileView 进行初始化 调用 tile 的 refreshState() 刷新状态 调用 mTileLayout.addTile() mTileLayoutmTileLayout 的类型是 QSTileLayout 接口。其实现类在 QSPanel 中是 PagedTileLayout，在 QuickQSPanel 中是 QQSSideLabelTileLayout。 PagedTileLayoutPagedTileLayout 继承自 ViewPager 123456// class PagedTileLayoutpublic void addTile(TileRecord tile) &#123; mTiles.add(tile); forceTilesRedistribution(&quot;adding new tile&quot;); requestLayout();&#125; PagedTileLayout 的 PagerAdapter： 12345678910111213141516171819202122232425262728293031323334// class PagedTileLayoutprivate final PagerAdapter mAdapter = new PagerAdapter() &#123; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; mLogger.d(&quot;Destantiating page at&quot;, position); container.removeView((View) object); updateListening(); &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; mLogger.d(&quot;Instantiating page at&quot;, position); if (isLayoutRtl()) &#123; position = mPages.size() - 1 - position; &#125; ViewGroup view = mPages.get(position); if (view.getParent() != null) &#123; container.removeView(view); &#125; container.addView(view); updateListening(); return view; &#125; @Override public int getCount() &#123; return mPages.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return view == object; &#125;&#125;; PagerAdapter 的数据源是 mPages，mPages 是 ArrayList&lt;TileLayout&gt;，这里 TileLayout 的实现类是 SideLabelTileLayout。 mPages 的数据填充发生在 onFinishInflate() 和 onMeasure() 中。 1234567891011121314151617181920212223242526// class PagedTileLayoutprotected void onFinishInflate() &#123; super.onFinishInflate(); mPages.add(createTileLayout()); mAdapter.notifyDataSetChanged();&#125;protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; final int nTiles = mTiles.size(); // If we have no reason to recalculate the number of rows, skip this step. In particular, // if the height passed by its parent is the same as the last time, we try not to remeasure. if (mDistributeTiles || mLastMaxHeight != MeasureSpec.getSize(heightMeasureSpec) || mLastExcessHeight != mExcessHeight)&#123; mLastMaxHeight=MeasureSpec.getSize(heightMeasureSpec); mLastExcessHeight=mExcessHeight; // Only change the pages if the number of rows or columns (from updateResources) has // changed or the tiles have changed int availableHeight=mLastMaxHeight-mExcessHeight; if(mPages.get(0).updateMaxRows(availableHeight,nTiles)||mDistributeTiles)&#123; mDistributeTiles=false; distributeTiles(); &#125; ......&#125; 其中 distributeTiles() 会调用 emptyAndInflateOrRemovePages()： 1234567891011121314151617181920212223242526// class PagedTileLayoutprivate void emptyAndInflateOrRemovePages() &#123; final int numPages = getNumPages(); final int NP = mPages.size(); for (int i = 0; i &lt; NP; i++) &#123; mPages.get(i).removeAllViews(); &#125; if (NP == numPages) &#123; return; &#125; while (mPages.size() &lt; numPages) &#123; mLogger.d(&quot;Adding new page&quot;); mPages.add(createTileLayout()); &#125; while (mPages.size() &gt; numPages) &#123; mLogger.d(&quot;Removing page&quot;); mPages.remove(mPages.size() - 1); &#125; mPageIndicator.setNumPages(mPages.size()); setAdapter(mAdapter); mAdapter.notifyDataSetChanged(); if (mPageToRestore != NO_PAGE) &#123; setCurrentItem(mPageToRestore, false); mPageToRestore = NO_PAGE; &#125;&#125; 这里调用 getNumPages() 计算所需的 page 数。 12345678910111213// class PagedTileLayoutpublic int getNumPages() &#123; final int nTiles = mTiles.size(); // We should always have at least one page, even if it&#x27;s empty. int numPages = Math.max(nTiles / mPages.get(0).maxTiles(), 1); // Add one more not full page if needed if (nTiles &gt; numPages * mPages.get(0).maxTiles()) &#123; numPages++; &#125; return numPages;&#125; SideLabelTileLayout 的 maxTiles()： 1234567// class SideLabelTileLayoutpublic int maxTiles() &#123; // Each layout should be able to hold at least one tile. If there&#x27;s not enough room to // show even 1 or there are no tiles, it probably means we are in the middle of setting // up. return Math.max(mColumns * mRows, 1);&#125; 回到 distributeTiles() 中，处理完 mPages 的数据后，就把 mTiles 中的 Tile 分发到各个 page 中。 123456789101112131415// class PagedTileLayoutprivate void distributeTiles() &#123; emptyAndInflateOrRemovePages(); final int tilesPerPageCount = mPages.get(0).maxTiles(); int index = 0; final int totalTilesCount = mTiles.size(); mLogger.logTileDistributionInProgress(tilesPerPageCount, totalTilesCount); for (int i = 0; i &lt; totalTilesCount; i++) &#123; TileRecord tile = mTiles.get(i); if (mPages.get(index).mRecords.size() == tilesPerPageCount) index++; mLogger.logTileDistributed(tile.tile.getClass().getSimpleName(), index); mPages.get(index).addTile(tile); &#125;&#125; SideLabelTileLayout 没有重写 addTile()，所以这里调用父类 TileLayout 中的。 12345678910// class TileLayoutpublic void addTile(TileRecord tile) &#123; mRecords.add(tile); tile.tile.setListening(this, mListening); addTileView(tile);&#125;protected void addTileView(TileRecord tile) &#123; addView(tile.tileView);&#125; Tile 更新流程： QSTileImpl.refreshState() -&gt; handleRefreshState() QSTileImpl.handleRefreshState() -&gt; handleUpdateState() QSTileImpl.handleRefreshState() -&gt; handleStateChanged() QSTileImpl.handleStateChanged() -&gt; QSTile.Callback.onStateChanged() QSTile.Callback.onStateChanged() -&gt; QSPanel.drawTile() QSPanel.drawTile() -&gt; QSTileView.onStateChanged() QSTileView.onStateChanged() -&gt; QSTileViewImpl.handleStateChanged() Tile 测量流程从 SideLabelTileLayout 的 onMeasure() 开始。 123456789101112131415161718192021222324252627282930313233// class TileLayoutprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // If called with AT_MOST, it will limit the number of rows. If called with UNSPECIFIED // it will show all its tiles. In this case, the tiles have to be entered before the // container is measured. Any change in the tiles, should trigger a remeasure. final int numTiles = mRecords.size(); final int width = MeasureSpec.getSize(widthMeasureSpec); final int availableWidth = width - getPaddingStart() - getPaddingEnd(); final int heightMode = MeasureSpec.getMode(heightMeasureSpec); if (heightMode == MeasureSpec.UNSPECIFIED) &#123; mRows = (numTiles + mColumns - 1) / mColumns; &#125; final int gaps = mColumns - 1; mCellWidth = (availableWidth - (mCellMarginHorizontal * gaps) - mSidePadding * 2) / mColumns; // Measure each QS tile. View previousView = this; int verticalMeasure = exactly(getCellHeight()); for (TileRecord record : mRecords) &#123; if (record.tileView.getVisibility() == GONE) continue; record.tileView.measure(exactly(mCellWidth), verticalMeasure); previousView = record.tileView.updateAccessibilityOrder(previousView); mCellHeight = record.tileView.getMeasuredHeight(); &#125; int height = (mCellHeight + mCellMarginVertical) * mRows; height -= mCellMarginVertical; if (height &lt; 0) height = 0; setMeasuredDimension(width, height);&#125; 这里计算出 Tile 的宽高限制 mCellWidth 和 verticalMeasure，然后调用 QSTileView 的 measure()。 Tile 布局流程看 SideLabelTileLayout 的 onLayout()。 123456789101112131415161718192021222324252627282930313233343536373839// class TileLayoutprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; layoutTileRecords(mRecords.size(), true /* forLayout */);&#125;private void layoutTileRecords(int numRecords, boolean forLayout) &#123; final boolean isRtl = getLayoutDirection() == LAYOUT_DIRECTION_RTL; int row = 0; int column = 0; mLastTileBottom = 0; // Layout each QS tile. final int tilesToLayout = Math.min(numRecords, mRows * mColumns); for (int i = 0; i &lt; tilesToLayout; i++, column++) &#123; // If we reached the last column available to layout a tile, wrap back to the next row. if (column == mColumns) &#123; column = 0; row++; &#125; final TileRecord record = mRecords.get(i); final int top = getRowTop(row); final int left = getColumnStart(isRtl ? mColumns - column - 1 : column); final int right = left + mCellWidth; final int bottom = top + record.tileView.getMeasuredHeight(); if (forLayout) &#123; record.tileView.layout(left, top, right, bottom); &#125; else &#123; record.tileView.setLeftTopRightBottom(left, top, right, bottom); &#125; record.tileView.setPosition(i); // Set the bottom to the unoverriden squished bottom. This is to avoid fake bottoms that // are only used for QQS -&gt; QS expansion animations float scale = QSTileViewImplKt.constrainSquishiness(mSquishinessFraction); mLastTileBottom = top + (int) (record.tileView.getMeasuredHeight() * scale); &#125;&#125; 计算出 Tile 的四边坐标，然后调用 QSTileView 的 layout() 或 setLeftTopRightBottom()","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - Dagger","slug":"Android-Dagger","date":"2023-06-30T08:35:01.000Z","updated":"2023-07-18T03:58:47.425Z","comments":true,"path":"2023/06/30/Android-Dagger/","link":"","permalink":"https://azxkenzo.github.io/2023/06/30/Android-Dagger/","excerpt":"","text":"Dagger 基础根据项目的大小，Android 应用程序中的手动依赖项注入或服务定位器可能会出现问题。 可以通过使用 Dagger 管理依赖项来限制项目扩展时的复杂性。 Dagger 会自动生成模仿手写代码的代码。 由于代码是在编译时生成的，因此它是可追踪的，并且比 Guice 等其他基于反射的解决方案性能更高。 1注意：在 Android 上使用 Hilt 进行依赖注入。 Hilt 构建在 Dagger 之上，它提供了将 Dagger 依赖项注入合并到 Android 应用程序中的标准方法。 使用 Dagger 的好处Dagger 通过以下方式让你免于编写繁琐且容易出错的样板代码： 生成你在手动 DI 部分中手动实现的 AppContainer 代码（application graph）。 为 application graph 中可用的类创建工厂。 这就是内部满足依赖关系的方式。 决定是否重用依赖项或通过使用 scope 创建新实例。 使用 Dagger 子组件为特定流创建容器。 这可以通过在不再需要内存中的对象时释放它们来提高应用程序的性能。 只要你声明类的依赖项并指定如何使用注解来满足它们，Dagger 就会在构建时自动执行所有这些操作。 Dagger 生成的代码与你手动编写的代码类似。在内部，Dagger 创建一个 graph of objects，它可以引用该 graph of objects 来找到提供类实例的方法。 对于 graph 中的每个类，Dagger 都会生成一个工厂类型类，它在内部使用该类来获取该类型的实例。 在构建时，Dagger 会遍历你的代码并： 构建并验证 dependency graph，确保： 每个对象的依赖关系都可以得到满足，因此不存在运行时异常。 不存在依赖循环，因此不存在无限循环。 生成在运行时用于创建实际对象及其依赖项的类。 Dagger 中的一个简单用例：生成工厂为了演示如何使用 Dagger，让我们为 UserRepository 类创建一个简单的工厂，如下图所示： 定义 UserRepository 如下： 1234class UserRepository( private val localDataSource: UserLocalDataSource, private val remoteDataSource: UserRemoteDataSource) &#123; ... &#125; 将 @Inject 注释添加到 UserRepository 构造函数中，以便 Dagger 知道如何创建 UserRepository： 12345// @Inject lets Dagger know how to create instances of this objectclass UserRepository @Inject constructor( private val localDataSource: UserLocalDataSource, private val remoteDataSource: UserRemoteDataSource) &#123; ... &#125; 123456789101112public class UserRepository &#123; private final UserLocalDataSource userLocalDataSource; private final UserRemoteDataSource userRemoteDataSource; // @Inject lets Dagger know how to create instances of this object @Inject public UserRepository(UserLocalDataSource userLocalDataSource, UserRemoteDataSource userRemoteDataSource) &#123; this.userLocalDataSource = userLocalDataSource; this.userRemoteDataSource = userRemoteDataSource; &#125;&#125; 在上面的代码片段中，你告诉 Dagger： 如何使用 @Inject 注解的构造函数创建 UserRepository 实例。 它的依赖项是：UserLocalDataSource 和 UserRemoteDataSource。 现在 Dagger 知道如何创建 UserRepository 的实例，但不知道如何创建其依赖项。 如果你也注解其他类，Dagger 知道如何创建它们： 123// @Inject lets Dagger know how to create instances of these objectsclass UserLocalDataSource @Inject constructor() &#123; ... &#125;class UserRemoteDataSource @Inject constructor() &#123; ... &#125; Dagger componentDagger 可以在项目中创建 graph of the dependencies，以便在需要时找出应该从哪里获取这些依赖关系。 要让 Dagger 执行此操作，你需要创建一个接口并使用 @Component 进行注释。 Dagger 创建一个容器，就像手动依赖注入一样。 在 @Component 接口内部，你可以定义返回所需类实例的函数（即 UserRepository）。 @Component 告诉 Dagger 生成一个容器，其中包含满足其公开的类型所需的所有依赖项。 这称为 Dagger component； 它包含一个 graph，其中包含 Dagger 知道如何提供的对象及其各自的依赖项。 1234567// @Component makes Dagger create a graph of dependencies@Componentinterface ApplicationGraph &#123; // The return type of functions inside the component interface is // what can be provided from the container fun repository(): UserRepository&#125; 当你构建项目时，Dagger 会为你生成 ApplicationGraph 接口的实现：DaggerApplicationGraph。 通过其注释处理器，Dagger 创建了一个 dependency graph，该 dependency graph 由三个类（UserRepository、UserLocalDatasource 和 UserRemoteDataSource）之间的关系组成，只有一个入口点：获取 UserRepository 实例。 你可以按如下方式使用它： 1234// Create an instance of the application graphval applicationGraph: ApplicationGraph = DaggerApplicationGraph.create()// Grab an instance of UserRepository from the application graphval userRepository: UserRepository = applicationGraph.repository() Dagger 在每次请求时都会创建一个新的 UserRepository 实例。 123456val applicationGraph: ApplicationGraph = DaggerApplicationGraph.create()val userRepository: UserRepository = applicationGraph.repository()val userRepository2: UserRepository = applicationGraph.repository()assert(userRepository != userRepository2) 有时，你需要在容器中拥有唯一的依赖项实例。 你需要这个可能有几个原因： 你希望将此类型作为依赖项的其他类型共享同一实例，例如登录流中使用相同 LoginUserData 的多个 ViewModel 对象。 创建对象的成本很高，并且你不希望每次将其声明为依赖项（例如，JSON 解析器）时都创建一个新实例。 在示例中，你可能希望 graph 中有一个可用的唯一 UserRepository 实例，以便每次请求 UserRepository 时，你总是会获得相同的实例。这在你的示例中非常有用，因为在具有更复杂的 application graph 的现实应用程序中，你可能有多个取决于 UserRepository 的 ViewModel 对象，并且你不希望每次需要提供 UserRepository 时都创建 UserLocalDataSource 和 UserRemoteDataSource 的新实例 。 在手动依赖注入中，你可以通过将 UserRepository 的相同实例传递给 ViewModel 类的构造函数来实现此目的； 但在 Dagger 中，因为你不是手动编写该代码，所以你必须让 Dagger 知道你想要使用同一个实例。 这可以通过 scope annotation 来完成。 Scoping with Dagger你可以使用 scope annotation 将对象的生命周期限制为其 component 的生命周期。 这意味着每次需要提供该类型时都会使用相同的依赖项实例。 要在 ApplicationGraph 中请求存储库时拥有唯一的 UserRepository 实例，请对 @Component 接口和 UserRepository 使用相同的 scope annotation。 你可以使用 Dagger 使用的 javax.inject 包附带的 @Singleton 注释： 123456789101112131415// @Component 接口上的 scope 注解告知 Dagger// 用此注解（即 @Singleton）注释的类绑定到 graph 的生命周期// 因此每次请求该类型时都会提供该类型的相同实例。@Singleton@Componentinterface ApplicationGraph &#123; fun repository(): UserRepository&#125;// 使用 @Singleton scope（即 ApplicationGraph）将此类的 scope 限定为组件@Singletonclass UserRepository @Inject constructor( private val localDataSource: UserLocalDataSource, private val remoteDataSource: UserRemoteDataSource) &#123; ... &#125; 或者，你可以创建并使用自定义 scope annotation。 你可以按如下方式创建 scope annotation： 12345// Creates MyCustomScope@Scope@MustBeDocumented@Retention(value = AnnotationRetention.RUNTIME)annotation class MyCustomScope 然后，你可以像以前一样使用它 在这两种情况下，对象都具有用于注释 @Component 接口的相同 scope。 因此，每次调用 applicationGraph.repository() 时，你都会获得相同的 UserRepository 实例。 Using Dagger in Android apps最佳实践总结 只要有可能，就使用构造函数注入和 @Inject 将类型添加到 Dagger graph 中。 当它不是时：| 使用 @Binds 告诉 Dagger 接口应该具有哪个实现。 使用 @Provides 告诉 Dagger 如何提供你的项目不拥有的类。 你应该只在 component 中声明一次模块 根据使用注释的生命周期来命名 scope annotation。 示例包括 @ApplicationScope、@LoggedUserScope 和 @ActivityScope。 Adding dependencies要在项目中使用 Dagger，请将这些依赖项添加到应用程序的 build.gradle 文件中。 你可以在此 GitHub 项目中找到最新版本的 Dagger。 123456789// Kotlinplugins &#123; id &#x27;kotlin-kapt&#x27;&#125;dependencies &#123; implementation &#x27;com.google.dagger:dagger:2.x&#x27; kapt &#x27;com.google.dagger:dagger-compiler:2.x&#x27;&#125; 12345// Javadependencies &#123; implementation &#x27;com.google.dagger:dagger:2.x&#x27; annotationProcessor &#x27;com.google.dagger:dagger-compiler:2.x&#x27;&#125; Dagger in Android考虑一个具有图 1 中的依赖关系图的示例 Android 应用程序。 在 Android 中，你通常会创建一个位于 application 类中的 Dagger graph，因为你希望只要应用程序正在运行，该 graph 的实例就位于内存中。通过这种方式，该 graph 就附加到了应用程序生命周期中。 在某些情况下，你可能还希望 application context 在 graph 中可用。为此，你还需要将 graph 放在 Application 类中。 这种方法的优点之一是该 graph 可供其他 Android framework 类使用。 此外，它允许你在测试中使用自定义应用程序类，从而简化了测试。 因为生成 graph 的接口是用 @Component 注解的，所以你可以将其称为 ApplicationComponent 或 ApplicationGraph。你通常会在自定义 Application 类中保留该组件的一个实例，并在每次需要 application graph 时调用它，如以下代码片段所示： 12345678910// Definition of the Application graph@Componentinterface ApplicationComponent &#123; ... &#125;// appComponent lives in the Application class to share its lifecycleclass MyApplication: Application() &#123; // Reference to the application graph that is used across the whole app val appComponent = DaggerApplicationComponent.create()&#125; 由于某些 Android framework 类（例如 activities and fragments）是由系统实例化的，因此 Dagger 无法为你创建它们。 特别是对于 activity，任何初始化代码都需要进入 onCreate() 方法。 这意味着你不能像在前面的示例中那样在类的构造函数中使用 @Inject 注释（构造函数注入）。 相反，你必须使用字段注入。 你希望 Dagger 为你填充这些依赖项，而不是在 onCreate() 方法中创建 activity 所需的依赖项。 对于字段注入，你可以将 @Inject 注释应用于要从 Dagger graph 中获取的字段。 1234class LoginActivity: Activity() &#123; // You want Dagger to provide an instance of LoginViewModel from the graph @Inject lateinit var loginViewModel: LoginViewModel&#125; 为简单起见，LoginViewModel 不是 Android 架构组件 ViewModel； 它只是一个充当 ViewModel 的常规类。 有关如何注入这些类的更多信息，请查看 dev-dagger 分支中官方 Android Blueprints Dagger 实现中的代码。 Dagger 的考虑因素之一是注入的字段不能是私有的。 它们至少需要具有包私有可见性，如前面的代码所示。 1注意：字段注入只能用在不能使用构造函数注入的 Android 框架类中。 Injecting activitiesDagger 需要知道 LoginActivity 必须访问该 graph 才能提供它所需的 ViewModel。 在 Dagger 基础知识页面中，你使用 @Component 接口通过公开具有要从 graph 中获取的内容的返回类型的函数来从 graph 中获取对象。在这种情况下，你需要告诉 Dagger 需要注入依赖项的对象（本例中为 LoginActivity）。 为此，你公开一个函数，该函数将请求注入的对象作为参数。 123456@Componentinterface ApplicationComponent &#123; // This tells Dagger that LoginActivity requests injection so the graph needs to // satisfy all the dependencies of the fields that LoginActivity is requesting. fun inject(activity: LoginActivity)&#125; 该函数告诉 Dagger LoginActivity 想要访问该 graph 并请求注入。 Dagger 需要满足 LoginActivity 所需的所有依赖项（LoginViewModel 具有自己的依赖项）。 如果你有多个请求注入的类，则必须在组件中明确声明它们的确切类型。例如，如果你有 LoginActivity 和 RegistrationActivity 请求注入，则你将有两个 inject() 方法，而不是涵盖这两种情况的通用方法。通用的 inject() 方法不会告诉 Dagger 需要提供什么。 接口中的函数可以有任何名称，但在 Dagger 中，当它们接收要注入的对象作为参数时叫它们 inject() 是一种约定。 要在 activity 中注入对象，你可以使用 Application 类中定义的 appComponent 并调用 inject() 方法，传入请求注入的 activity 实例。 使用 Activity 时，请在调用 super.onCreate() 之前在 Activity 的 onCreate() 方法中注入 Dagger，以避免 fragment 恢复问题。在 super.onCreate() 的恢复阶段，Activity 会附加可能想要访问 activity 绑定的 fragment。 使用 fragment 时，在 fragment 的 onAttach() 方法中注入 Dagger。 在这种情况下，可以在调用 super.onAttach() 之前或之后完成。 1234567891011121314151617class LoginActivity: Activity() &#123; // You want Dagger to provide an instance of LoginViewModel from the graph @Inject lateinit var loginViewModel: LoginViewModel override fun onCreate(savedInstanceState: Bundle?) &#123; // 让 Dagger 在 LoginActivity 中实例化 @Inject 字段 (applicationContext as MyApplication).appComponent.inject(this) // Now loginViewModel is available super.onCreate(savedInstanceState) &#125;&#125;// @Inject tells Dagger how to create instances of LoginViewModelclass LoginViewModel @Inject constructor( private val userRepository: UserRepository) &#123; ... &#125; 让我们告诉 Dagger 如何提供其余的依赖项来构建 graph： 123456789class UserRepository @Inject constructor( private val localDataSource: UserLocalDataSource, private val remoteDataSource: UserRemoteDataSource) &#123; ... &#125;class UserLocalDataSource @Inject constructor() &#123; ... &#125;class UserRemoteDataSource @Inject constructor( private val loginService: LoginRetrofitService) &#123; ... &#125; Dagger modules在此示例中，你使用的是 Retrofit 网络库。 UserRemoteDataSource 依赖于 LoginRetrofitService。 但是，创建 LoginRetrofitService 实例的方法与你迄今为止所做的不同。 它不是一个类实例化；这是调用 Retrofit.Builder() 并传入不同参数来配置登录服务的结果。 除了 @Inject 注释之外，还有另一种方法告诉 Dagger 如何提供类的实例：Dagger 模块内的信息。 Dagger 模块是一个用 @Module 注解的类。 在那里，你可以使用 @Provides 注释定义依赖项。 1234567891011121314151617// @Module informs Dagger that this class is a Dagger Module@Moduleclass NetworkModule &#123; // @Provides tell Dagger how to create instances of the type that this function // returns (i.e. LoginRetrofitService). // Function parameters are the dependencies of this type. @Provides fun provideLoginRetrofitService(): LoginRetrofitService &#123; // Whenever Dagger needs to provide an instance of type LoginRetrofitService, // this code (the one inside the @Provides method) is run. return Retrofit.Builder() .baseUrl(&quot;https://example.com&quot;) .build() .create(LoginService::class.java) &#125;&#125; 123注意：你可以在 Dagger 模块中使用 @Provides 注释来告诉 Dagger 如何提供你的项目不拥有的类（例如 Retrofit 的实例）。对于接口的实现，最佳实践是使用 @Binds 模块是一种从语义上封装有关如何提供对象的信息的方法。 正如你所看到的，你调用了 NetworkModule 类来对提供与网络相关的对象的逻辑进行分组。 如果应用扩展，还可以在这里添加如何提供 OkHttpClient，或者如何配置 Gson 或 Moshi。 @Provides 方法的依赖项是该方法的参数。 对于前面的方法，LoginRetrofitService 可以不提供依赖项，因为该方法没有参数。 如果你已声明 OkHttpClient 作为参数，Dagger 需要从 graph 中提供 OkHttpClient 实例来满足 LoginRetrofitService 的依赖关系。 例如： 12345678@Moduleclass NetworkModule &#123; // Hypothetical dependency on LoginRetrofitService @Provides fun provideLoginRetrofitService( okHttpClient: OkHttpClient ): LoginRetrofitService &#123; ... &#125;&#125; 为了让 Dagger graph 了解这个模块，你必须将其添加到 @Component 接口，如下所示： 123456// The &quot;modules&quot; attribute in the @Component annotation tells Dagger what Modules// to include when building the graph@Component(modules = [NetworkModule::class])interface ApplicationComponent &#123; ...&#125; 向 Dagger graph 中添加类型的推荐方法是使用构造函数注入（即在类的构造函数上使用 @Inject 注释）。 有时，这是不可能的，你必须使用 Dagger 模块。一个例子是当你希望 Dagger 使用计算结果来确定如何创建对象的实例时。 每当需要提供该类型的实例时，Dagger 都会运行 @Provides 方法内的代码。 这就是示例中的 Dagger graph 现在的样子： 该 graph 的入口点是 LoginActivity。 由于 LoginActivity 注入 LoginViewModel，Dagger 构建了一个 graph，该 graph 知道如何提供 LoginViewModel 的实例，并递归地提供其依赖项。 Dagger 知道如何执行此操作，因为类构造函数上有 @Inject 注释。 在 Dagger 生成的 ApplicationComponent 内部，有一个工厂类型的方法来获取它知道如何提供的所有类的实例。 在此示例中，Dagger 委托给 ApplicationComponent 中包含的 NetworkModule 来获取 LoginRetrofitService 的实例。 Dagger scopesDagger 基础知识页面上提到了 scope 作为在组件中拥有类型的唯一实例的一种方式。 这就是将类型的 scope 限定到组件的生命周期的含义。 由于你可能希望在应用程序的其他功能中使用 UserRepository，并且可能不希望每次需要时都创建一个新对象，因此你可以将其指定为整个应用程序的唯一实例。LoginRetrofitService 也是如此：创建成本可能很高，而且你还希望重用该对象的唯一实例。 创建 UserRemoteDataSource 的实例并不那么昂贵，因此没有必要将其 scope 限定到组件的生命周期。 @Singleton 是 javax.inject 包附带的唯一 scope 注释。 你可以使用它来注释 ApplicationComponent 以及你想要在整个 application 中重用的对象。 12345678910111213141516171819@Singleton@Component(modules = [NetworkModule::class])interface ApplicationComponent &#123; fun inject(activity: LoginActivity)&#125;@Singletonclass UserRepository @Inject constructor( private val localDataSource: UserLocalDataSource, private val remoteDataSource: UserRemoteDataSource) &#123; ... &#125;@Moduleclass NetworkModule &#123; // Way to scope types inside a Dagger Module @Singleton @Provides fun provideLoginRetrofitService(): LoginRetrofitService &#123; ... &#125;&#125; 1注意：使用 scope 注释的模块只能在使用相同 scope 注释的组件中使用。 将 scope 应用于对象时，请注意不要引入内存泄漏。 只要 scoped component 位于内存中，创建的对象也位于内存中。 因为 ApplicationComponent 是在应用程序启动时创建的（在 Application 类中），所以当应用程序被销毁时它也会被销毁。 因此，UserRepository 的唯一实例始终保留在内存中，直到应用程序被销毁。 1注意：使用构造函数注入（使用 @Inject）时在类中添加 scope 注释，并在使用 Dagger 模块时将它们添加到 @Provides 方法中。 Dagger subcomponents如果你的登录流（由单个 LoginActivity 管理）包含多个 fragment，则应在所有 fragment 中重用相同的 LoginViewModel 实例。 @Singleton 无法注释 LoginViewModel 以重用实例，原因如下： 流程完成后，LoginViewModel 的实例将保留在内存中。 你需要为每个登录流程使用不同的 LoginViewModel 实例。 例如，如果用户注销，你需要一个不同的 LoginViewModel 实例，而不是与用户第一次登录时相同的实例。 要将 LoginViewModel 的 scope 限定为 LoginActivity 的生命周期，你需要为登录流程和新 scope 创建一个新组件（新的 subgraph）。 让我们创建一个特定于登录流程的 graph。 12@Componentinterface LoginComponent &#123;&#125; 现在，LoginActivity 应该从 LoginComponent 获取注入，因为它具有特定于登录的配置。 这消除了从 ApplicationComponent 类注入 LoginActivity 的责任。 1234@Componentinterface LoginComponent &#123; fun inject(activity: LoginActivity)&#125; LoginComponent 必须能够访问 ApplicationComponent 中的对象，因为 LoginViewModel 依赖于 UserRepository。 告诉 Dagger 你希望新组件使用另一个组件的一部分的方法是使用 Dagger subcomponent。 新组件必须是包含共享资源的组件的 subcomponent。 Subcomponent 是继承并扩展父组件的 object graph 的组件。 因此，父组件中提供的所有对象也在子组件中提供。 这样，子组件中的对象可以依赖于父组件提供的对象。 要创建子组件的实例，你需要父组件的实例。 因此，父组件向子组件提供的对象的 scope 仍然是父组件。 在示例中，你必须将 LoginComponent 定义为 ApplicationComponent 的子组件。 为此，请使用 @Subcomponent 注释 LoginComponent： 123456789// @Subcomponent annotation informs Dagger this interface is a Dagger Subcomponent@Subcomponentinterface LoginComponent &#123; // This tells Dagger that LoginActivity requests injection from LoginComponent // so that this subcomponent graph needs to satisfy all the dependencies of the // fields that LoginActivity is injecting fun inject(loginActivity: LoginActivity)&#125; 你还必须在 LoginComponent 中定义一个子组件工厂，以便 ApplicationComponent 知道如何创建 LoginComponent 的实例。 1234567891011@Subcomponentinterface LoginComponent &#123; // Factory that is used to create instances of this subcomponent @Subcomponent.Factory interface Factory &#123; fun create(): LoginComponent &#125; fun inject(loginActivity: LoginActivity)&#125; 要告诉 Dagger LoginComponent 是 ApplicationComponent 的子组件，你必须通过以下方式指示它： 创建一个新的 Dagger 模块（例如 SubcomponentsModule），将子组件的类传递给注释的 subcomponents 属性。 1234// The &quot;subcomponents&quot; attribute in the @Module annotation tells Dagger what// Subcomponents are children of the Component this module is included in.@Module(subcomponents = LoginComponent::class)class SubcomponentsModule &#123;&#125; 将新模块（即 SubcomponentsModule）添加到 ApplicationComponent： 123456// Including SubcomponentsModule, tell ApplicationComponent that// LoginComponent is its subcomponent.@Singleton@Component(modules = [NetworkModule::class, SubcomponentsModule::class])interface ApplicationComponent &#123;&#125; 请注意，ApplicationComponent 不再需要注入 LoginActivity，因为该责任现在属于 LoginComponent，因此你可以从 ApplicationComponent 中删除 inject() 方法。 ApplicationComponent 的使用者需要知道如何创建 LoginComponent 的实例。 父组件必须在其接口中添加一个方法，以允许使用者从父组件的实例中创建子组件的实例： 在接口中公开创建 LoginComponent 实例的工厂： 1234567@Singleton@Component(modules = [NetworkModule::class, SubcomponentsModule::class])interface ApplicationComponent &#123;// This function exposes the LoginComponent Factory out of the graph so consumers// can use it to obtain new instances of LoginComponentfun loginComponent(): LoginComponent.Factory&#125; Assigning scopes to subcomponents如果构建项目，则可以创建 ApplicationComponent 和 LoginComponent 的实例。 ApplicationComponent 附加到 application 的生命周期，因为只要 application 位于内存中，你就希望使用同一 graph 实例。 LoginComponent 的生命周期是怎样的？ 你需要 LoginComponent 的原因之一是因为你需要在与登录相关的 fragment 之间共享相同的 LoginViewModel 实例。而且，每当有新的登录流程时，你都需要 LoginViewModel 的不同实例。 LoginActivity 是 LoginComponent 的正确生命周期：对于每个新 activity，你需要一个新的 LoginComponent 实例和可以使用该 LoginComponent 实例的 fragment。 由于 LoginComponent 附加到 LoginActivity 生命周期，因此你必须在 activity 中保留对组件的引用，就像在 Application 类中保留对 applicationComponent 的引用一样。 这样，fragment 就可以访问它。 12345class LoginActivity: Activity() &#123; // Reference to the Login graph lateinit var loginComponent: LoginComponent ...&#125; 请注意，变量 loginComponent 未使用 @Inject 进行注释，因为你不希望 Dagger 提供该变量。 你可以使用 ApplicationComponent 获取对 LoginComponent 的引用，然后注入 LoginActivity，如下所示： 1234567891011121314151617181920class LoginActivity: Activity() &#123; // Reference to the Login graph lateinit var loginComponent: LoginComponent // Fields that need to be injected by the login graph @Inject lateinit var loginViewModel: LoginViewModel override fun onCreate(savedInstanceState: Bundle?) &#123; // Creation of the login graph using the application graph loginComponent = (applicationContext as MyDaggerApplication) .appComponent.loginComponent().create() // Make Dagger instantiate @Inject fields in LoginActivity loginComponent.inject(this) // Now loginViewModel is available super.onCreate(savedInstanceState) &#125;&#125; LoginComponent 是在 Activity 的 onCreate() 方法中创建的，当 Activity 被销毁时，它会被隐式销毁。 每次请求时，LoginComponent 必须始终提供相同的 LoginViewModel 实例。 你可以通过创建自定义注释 scope 并用它注释 LoginComponent 和 LoginViewModel 来确保这一点。请注意，你不能使用 @Singleton 注释，因为它已被父组件使用，这会使该对象成为 application 单例（整个应用程序的唯一实例）。 你需要创建不同的注释 scope。 1234567注意：scope 规则如下： 当一个类型被标记了 scope 注释时，它只能被具有相同 scope 注释的组件使用。 当组件使用 scope 注释进行标记时，它只能提供具有该注释的类型或不具有注释的类型。 子组件不能使用其父组件之一所使用的 scope 注释。在这种情况下，组件还涉及子组件。 在这种情况下，你可以将此 scope 称为 @LoginScope，但这不是一个好的做法。 scope 注释的名称不应明确说明其所实现的目的。相反，它应该根据其生命周期来命名，因为注释可以被同级组件（例如 RegistrationComponent 和 SettingsComponent）重用。这就是为什么你应该将其命名为 @ActivityScope 而不是 @LoginScope。 1234567891011121314151617// Definition of a custom scope called ActivityScope@Scope@Retention(value = AnnotationRetention.RUNTIME)annotation class ActivityScope// Classes annotated with @ActivityScope are scoped to the graph and the same// instance of that type is provided every time the type is requested.@ActivityScope@Subcomponentinterface LoginComponent &#123; ... &#125;// A unique instance of LoginViewModel is provided in Components// annotated with @ActivityScope@ActivityScopeclass LoginViewModel @Inject constructor( private val userRepository: UserRepository) &#123; ... &#125; 现在，如果你有两个需要 LoginViewModel 的 fragment，则它们都提供有相同的实例。 例如，如果你有 LoginUsernameFragment 和 LoginPasswordFragment，它们需要由 LoginComponent 注入： 12345678910111213141516@ActivityScope@Subcomponentinterface LoginComponent &#123; @Subcomponent.Factory interface Factory &#123; fun create(): LoginComponent &#125; // All LoginActivity, LoginUsernameFragment and LoginPasswordFragment // request injection from LoginComponent. The graph needs to satisfy // all the dependencies of the fields those classes are injecting fun inject(loginActivity: LoginActivity) fun inject(usernameFragment: LoginUsernameFragment) fun inject(passwordFragment: LoginPasswordFragment)&#125; 这些组件访问 LoginActivity 对象中的组件实例。 LoginUserNameFragment 的示例代码显示在以下代码片段中： 12345678910111213141516class LoginUsernameFragment: Fragment() &#123; // Fields that need to be injected by the login graph @Inject lateinit var loginViewModel: LoginViewModel override fun onAttach(context: Context) &#123; super.onAttach(context) // Obtaining the login graph from LoginActivity and instantiate // the @Inject fields with objects from the graph (activity as LoginActivity).loginComponent.inject(this) // Now you can access loginViewModel here and onCreateView too // (shared instance with the Activity and the other Fragment) &#125;&#125; 图 3 显示了带有新子组件的 Dagger graph的外观。 带白点的类（UserRepository、LoginRetrofitService 和 LoginViewModel）是具有其各自组件范围的唯一实例的类。 让我们分解一下 graph 的各个部分： NetworkModule（以及 LoginRetrofitService）包含在 ApplicationComponent 中，因为你在组件中指定了它。 UserRepository 保留在 ApplicationComponent 中，因为它的作用域为 ApplicationComponent。 如果项目不断增长，你希望在不同功能（例如注册）之间共享相同的实例。由于 UserRepository 是 ApplicationComponent 的一部分，因此它的依赖项（即 UserLocalDataSource 和 UserRemoteDataSource）也需要位于该组件中，以便能够提供 UserRepository 的实例。 LoginViewModel 包含在 LoginComponent 中，因为只有 LoginComponent 注入的类才需要它。 LoginViewModel 不包含在 ApplicationComponent 中，因为 ApplicationComponent 中没有依赖项需要 LoginViewModel。类似地，如果你没有将 UserRepository 范围限定为 ApplicationComponent，Dagger 会自动将 UserRepository 及其依赖项作为 LoginComponent 的一部分包含在内，因为这是当前唯一使用 UserRepository 的地方。 除了将对象的范围限定到不同的生命周期之外，创建子组件是将应用程序的不同部分相互封装的一个好习惯。 根据应用程序的流程构建应用程序以创建不同的 Dagger 子图有助于在内存和启动时间方面实现更高性能和可扩展的应用程序。 Best practices when building a Dagger graph为你的应用程序构建 Dagger graph 时： 创建组件时，你应该考虑哪个元素负责该组件的生命周期。 在本例中，Application 类负责 ApplicationComponent，LoginActivity 负责 LoginComponent。 仅在有意义时才使用 scope。 过度使用 scope 会对应用程序的运行时性能产生负面影响：只要组件位于内存中，对象就位于内存中，并且获取 scope 对象的成本更高。 当 Dagger 提供对象时，它使用 DoubleCheck 锁定而不是工厂类型提供程序。 Working with Dagger modulesDagger 模块是一种封装如何以语义方式提供对象的方法。 你可以在组件中包含模块，但也可以在其他模块中包含模块。 这很强大，但很容易被滥用。 一旦一个模块被添加到一个组件或另一个模块中，它就已经在 Dagger graph 中了； Dagger 可以在该组件中提供这些对象。 在添加模块之前，请检查该模块是否已是 Dagger graph 的一部分，方法是检查该模块是否已添加到组件中，或者编译项目并查看 Dagger 是否可以找到该模块所需的依赖项。 良好的实践表明，模块只能在组件中声明一次（在特定的高级 Dagger 用例之外）。 假设你以这种方式配置了 graph。 ApplicationComponent 包括 Module1 和 Module2，Module1 包括 ModuleX。 12345678@Component(modules = [Module1::class, Module2::class])interface ApplicationComponent &#123; ... &#125;@Module(includes = [ModuleX::class])class Module1 &#123; ... &#125;@Moduleclass Module2 &#123; ... &#125; 如果现在 Module2 依赖于 ModuleX 提供的类。 不好的做法是将 ModuleX 包含在 Module2 中，因为 ModuleX 在 graph 中包含了两次，如以下代码片段所示： 123456789// Bad practice: ModuleX is declared multiple times in this Dagger graph@Component(modules = [Module1::class, Module2::class])interface ApplicationComponent &#123; ... &#125;@Module(includes = [ModuleX::class])class Module1 &#123; ... &#125;@Module(includes = [ModuleX::class])class Module2 &#123; ... &#125; 相反，你应该执行以下操作之一： 重构模块并将公共模块提取到组件中。 使用两个模块共享的对象创建一个新模块，并将其提取到组件中。 不以这种方式重构会导致许多模块相互包含而没有清晰的组织感，并且更难以看出每个依赖项来自何处。 良好实践（选项 1）：ModuleX 在 Dagger graph 中声明一次。 12345678@Component(modules = [Module1::class, Module2::class, ModuleX::class])interface ApplicationComponent &#123; ... &#125;@Moduleclass Module1 &#123; ... &#125;@Moduleclass Module2 &#123; ... &#125; 良好实践（选项 2）：ModuleX 中 Module1 和 Module2 的公共依赖项被提取到包含在组件中的名为 ModuleXCommon 的新模块中。 然后，使用特定于每个模块的依赖项创建另外两个名为 ModuleXWithModule1Dependency 和 ModuleXWithModule2Dependency 的模块。 所有模块都在 Dagger graph 中声明一次。 1234567891011121314151617@Component(modules = [Module1::class, Module2::class, ModuleXCommon::class])interface ApplicationComponent &#123; ... &#125;@Moduleclass ModuleXCommon &#123; ... &#125;@Moduleclass ModuleXWithModule1SpecificDependencies &#123; ... &#125;@Moduleclass ModuleXWithModule2SpecificDependencies &#123; ... &#125;@Module(includes = [ModuleXWithModule1SpecificDependencies::class])class Module1 &#123; ... &#125;@Module(includes = [ModuleXWithModule2SpecificDependencies::class])class Module2 &#123; ... &#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"JVM - 类加载机制","slug":"JVM-类加载机制","date":"2023-06-05T02:36:00.000Z","updated":"2023-07-18T04:22:50.342Z","comments":true,"path":"2023/06/05/JVM-类加载机制/","link":"","permalink":"https://azxkenzo.github.io/2023/06/05/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。 类加载的时机一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备、解析三个部分统称为连接。 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（动态绑定或晚期绑定）。 关于在什么情况下需要开始类加载过程的第一个阶段 “加载”，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，则是严格规定了有且只有六种情况必须立即对类进行 “初始化”： 遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有： 使用 new 关键字实例化对象的时候 读取或设置一个类型的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候 调用一个类型的静态方法的时候 使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个类。 当使用JDK 7新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。 当一个接口中定义了JDK 8新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在之前被初始化。 对于这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语—— “有且只有”，这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。下面举三个例子来说明何为被动引用。 1234567891011121314151617181920212223242526/** * 被动使用类字段演示一： * 通过子类引用父类的静态字段，不会导致子类初始化 */class SuperClass &#123; static &#123; System.out.println(&quot;SuperClass init&quot;); &#125; public static int value = 123;&#125;class SubClass extends SuperClass &#123; static &#123; System.out.println(&quot;SubClass init&quot;); &#125;&#125;/** * 非主动使用类字段演示 */public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); &#125;&#125; 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证阶段，在《Java虚拟机规范》中并未明确规定，所以这点取决于虚拟机的具体实现。 123456789/** * 被动使用类字段演示二： * 通过数组定义来引用类，不会触发此类的初始化 */class NotInitialization &#123; public static void main(String[] args) &#123; SuperClass[] sca = new SuperClass[10]; &#125;&#125; 这段代码运行之后没有输出 “SuperClass init”，说明并没有触发类 org.test.SuperClass 的初始化阶段。但是这段代码里面触发了另一个名为 “[Lorg.test.SuperClass” 的类的初始化阶段，对于用户代码来说，这并不是一个合法的类型名称，它是个由虚拟机自动生成的、直接继承于 java.lang.Object 的子类，创建动作由字节码指令 anewarray 触发。 这个类代表了一个元素类型为 org.test.SuperClass 的一维数组，数组中应用的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里。Java语言中对数组的访问要比 C&#x2F;C++ 相对安全，很大程度上就是因为这个类包装了数组元素的访问，而 C&#x2F;C++ 中则是直接翻译为对数组指针的移动。 1234567891011121314151617181920/** * 被动使用类字段演示三： * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化 */class ConstClass &#123; static &#123; System.out.println(&quot;ConstClass init&quot;); &#125; public static final String HELLO = &quot;Hello&quot;;&#125;/** * 非主动使用类字段演示 */class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(ConstClass.HELLO); &#125;&#125; 虽然在Java源码中确实引用了ConstClass类的常量 HELLO，但其实在编译阶段通过常量传播优化，已经将此常量的值 “Hello” 直接存储在 NotInitialization 类的常量池中，以后 NotInitialization 对常量 ConstClass.HELLO 的引用，实际都被转化为 NotInitialization 类对自身常量池的引用了。 接口的加载过程与类加载过程稍有不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块 “static {}” 来输出初始化信息的，而接口中不能使用 “static {}” 语句块，但编译器仍然会为接口生成 “&lt;clinit&gt;()” 类构造器，用于初始化接口中所定义的成员变量。接口与类真正有所区别的是前面讲述的六种 “有且仅有” 需要触发初始化场景的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。 类加载的过程加载“加载” 阶段是整个 “类加载” 过程中的一个阶段。在加载阶段，Java虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口 《Java虚拟机规范》对这三点要求其实并不是特别具体，留给虚拟机实现与Java应用的灵活度都是相当大的。例如 “通过一个类的全限定名来获取定义此类的二进制字节流” 这条规则，它并没有指明二进制字节流必须得从某个Class文件中获取，确切的说是根本没有指明要从哪里获取、如何获取。例如： 从 ZIP 压缩包中读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。 从网络中获取，这种场景最典型的应用就是Web Applet。 运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass() 来为特定接口生成形式为 “*$Proxy” 的代理类的二进制字节流 由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件 从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。 可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探 相对于类加载过程的其他阶段，非数组类型的加载阶段（准确的说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的阶段。加载阶段既可以使用 Java虚拟机里内置的启动类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的 findClass() 或 loadClass() 方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。 对于数组类而言，情况有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载，一个数组类（下面简称为 C）创建过程遵循以下规则： 如果数组的组件类型（指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将被标识在加载该组件类型的类加载器的类名称空间上 如果数组的组件类型不是引用类型（例如 int[] 数组的组件类型为 int），Java虚拟机将会把数组 C 标记为与启动类加载器关联 数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为 public，可被所有的类和接口访问到 加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个 java.lang.Class 类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。 加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。 验证验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。 Java语言本身是相对安全的编程语言，使用纯粹的Java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果尝试这样去做了，编译器会抛出异常、拒绝编译。但前面也曾说过，Class文件并不一定只能由Java源码编译而来，它可以使用包括靠键盘0和1直接在二进制编辑器中敲出Class文件在内的任何途径产生。上述Java代码无法做到的事情在字节码层面上都是可以实现的，至少语义上是可以表达出来的。Java虚拟机如果不检查输入的字节流，对齐完全信任的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃，所以验证字节码是Java虚拟机保护自身的一项必要措施。 验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击，从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。 1. 文件格式验证第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。 该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。 2. 元数据验证第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。 第二阶段的主要目的是对雷德元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。 3. 字节码验证第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。 4. 符号引用验证最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。 准备准备阶段是正式为类中定义的变量（即静态变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK 7之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 7及之后，类变量则会随着Class对象一起存放在Java堆中，这时候 “类变量在方法区” 就完全是一种对逻辑概念的表述了。 关于准备阶段，还有两个容易产生混淆的概念需要着重强调，首先是这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次是这里所说的初始值 “通常情况” 下是数据类型的零值。 上面提到在 “通常情况” 下初始值是零值，那言外之意是相对的会有某些 “特殊情况” ：如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量值就会被初始化为 ConstantValue 属性所指定的初始值。 解析解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，在Class文件中符号引用以 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的常量出现。 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。 直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。 《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行 anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield 和 pustatic 这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。 类似地，对方法或者字段的访问，也会在解析阶段中对它们的可访问性进行检查。 对同一个符号引用进行多次解析请求是很常见的事情，除 invokedynamic 指令之外，虚拟机实现可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。无论是否真正执行了多次解析动作，Java虚拟机都需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功；同样地，如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中。 …… 初始化类的初始化阶段是类加载过程的最后一个步骤。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码。 进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据通过程序编码指定的主观计划去初始化类变量和其他资源。也可以从另外一种更直接的形式来表达：初始化阶段就是执行类构造器 &lt;clinit&gt;() 方法的过程。&lt;clinit&gt;() 并不是在Java代码中直接编写的方法，它是Javac编译器的自动生成物。 &lt;clinit&gt;() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。 &lt;clinit&gt;() 方法与类的构造函数（即在虚拟机视角中的实例构造器 &lt;init&gt;() 方法）不同，它不需要显式调用父类构造器，Java虚拟机会保证在子类的 &lt;clinit&gt;() 方法执行前，父类的 &lt;clinit&gt;() 方法已经执行完毕。 由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。 &lt;clinit&gt;() 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 &lt;clinit&gt;() 方法。 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。 Java虚拟机必须保证一个类的 &lt;clinit&gt;() 方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的 &lt;clinit&gt;() 方法，其他线程都需要阻塞等待，直到活动线程执行完毕 &lt;clinit&gt;() 方法。 类加载器","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://azxkenzo.github.io/tags/JVM/"}]},{"title":"JVM - 线程安全与锁优化","slug":"JVM-线程安全与锁优化","date":"2023-06-03T01:17:10.000Z","updated":"2023-07-18T04:22:50.362Z","comments":true,"path":"2023/06/03/JVM-线程安全与锁优化/","link":"","permalink":"https://azxkenzo.github.io/2023/06/03/JVM-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/","excerpt":"","text":"线程安全当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。 这个定义要求线程安全的代码都必须具备一个共同特征：代码本身封装了所有必要的正确性保障措施（如互斥同步等），令调用者无需关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用。 Java语言中的线程安全接下来就讨论一下：在Java语言中，线程安全具体是如何体现的？有哪些操作是线程安全的？这里讨论的线程安全，将以多个线程之间存在共享数据访问为前提。 为了更深入地理解线程安全，在这里可以不把线程安全当作一个非真即假的二元排他选项来看待，而是按照线程安全的 “安全程度” 由强至弱来排序，可以将Java语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 1. 不可变在Java语言里面，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。 Java语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用 final 关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。类比 java.lang.String 类的对象实例，它是一个典型的不可变对象，用户调用它的 substring()、replace() 和 concat() 这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。 保证对象行为不影响自己状态的途径有跟多种，最简单的一种就是把对象里面带有状态的变量都声明为 final，这样在构造函数结束之后，它就是不可变的。如 java.lang.Integer 的构造函数，它通过把内部状态变量 value 定义为 final 来保障状态不变。 在Java类库API中符合不可变要求的类型，除了上面提到的String之外，常用的还有枚举类型及 java.lang.Number 的部分子类，如 Long 和 Double 等数值包装类型、BigInteger 和 BigDecimal 等大数据类型。但同为 Number 子类型的原子类 AtomicInteger 和 AtomicLong 则是可变的，不妨看看这两个原子类的源码，想一想为什么它们要设计成可变的。 2. 绝对线程安全绝对的线程安全能够完全满足上面给出的线程安全的定义，这个定义是很严格的，一个类要达到 “不管运行时环境如何，调用者都不需要任何额外的同步措施” 可能需要付出非常高昂的，甚至不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。可以通过Java API中一个不是 “绝对线程安全” 的 “线程安全类型” 来看看这个预警里的 “绝对” 究竟是什么意思。 如果说 java.util.Vector 是一个线程安全的容器，相信对此都不会有异议，因为它的 add()、get() 和 size() 等方法都是被 synchronized 修饰的，尽管这样效率不高，但保证了具备原子性、可见性和有序性。不过，即使它所有的方法都被修饰成 synchronized，也不意味着调用它的时候就永远不再需要同步手段了，看下面测试带代码。 1234567891011121314151617181920212223242526272829303132private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;();public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;); Thread printThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println(vector.get(i)); &#125; &#125; &#125;); removeThread.start(); printThread.start(); while (Thread.activeCount() &gt; 20) ; &#125;&#125; 很明显，尽管这里使用到的 Vector 的 get()、remove() 和 size() 都是同步的，但是在多线程的环境中，如果不在方法调用端做额外的同步措施，使用这段代码仍然是不安全的。因为如果另一个线程恰好在错误的时间里删除了一个元素，导致序号 i 已经不再可用，再用 i 访问数组就会抛出异常。如果要保证这段代码能正确执行下去，就不得不把 removeThread 和 printThread 的定义改成如下所示这样。 123456789101112131415161718192021Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (vector) &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;&#125;);Thread printThread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (vector) &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println(vector.get(i)); &#125; &#125; &#125;&#125;); 假如 Vector 一定要做到绝对的线程安全，那就必须在它内部维护一组一致性的快照访问才行，每次对其中元素进行改动都要产生新的快照，这样要付出的时间和空间成本都是非常大的。 3. 相对线程安全相对线程安全就是通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。上面的代码就是相对线程安全的的案例。 在Java语言中，大部分声称线程安全的类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。 4. 线程兼容线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。平常说一个类不是线程安全的，通常就是指这种情况。 5. 线程对立线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。 一个线程对立的例子是 Thread 类的 suspend() 和 resume() 方法。如果有两个线程同时持有一个线程对象，一个尝试去中断线程，一个尝试去恢复线程，在并发进行的情况下，无论调用时是否进行了同步，目标线程都存在死锁风险——假如 suspend() 中断的线程就是即将要执行 resume() 的那个线程，那就肯定要产生死锁了。常见的线程对立的操作还有 System.setIn()、System.setOut 和 System.runFinalizersOnExit() 等。 线程安全的实现方法1. 互斥同步互斥同步是一种最常见也是最主要的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。 在Java里面，最基本的互斥同步手段就是 synchronized 关键字，这是一种块结构的同步语法。synchronized 关键字经过Javac编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference；如果没有明确指定，那将根据synchronized修饰的方法类型，来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。 根据《Java虚拟机规范》的要求，在执行 monitorenter 指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行 monitorexit 指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。 从功能上看，根据上述描述，可以得出两个关于 synchronized 的直接推论，这是使用它时需特别注意的： 被 synchronized 修饰的同步块对同一条线程来说是可重入的，这意味着同一条线程反复进入同步块也不会出现自己把自己锁死的情况。 被 synchronized 修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。 从执行成本的角度看，持有锁是一个重量级的操作。已知了在主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转换需要耗费很多的处理器时间。尤其是对于代码特别简单的同步块，状态转换消耗的时间甚至会比用户代码本身执行的时间还要长。因此才说，synchronized 是Java语言中一个重量级的操作，有经验的都只会在确实必要的情况下才使用这种操作。而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞系统之前加入一段自旋等待过程，以避免频繁地切入核心态之中。 除了 synchronized 关键字以外，自JDK 5起，Java类库中新提供了 java.util.concurrent 包，其中的 java.util.concurrent.locks.Lock 接口便成了Java的另一种全新的互斥同步手段。基于 Lock 接口，用户能够以非块结构来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面去实现同步，这也为日后扩展出不同调度算法、不同特征、不同性能、不同语义的各种锁提供了广阔的空间。 重入锁（ReentrantLock）是Lock接口最常见的一种实现，顾名思义，它与 synchronized 一样是可重入的。在基本用法上，ReentrantLock 也与 synchronized 很相似，只是代码写法上稍有区别而已。不过，ReentrantLock 与 synchronized 相比增加了一些高级功能，主要有以下三项：等待可中断、可实现公平锁及锁可以绑定多个条件。 等待可中断：是指当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。 公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock 在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致 ReentrantLock 的性能急剧下降，会明显影响吞吐量。 锁绑定多个条件：是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象。在 synchronized 中，锁对象的 wait() 跟它的 notify() 或者 notifyAll() 方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而 ReentrantLock 则无需这样做，多次调用 newCondition() 方法即可。 如果需要使用上述功能，使用 ReentrantLock 是一个很好的选择，那如果基于性能考虑呢？synchronized 对性能的影响，尤其在JDK 5之前是很显著的，为此在JDK 6中还专门进行过针对性的优化。所以性能已经不再是选择 synchronized 和 ReentrantLock 的决定因素。 推荐在 synchronized 与 ReentrantLock 都可满足需要时优先使用 synchronized： synchronized 是在Java语法层面的同步，足够清晰，也足够简单。因此在只需要基础的同步功能时，更推荐 synchronized。 Lock 应该确保在 finally 块中释放锁，否则一旦受同步保护的的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由用户自己来保证，而使用 synchronized 的话则可以由Java虚拟机来确保即使出现异常，锁也能被自动释放。 从长远来看，Java虚拟机更容易针对 synchronized 来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录 synchronized 中锁的相关信息，而使用 Lock 的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。 2. 非阻塞同步互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为阻塞同步。从解决问题的方式上看，互斥同步属于一种悲观的并发策略，其总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享的数据是否真的会出现竞争，它都会进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁），这将会导致用户态到核心态的转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。随着硬件指令集的发展，已经有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步，使用这种措施的代码也常被称为无锁编程。 为什么说使用乐观并发策略需要 “硬件指令集的发展”？因为必须要求操作和冲突检测这两个步骤具备原子性。靠什么来保证原子性？如果这里再使用互斥同步来保证就完全失去意义了，所以只能靠硬件来实现这件事情，硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有： 测试并设置 获取并增加 交换 比较并交换（CAS） 加载链接 &#x2F; 条件存储（LL&#x2F;SC） 其中，前面的三条是20世纪就已经存在于大多数指令集之中的处理器指令，后面的两条是现代处理器新增的，而且这两条指令的目的和功能也是类似的。Java里最终暴露出来的是 CAS 操作，所以下面以 CAS 指令为例进行讲解。 CAS 指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和准备设置的新值（用 B 表示）。CAS指令执行时，当且仅当 V 符合 A 时，处理器才会用 B 更新 V 的值，否则它就不执行更新。但是，不管是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。 在JDK 5之后，Java类库中才开始使用 CAS 操作，该操作由 sun.misc.Unsafe 类里面的 compareAndSwapInt() 和 compareAndSwapLong() 等几个方法包装提供。HotSpot虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器 CAS 指令，没有方法调用的过程。不过由于 Unsafe 类在设计上就不是提供给用户程序调用的类，因此在JDK 9之前只有Java类库可以使用 CAS，譬如 java.util.concurrent 包里面的整数原子类，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作来实现。而如果用户程序也有使用 CAS 操作的需求，那要么就采用反射手段突破 Unsafe 的访问限制，要么就只能通过Java类库API来间接使用它。直到JDK 9之后，Java类库才在 VarHandle 类里开放了面向用户程序使用的 CAS 操作。 尽管 CAS 看起来很美好，既简单又高效，但显然这种操作无法涵盖互斥同步的所有使用场景，并且 CAS 从语义上来说并不是真正完美的，它存在一个逻辑漏洞：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那就能说明它的值没有被其他线程改变过了吗？这是不能的，因为如果在这段时间它的值曾经被改成 B，后来又被改回 A，那 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 CAS 操作的 “ABA问题”。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更为高效。 3. 无同步方案要保证线程安全，也并非一定要进行阻塞或非阻塞同步，同步与线程安全两者没有必然的联系。同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的，下面简单介绍其中的两类。 可重入代码：这种代码又称纯代码，是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。在特指多线程的上下文语境里（不涉及信号量等因素），可以认为可重入代码是线程安全代码的一个真子集，这意味着相对线程安全来说，可重入性是更为基础的特性，它可以保证代码线程安全，即所有可重入的代码都是线程安全的，但并非所有的线程安全的代码都是可重入的。 可重入代码有一些共同的特征，例如，不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等。可以通过一个比较简单的原则来判断代码是否具备可重入性：如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。 线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，就可以把共享数据的可见范围限制在同一个线程之内，这样，无需同步也能保证线程之间不出现数据争用的问题。 符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如 “生产者 - 消费者” 模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是经典Web交互模型中的 “一个请求对应一个服务器线程” 的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。 Java语言中，如果一个变量要被多线程访问，可以使用 volatile 关键字将它声明为 “易变的”；如果一个变量只要被某个线程独享，Java中就没有类似 C++ 中 __declspec(thread) 这样的关键字去修饰，不过还是可以通过 java.lang.ThreadLocalMap 类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个 ThreadLocalMap 对象，这个对象存储了一组以 ThreadLocal.threadLocalHashCode 为键，以本地线程变量为值的 K-V 值对，ThreadLocal 对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程 K-V 值对中找回对应的本地线程变量。 锁优化自旋锁与自适应自旋前面讨论互斥同步的时候，提到了互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。现在绝大多数的个人电脑和服务器都是多核处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，就可以让后面请求锁的那个线程 “稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。 自旋锁在JDK 1.4.2中就已经引入，只不过默认是关闭的，可以使用 -XX:+UseSpinning 参数来开启，在JDK 6中就已经改为默认开启了。自旋等待不能替换阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。 不过无论是默认值还是用户指定的自旋次数，对整个Java虚拟机中所有的锁来说都是相同的。在JDK 6中对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。 锁消除锁消除是指虚拟机即时编译器在运行时检测到某段需要同步的代码根本不可能存在共享数据竞争而实施的一种对锁进行消除的优化策略。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。 变量是否逃逸，对于虚拟机来说是需要使用复杂的过程间分析才能确定的，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下还要求同步呢？这个问题的答案是：有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中出现的频繁程度也许超过了大部分人的想象。 锁粗化原则上，在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。 大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥操作也会导致不必要的性能损耗。 如果虚拟机探测到有这样一串零碎的的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。 轻量级锁轻量级锁是JDK 6时加入的新型锁机制，它名字中的 “轻量级” 是相对于使用操作系统互斥量来实现的传统锁而言的。因此传统的锁机制就被称为 “重量级” 锁。不过，需要强调一点，轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 HotSpot虚拟机的对象头分为两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄等。这部分数据的长度在32位和62位的Java虚拟机中分别会占用32个或64个比特，官方称它为 “Mark Word”。这部分是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。 由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到Java虚拟机的空间使用效率，Mark Word被设计成一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，对象未被锁定的状态下，Mark Word的32个比特空间里的25个比特将用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，还有1个比特固定为0（这表示未进入偏向模式）。对象除了未被锁定的正常状态外，还有轻量级锁定、重量级锁定、GC标记、可偏向等几种不同状态。 轻量级锁的工作过程：在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为 “01” 状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。 然后，虚拟机将使用 CAS 操作尝试把对象的Mark Word更新为指向Local Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位将转变为 “00”，表示此对象处于轻量级锁定状态。 如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为 “10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。 上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行的。如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Mark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。 轻量级锁能提升程序同步性能的依据是 “对于绝大部分的锁，在整个同步周期内都是不存在竞争的” 这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。 偏向锁偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。 偏向锁中的 “偏”，就是偏心的偏、偏袒的偏。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。 假设当前虚拟机启用了偏向锁，那么当锁对象第一次被线程获取时，虚拟机将会把对象头中的标志位设置为 “01”、把偏向模式设置为 “1”，表示进入偏向模式，并使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）。 一旦出现另一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为 “0”），撤销后标志位恢复到未锁定（标志位为 “01”）或轻量级锁定（标志位为 “00”）的状态，后续的同步操作就按轻量级锁去执行。 当对象进入偏向状态的时候，Mark Word大部分的空间都用于存储持有锁的线程ID了，这部分空间占用了原来存储对象哈希码的为止，那原来对象的哈希码怎么办？ 在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变，否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的 Object::hashCode() 方法，返回的是对象的一致性哈希码，这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法获取到的哈希码值永远不会发生改变。因此，当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正在处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的 ObjectMonitor 类里有字段可以记录非加锁状态下的Mark Word，其中自然可以存储原来的哈希码。 偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://azxkenzo.github.io/tags/JVM/"}]},{"title":"JVM - Java与线程","slug":"JVM-Java与线程","date":"2023-05-26T06:20:06.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2023/05/26/JVM-Java与线程/","link":"","permalink":"https://azxkenzo.github.io/2023/05/26/JVM-Java%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"线程的实现线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I&#x2F;O等），又可以独立调度。目前线程是Java里面进行处理器资源调度的最基本单位。 主流的操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经调用过 start() 方法且还未结束的 java.lang.Thread 类的实例就代表着一个线程。 实现线程主要有三种方式：使用内核线程实现（1:1实现），使用用户线程实现（1:N实现），使用用户线程加轻量级进程混合实现（N:M实现）。 1. 内核线程实现使用内核线程实现的方式也被称为1:1实现。内核线程（KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核。 程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（LWP），轻量级进程就是通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。 由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。轻量级进程也具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。 2. 用户线程实现使用用户线程实现的方式被称为1:N实现。广义上来讲，一个线程只要不是内核线程，都可以认为是用户线程（UT）的一种，因此从这个定义上看，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，因此效率会受到限制，并不具备通常意义上的用户线程的优点。 而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量。 用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如 “阻塞如何处理” “多处理器系统中如何将线程映射到其他处理器上” 这类问题解决起来将会异常困难，甚至有些是不可能实现的。 3. 混合实现还有一种将内核线程与用户线程一起使用的实现方式，被称为N:M实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户进程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，是N:M的关系。 4. Java线程的实现Java线程如何实现并不受Java虚拟机规范的约束，这是一个与具体虚拟机相关的话题。从 JDK 1.3 起，“主流” 平台上的 “主流” 商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1:1的线程模型。 以 HotSpot 为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以 HotSpot 自己是不会去干涉线程调度的，全权交给底下的操作系统去处理。 Java线程调度线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是协同式线程调度和抢占式线程调度。 如果使用协同式线程调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另一个线程上去。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以一般没有什么线程同步的问题。Lua语言中的“协同例程”就是这类实现。它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。 如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。譬如在Java中，有 Thread::yield() 方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程本身是没有什么办法的。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程甚至整个系统阻塞的问题。Java使用的线程调度方式就是抢占式调度。 虽说Java线程调度是系统自动完成的，但是仍然可以 “建议” 操作系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作是通过设置线程优先级来完成的。Java语言一共设置了10个级别的线程优先级。在两个线程同时处于 Ready 状态时，优先级越高的线程越容易被系统选择执行。 状态转换Java语言定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间切换。 新建（New）：创建后尚未启动的线程处于这种状态。 运行（Runnable）：包括操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。 无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态： 没有设置 Timeout 参数的 Object::wait() 方法 没有设置 Timeout 参数的 Thread::join() 方法 LockSupport::park() 方法 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程陷入限期的等待状态： Thread::sleep() 方法 设置了 Timeout 参数的 Object::wait() 方法 设置了 Timeout 参数的 Thread::join() 方法 LockSupport::parkNanos() 方法 LockSupport::parkUntil() 方法 阻塞（Blocked）：线程被阻塞了，“阻塞状态” 与 “等待状态” 的区别是 “阻塞状态” 在等待着获取到一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生；而 “等待状态” 则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。 Java 与 协程内核线程的局限今天对Web应用的服务要求，不论是在请求数量上还是在复杂度上，与十多年前相比已不可同日而语，这一方面是源于业务量的增长，另一方面来自于为了应对业务复杂化而不断进行的服务细分。现代 B&#x2F;S 系统中一次对外部业务请求的响应，往往需要分布在不同机器上的大量服务共同协作来实现，这种服务细分的架构在减少单个服务复杂度、增加复用性的同时，也不可避免地增加了服务的数量，缩短了留给每个服务的响应时间。这要求每一个服务都必须在极短的时间内完成计算，这样组合多个服务的总耗时才不会太长；也要求每一个服务提供者都要能同时处理数量更庞大的请求，这样才不会出现请求由于某个服务被阻塞而出现等待。 Java目前的并发编程机制就与上述架构趋势产生了一些矛盾，1:1 的内核线程模型是如今Java虚拟机线程实现的主流选择，但是这种映射到操作系统上的线程天然的缺陷是切换、调度成本高昂，系统能容纳的线程数量也很有限。在以前的单体应用中，处理每一个请求可以允许花费很长时间，具有这种线程切换的成本也是无伤大雅的，但现在在每个请求本身的执行时间变得更短、数量变得更多的前提下，用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费。 传统的Java Web服务器的线程池的容量通常在几十个到两百之间，当程序员把数以百万计的请求往线程池里面灌时，系统即使能处理得过来，但其中的切换损耗也是相当可观的。现实的需求在迫使Java去研究新的解决方案。 协程的复苏为什么内核线程调度切换起来成本会更高？ 内核线程的调度成本主要来自于用户态与核心态之间的状态转换，而这两种状态转换的开销主要来自于响应中断、保护和恢复执行现场的成本。假设发生了这样一次线程切换： 1线程A -&gt; 系统中断 -&gt; 线程B 处理器要去执行线程A的程序代码时，并不是仅有代码程序就能跑得起来，程序是数据与代码的组合体，代码执行时还必须要有上下文数据的支撑。而这里说的 “上下文”，以程序员的角度来看，是方法调用过程中的各种局部的变量与资源；以线程的角度来看，是方法的调用栈中存储的各类信息；而以操作系统和硬件的角度来看，则是存储在内存、缓存和寄存器中的一个个具体数值。物理硬件的各种存储设备和寄存器是被操作系统内所有线程共享的资源，当中断发生，从线程A切换到线程B去执行之前，操作系统首先要把线程A的上下文数据妥善保管好，然后把寄存器、内存分页等恢复到线程B挂起时候的状态，这样线程B被重新激活后才能仿佛从来没有被挂起过。这种保护和恢复现场的工作，免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级操作。 如果说内核线程的切换开销是来自于保护和恢复现场的成本，那如果改为采用用户线程，这部分开销就能够省略掉吗？答案是 “不能”。但是，一旦把保护、恢复现场及调度的工作从操作系统交到程序员手上，那就可以打开脑洞，通过玩出很多新花样来缩减这些开销。 有一些古老的操作系统是单人单工作业形式的，天生就不支持多线程，自然也不会有多个调用栈这样的基础设施。而早在那样的蛮荒时代，就已经出现了今天被称为 栈纠缠 的、由用户自己模拟多线程、自己保护恢复现场的工作模式。其大致的原理是通过在内存里划出一片额外空间来模拟调用栈，只要其他“线程”中方法压栈、退栈时遵守规则，不破坏这片空间即可，这样多段代码执行时就会像相互缠绕着一样，非常形象。 到后来，操作系统开始提供多线程的支持，靠应用自己模拟多线程的做法自然是变少了许多，但也没有完全消失，而是演化为用户线程继续存在。由于最初多数的用户线程是被设计成协同式调度的，所以它有了一个别名——“协程”。又由于这时候的协程会完整地做调用栈的保护、恢复工作，所以今天也被称为“有栈协程”，起这样的名字是为了便于跟后来的“无栈协程”区分开。无栈协程不是本节的主角，不过还是可以简单提一下它的典型应用，即各种语言中的await、async、yield这类关键字，无栈协程本质上是一种有限状态机，状态保护在闭包里，自然比有栈协程恢复调用栈要轻量得多，但功能也相对更有限。 协程的主要优势是轻量，无论是有栈协程还是无栈协程，都要比传统内核线程要轻量得多，如果进行量化的话，那么如果不显式设置 -Xss 或 -XX:ThreadStackSize，则在64位Linux上HotSpot的线程栈容量默认是1MB，此外内核数据结构还会额外消耗16KB内存。与之相对的，一个协程的栈通常在几百个字节到几KB之间，所以Java虚拟机里线程池容量达到两百就已经不算小了，而很多支持协程的应用中，同时并存的协程数量可数以十万计。 协程当然也有它的局限，需要在应用层面实现的内容（调用栈、调度器这些）特别多。除此之外，协程在最初，甚至在今天很多语言和框架中会被设计成协同式调度，这样在语言运行平台或者框架上的调度器就可以做得非常简单。 具体到Java语言，还会有一些别的限制，譬如HotSpot这样的虚拟机，Java调用栈跟本地调用栈是做在一起的。如果在协程中调用了本地方法，还能否正常切换协程而不影响整个线程？另外，如果协程中遇传统的线程同步措施会怎样？譬如Kotlin提供的协程实现，一旦遭遇 synchronized 关键字，那挂起来的仍将是整个线程。 Java的解决方案OpenJDK 在2018年创建了Loom项目，这是Java用来应对本节开篇所列场景的官方解决方案，根据目前公开的信息，如无意外，日后该项目为Java语言引入的、与现在线程模型平行的新并发编程机制中应该会采用 “纤程” 这个名字。从 Oracle 官方对 “什么是纤程” 的解释里可以看出，它就是一种典型的有栈协程。 Loom项目背后的意图是重新提供对用户线程的支持，但与过去的绿色线程不同，这些新功能不是为了取代当前基于操作系统的线程实现，而是会有两个并发编程模型在Java虚拟机中并存，可以在程序中同时使用。 在新并发模型下，一段使用纤程并发的代码会被分为两部分——执行过程和调度器。执行过程主要用于维护执行现场，保护、恢复上下文状态，而调度器则负责编排所有要执行的代码的顺序。将调度程序与执行过程分离的好处是，用户可以选择自行控制其中的一个或者多个，而且Java中现有的调度器也可以被直接重用。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://azxkenzo.github.io/tags/JVM/"}]},{"title":"JVM - Java 内存模型","slug":"JVM-Java-内存模型","date":"2023-05-23T08:12:05.000Z","updated":"2023-07-18T04:22:50.346Z","comments":true,"path":"2023/05/23/JVM-Java-内存模型/","link":"","permalink":"https://azxkenzo.github.io/2023/05/23/JVM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"主内存与工作内存Java 内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到存储到内存和从内存中取出变量值这样的底层细节。此处的变量与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，也就不会存在竞争问题。 Java 内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本（假设线程中访问一个 10MB 大小的对象，也会把这 10MB 的内存复制一份出来吗？ 事实上并不会如此，这个对象的引用、对象中某个在线程访问到的字段是有可能被复制的，但不会有虚拟机把整个对象复制一次），线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java 内存模型中定义了以下 8 种操作来完成。Java 虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。 load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。 write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行 read 和 load 操作，如果要把变量从工作内存同步回主内存，就要按顺序执行 store 和 write 操作。注意，Java 内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说 read 与 load 之间、store 与 write 之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是 read a、read b、load b、load a。除此之外，Java 内存模型还规定了在执行上述 8 种基本操作时必须满足以下规则： 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化的（load 或 assign）的变量，换句话说就是对一个变量实施 use、store 操作之前，必须先执行 assign 和 load 操作。 一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。 如果对一个变量执行 lock 操作，那将会清空工作内存中该变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作以初始化变量的值。 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。 对于 volatile 型变量的特殊规则当一个变量被定义成 volatile 之后，它将具备两项特性：第一项是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如。线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再对主内存进行读取操作，新变量值才会对线程 B 可见。 关于 volatile 变量的可见性，经常会被开发人员误解，他们会误以为下面的描述是正确的：“volatile 变量对所有线程是立即可见的，对 volatile 变量的所有写操作都能立刻反映到其他线程之中。换句话说，volatile 变量在各个线程中是一致的，所以基于 volatile 变量的运算在并发下是线程安全的”。这句话的论据部分并没有错，但是由其论据并不能得出“基于 volatile 变量的运算在并发下是线程安全的”这样的结论。volatile 变量在各个线程的工作内存中是不存在一致性问题的（从物理存储的角度看，各个线程的工作内存中 volatile 变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在不一致问题），但是 Java 里面的运算操作符并非原子操作，这导致 volatile 变量的运算在并发下一样是不安全的。 1234567891011121314151617181920212223242526272829class VolatileTest &#123; public static volatile int race = 0; public static void increase() &#123; race++; &#125; private static final int THREAD_COUNT = 20; public static void main(String[] args) &#123; Thread[] threads = new Thread[THREAD_COUNT]; for (int i = 0; i &lt; THREAD_COUNT; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 10000; j++) &#123; increase(); &#125; &#125; &#125;); threads[i].start(); &#125; while (Thread.activeCount() &gt; 1) &#123; Thread.yield(); &#125; System.out.println(race); &#125;&#125; 这段代码发起了20个线程，每个线程对 race 变量进行 10000 次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是 200000。但是运行完这段代码之后，并不会获得期望的结果，而且会发现每次输出的结果的都不一样，都是一个小于 200000 的数字。 问题就出在自增运算“race++”之中，用 Javap 反编译这段代码后会得到如下所示，发现只有一行代码的 increase() 方法在Class文件中是由4条字节码指令构成（return 指令不是由 race++ 产生的，这条指令可以不计算），从字节码层面上已经很容易分析出并发失败的原因了：当 getstatic 指令把 race 的值取到操作栈顶时，volatile 关键字保证了 race 的值在此时是正确的，但是在执行 iconst_1、iadd 这些指令时，其他线程可能已经把 race 的值改变了，而操作栈顶的值就变成了过期的数据，所以 putstatic 指令执行后就可能把较小的 race 值同步回主内存之中。 1234567891011public static void increase(); Code: Stack=2, Locals=0, Args_size=0 0: getstatic #13; //Field race:I 3: iconst_1 4: iadd 5: putstatic #13; // Field race:I 8: return LineNumberTable: line 14: 0 line 15: 8 使用字节码来分析并发问题仍让是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释执行时，解释器要运行许多行代码才能实现它的语义。 由于 volatile 变量只能保证可见性，在不符合以下两条规则的运算场景中，仍然要通过加锁（使用 synchronized、java.util.concurrent 中的锁或原子类）来保证原子性： 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值 变量不需要与其他的状态变量共同参与不变约束 使用 volatile 变量的第二个语义是禁止指令重排序优化，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在同一个线程的方法执行过程中无法感知到这点，这就是 Java 内存模型中描述的所谓“线程内表现为串行的语义”。 通过一个例子来看看为何指令重排序会干扰程序的并发执行。 12345678910111213141516171819Map configOptions;char[] configText;// 此变量必须定义为volatilevolatile boolean initialized = false;// 假设以下代码在线程 A 中执行// 模拟读取配置信息，当读取完成后 将initialized设置为true，通知其他线程配置可用configOptions = new HashMap();configText = readConfigFile(fileName);processConfigOptions(configText, configOptions);initialized = true;// 假设以下代码在线程 B 中执行// 等待initialized为true，代表线程 A 已经把配置信息初始化完成while (!initialized) &#123; sleep();&#125;// 使用线程 A 中初始化好的配置信息doSomethingWithConfig(); 上述代码是一段伪代码，其中描述的场景是开发中常见配置读取过程，只是在处理配置文件时一般不会出现并发，所以没有察觉这会有问题。试想一下，如果定义 initialized 变量时没有使用 volatile 修饰，就可能会由于指令重排序的优化，导致位于线程 A 中最后一条代码 “initialized &#x3D; true” 被提前执行（这里虽然使用 Java 作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这条语句对应的汇编代码被提前执行），这样在线程B中使用配置信息的代码就可能出现错误，而 volatile 关键字可以避免此类情况的发生。 再举一个可以实际操作运行的例子来分析 volatile 关键字是如何禁止指令重排序优化的。以下代码所示的是一段标准的双锁检测（DCL）单例代码，观察加入 volatile 和 未加入 volatile 关键字时所生成的汇编代码的差别。 123456789101112131415161718public class Singleton &#123; private volatile static Singleton instance; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; Singleton.getInstance(); &#125;&#125; 通过对比发现，关键变化在于有 volatile 修饰的变量，赋值后（前面 mov %eax,0x150(%esi) 这句便是赋值操作）多执行了一个 “lock addl $0x0,(%esp)” 操作，这个操作的作用相当于一个内存屏障（指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个处理器访问内存时，并不需要内存屏障；但如果有两个或更多处理器访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性。 这句指令中的“addl $0x0,(%esp)”（把ESP寄存器的值加0）显然是一个空操作，之所以用这个空操作而不是空操作专用指令nop，是因为IA32手册规定 lock 前缀不允许配合nop指令使用。这里的关键在于 lock 前缀，它的作用是将本处理器的缓存写入来内存，该写入动作也会引起别的处理器或者别的内核无效化其缓存，这种操作相当于对缓存中的变量做了一次Java内存模型中的“store 和 write”操作，所以通过这样一个空操作，可让前面 volatile 变量的修改对其他处理器立即可见。 那为何说它禁止指令重排序呢？从硬件架构上讲，指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。但并不是说指令任意重排，处理器必须能正确处理指令依赖情况保障程序能得出正确的执行结果。譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排，但指令3可以重排到指令1、2之前或者中间，只要保证处理器执行后面依赖到A、B值的操作时能获取到正确的A和B值即可。所以在同一个处理器中，重排序过的代码看起来依然是有序的。因此，lock addl $0x0,(%esp) 指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。 再来看看在众多保障并发安全的工具中选用 volatile 的意义——它能让代码比使用其他的同步工具更快吗？在某些情况下，volatile 的同步机制的性能确实要优于锁，但是由于虚拟机对锁实行的许多消除和优化，使得很难确切的说 volatile 就会比 synchronized 快上多少。如果让 volatile 自己与自己比较，，那可以确定一个原则：volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下 volatile 的总开销仍然比锁来得更低。在 volatile 与锁中选择的唯一判断依据仅仅是 volatile 的语义能否满足使用场景的需求。 最后来看看Java内存模型中对 volatile 变量定义的特殊规则的定义。假定 T 表示一个线程，V 和 W 分别表示两个 volatile 型变量，那么在进行read、load、use、assign、store 和 write 操作时需要满足如下规则： 只有当线程 T 对变量 V 执行对前一个动作是 load 的时候，线程 T 才能对变量 V 执行 use 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 use 的时候，线程 T 才能对变量 V 执行 load 操作。线程 T 对变量 V 的 use 动作可以认为是和线程 T 对变量 V 的 load、read 动作相关联的，必须连续且一起出现。 这条规则要求在工作内存中，每次使用 V 前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量 V 所做的修改。 只有当线程 T 对变量 V 执行对前一个动作是 assign 的时候，线程 T 才能对变量 V 执行 store 动作；并且，只有当线程 T 对变量 V 执行的后一个动作是 store 的时候，线程 T 才能对变量 V 执行 assign 操作。线程 T 对变量 V 的 assign 动作可以认为是和线程 T 对变量 V 的 store、write 动作相关联的，必须连续且一起出现。 这条规则要求在工作内存中，每次修改 V 后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量 V 所做的修改。 假定动作 A 是线程 T 对变量 V 实施的 use 或 assign 动作，假定动作 F 是和动作 A 相关联的 load 或 store 动作，假定动作 P 是和动作 F 相应的对变量 V 的 read 或 write 动作；与此类似，假定动作 B 是线程 T 对变量 W 实施的 use 或 assign 动作，假定动作 G 是和动作 B 相关联的 load 或 store 动作，假定动作 Q 是和动作 G 相应的对变量 W 的 read 或 write 动作。如果 A 先于 B，那么 P 先于 Q。 这条规则要求 volatile 修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。 针对 long 和 double 型变量的特殊规则原子性、可见性与有序性1. 原子性（Atomicity）由Java内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write 这六个。大致可以认为，基本数据类型的访问、读写都是具备原子性的。 如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了 lock 和 unlock 操作操作来满足这种需求。尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块——synchronized 关键字，因此在 synchronized 块之间的操作也具备原子性。 2. 可见性（Visibility）可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是 volatile 变量都是如此。普通变量与 volatile 变量的区别是，volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。 除了 volatile 之外，Java还有两个关键字能实现可见性，它们是 synchronized 和 final。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）”这条规则获得的。而 final 关键字的可见性是指：被 final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见 final 字段的值。 3. 有序性（Ordering）Java 程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。 Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 关键字本身就包含了禁止指令重排序的语义，而 synchronized 则是由“一个变量在同一时刻只允许一条线程对其进行 lock 操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行的进入。 先行发生原则如果Java内存模型中所有的有序性都仅靠 volatile 和 synchronized 来完成，那么有很多操作都将会变得非常啰嗦，但是在编写并发代码的时候并没有察觉到这一点，这是因为Java语言中有一个“先行发生”的原则，这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的非常有用的手段。 先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。 下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意进行重排序。 程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。 volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。 线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每一个动作。 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，可以通过 Thread::join() 方法是否结束、Thread::isActive()的返回值等手段检测线程是否已经终止执行。 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread::interrupted() 方法检测到是否有中断发生。 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。 传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。 一个操作“时间上的先发生”不代表这个操作会是“先行发生”。一个操作“先行发生”也无法推导出这个操作必定是“时间上的先发生”。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://azxkenzo.github.io/tags/JVM/"}]},{"title":"JVM - 垃圾收集器与内存分配策略","slug":"JVM-垃圾收集器与内存分配策略","date":"2023-05-09T00:50:18.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2023/05/09/JVM-垃圾收集器与内存分配策略/","link":"","permalink":"https://azxkenzo.github.io/2023/05/09/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/","excerpt":"","text":"哪些内存需要回收？ 什么时候回收？ 如何回收？ 对象已死？垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对象）了。 引用计数算法很多教科书判断对象是否存活的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计时器为零的对象就是不可能再被使用的。 引用计数算法虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。也有一些比较著名的应用案例，例如微软COM技术、使用 ActionScript 3 的FlashPlayer、Python语言以及在游戏脚本领域得到许多应用的Squirrel中都使用了引用计数算法来管理内存。但是，在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。 可达性分析算法当前主流的商用程序语言的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。 在Java技术体系里面，固定可作为GC Roots的对象包括以下几种： 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如当前正在运行的方法所使用到的参数、局部变量、临时变量等 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量 在方法区中常量引用的对象，譬如字符串常量池里的引用 在本地方法栈中JNI引用的对象 Java虚拟机内部的引用，如基本数据类型对象的Class对象，一些常驻的异常对象等，还有系统类加载器 所有被同步锁（synchronized 关键字）持有的对象 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完成GC Roots集合。譬如分代收集和局部回收（Partial GC），如果只针对Java堆中某一块区域发起垃圾收集时，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。 再谈引用无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判断对象是否存活都和“引用”离不开关系。在JDK 1.2版之前，Java里面的引用是很传统的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。这种定义并没有什么不对，只是现在看来有些过于狭隘了，一个对象在这种定义下只有“被引用”或者“未被引用”两种状态，对于描述一些“食之无味，弃之可惜”的对象就显得无能为力。譬如希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象。 在JDK 1.2版之后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用（soft）、弱引用（weak）和虚引用（phantom）4种，这4种引用强度依次逐渐减弱。 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj &#x3D; new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象 软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常 弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知 生存还是死亡？","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://azxkenzo.github.io/tags/JVM/"}]},{"title":"JVM - 内存区域","slug":"JVM-内存区域","date":"2023-04-19T01:40:29.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2023/04/19/JVM-内存区域/","link":"","permalink":"https://azxkenzo.github.io/2023/04/19/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"运行时数据区域运行时数据区域包括： 方法区（method area）（线程共享的数据区） 虚拟机栈（VM stack） 本地方法栈（native method stack） 堆（heap）（线程共享的数据区） 程序计数器（program counter register） 程序计数器程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。在 Java 虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于 Java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 native 方法，这个计数器值则应为空。此内存区域是唯一一个在《Java 虚拟机规范》中没有规定任何 OutOfMemoryError 情况的区域。 Java 虚拟机栈Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知各种 Java 虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针。也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。 这些数据类型在局部变量表中的存储空间以局部变量槽（slot）来表示，其中64位长度的 long 和 double 类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。这个“大小”指的是变量槽的数量。 在《Java 虚拟机规范》中，对这个内存区域规定了两类异常情况： 如果线程请求的栈深度大于大于虚拟机所允许的深度，将抛出 StackOverflowError 异常； 如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出 OutOfMemoryError 异常。（HotSpot 虚拟机的栈容量是不可以动态扩展的。所以在 HotSpot 虚拟机上是不会由于虚拟机栈无法扩展而导致 OutOfMemoryError 异常—-只要线程申请栈空间成功了就不会有OOM，但是如果申请时就失败了，仍然是会出现OOM异常的） 本地方法栈本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则是为虚拟机使用到的 native 方法服务。 《Java 虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它。有的虚拟机（如 HotSpot）直接把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError 异常。 Java 堆Java 堆是被所有线程共享堆一块内存区域，在虚拟机启动时创建。此内存区域堆唯一目的就是存放对象实例，“几乎”所有的对象实例都在这里分配内存。 Java 堆是垃圾收集器管理的内存区域。 根据《Java 虚拟机规范》的规定，Java 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。 Java 堆既可以被实现成固定大小的，也可以是扩展的，当前主流的 Java 虚拟机都是按照可扩展来实现的。如果在 Java 堆中没有内存完成实例分配，并且堆也无法再扩展时，Java 虚拟机将会抛出 OutOfMemoryError 异常。 方法区方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 《Java 虚拟机规范》对方法区的约束是非常宽松的，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。 根据《Java 虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError 异常。 运行时常量池运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。 直接内存直接内存并不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。 在 JDK 1.4 中新加入了 NIO（new input&#x2F;output）类，引入了一种基于通道（channel）与缓冲区（buffer）的 I&#x2F;O 方式，它可以使用 native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存大小以及处理器寻址空间的限制。 忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现 OutOfMemoryError 异常。 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问对象的创建当 Java 虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上等同于把一块确定大小的内存块从 Java 堆中划分出来。假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。但如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块时可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理的能力决定。因此，当使用Serial、ParNew 等带有压缩整理过程的收集器时，系统采用的分配算法是指针碰撞；而当使用 CMS 这种基于清除算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。 除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程完全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存吗，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。 内存分配完成后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。 接下来，Java 虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从 Java 程序的视角来看，对象创建才刚刚开始——构造函数，即Class文件中的 () 方法还没有执行，所有字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节码流中的new指令后面是否跟随invokeespecial指令所决定，Java 编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着执行 () 方法，这样一个真正可用的对象才算完全被构造出来。 对象的内存布局在hotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。 HosSpot 虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、63位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。 对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。 接下来实例数据部分是对象真正存储的有效信息，即在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。HosSpot虚拟机默认的分配顺序为 longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops，从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。 对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HosSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。 对象的访问定位Java 程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java 虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现定的，主流的访问方式主要有使用句柄和直接指针两种： 如果使用句柄访问的话，Java堆中将可能划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。 如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型信息的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。 使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就HotSpot而言，它只要使用第二种方式进行对象访问。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://azxkenzo.github.io/tags/JVM/"}]},{"title":"Android 面试","slug":"Android-面试","date":"2023-04-18T02:54:14.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2023/04/18/Android-面试/","link":"","permalink":"https://azxkenzo.github.io/2023/04/18/Android-%E9%9D%A2%E8%AF%95/","excerpt":"","text":"JVMJVM的结构volatile内存模型GCAndroid绘制流程同步消息屏障ViewRootImpl 将遍历view树包装成一个Runnable并抛到Choreographer， 在抛之前会向主线程消息队列中抛同步屏障 同步屏障也是一个Message，只不过 target 等于null 取下一条message的算法中，若遇到同步屏障，则会越过同步消息，向后遍历找第一条异步消息找到则返回（Choreographer抛的异步消息），若没有找到则会执行epoll挂起 当执行到遍历View树的 runnable时，ViewRootImpl会移除同步屏障 Choreographer将和ui相关的任务与vsync同步的一个类。 每个任务被抽象成CallbackRecord，同类任务按时间先后顺序组成一条任务链CallbackQueue。四条任务链存放在mCallbackQueues[]数组结构中 触摸事件，动画，View树遍历都会被抛到编舞者，并被包装成CallbackRecord并存入链式数组结构，当Choreographer收到一个Vsync就会依次从输入，动画，绘制这些链中取出任务执行 当vsync到来时，会向主线程抛异步消息（执行doFrame）并带上消息生成时间，当异步消息被执行时，从任务链上摘取所有以前的任务，并按时间先后顺序逐个执行。 绘制模型1.软件绘制 2.硬件加速绘制 应用冷启动流程Surface它是原始图像缓冲区的一个句柄。即raw buffer的内存地址，raw buffer是保存像素数据的内存区域，通过Surface的canvas 可以将图像数据写入这个缓冲区 Surface类是使用一种称为双缓冲的技术来渲染 这种双缓冲技术需要两个图形缓冲区GraphicBuffer，其中一个称为前端缓冲区frontBuffer，另外一个称为后端缓冲区backBuffer。前端缓冲区是正在渲染的图形缓冲区，而后端缓冲区是接下来要渲染的图形缓冲区，当vsync到来时，交换前后缓冲区的指针 SurfaceFlingerSurfaceFlinger 是由 init 进程启动的运行在底层的一个系统进程，它的主要职责是合成和渲染多个Surface，并向目标进程发送垂直同步信号 VSync,并在 vsync 产生时合成帧到frame buffer Surfaceview一个嵌入View树的独立绘制表面，他位于宿主Window的下方，通过在宿主canvas上绘制透明区域来显示自己 虽然它在界面上隶属于view hierarchy，但在WMS及SurfaceFlinger中都是和宿主窗口分离的，它拥有独立的绘制表面，绘制表面在app进程中表现为Surface对象，在系统进程中表现为在WMS中拥有独立的WindowState，在SurfaceFlinger中拥有独立的Layer，而普通view和其窗口拥有同一个绘制表面 TextureViewSurfaceView 拥有独立的绘制表面，而TextureView和View树共享绘制表面 TextureView通过观察BufferQueue中新的SurfaceTexture到来，然后调用invalidate触发View树重绘，如果有View叠加在TextureView上面，它们的脏区有交集，则会触发不必要的重绘，所以他的刷新操作比SurfaceView更重 界面卡顿requestLayout() vs invalidate()Binder进程通信方式(IPC)BundleParcel持久化方式Service广播消息机制触摸事件滑动冲突recyclerviewview生命周期BitmapANRLifecycle恢复数据onSaveInstanceState()+onRestoreInstanceState():会进行序列化到磁盘，耗时，杀进程依然存在 Fragment+setRetainInstance()：数据保存在内存，配置发生变化时数据依然存在，但杀进程后数据不存在 进程优先级LruCache启动优化LiveDataViewModel编译打包流程launch modeJavaArrayMap &amp; HashMapSparseArray &amp; HashMap泛型java对象生命周期类加载类构造顺序HashMapWeakHashMapLinkedHashMapThreadLocal内存泄漏引用异常注解OOM类型内存优化equals()hashCode()","categories":[],"tags":[]},{"title":"Android - Build System","slug":"Android-Build-System","date":"2023-04-14T03:53:38.000Z","updated":"2023-07-17T14:38:22.413Z","comments":true,"path":"2023/04/14/Android-Build-System/","link":"","permalink":"https://azxkenzo.github.io/2023/04/14/Android-Build-System/","excerpt":"","text":"Android build system 编译应用资源和源代码并将它们打包成 APK 或 Android App Bundle，你可以测试、部署、签名和分发这些应用程序包。 Android Studio 使用高级构建工具包 Gradle 来自动化和管理构建过程，同时允许你定义灵活的自定义构建配置。 每个构建配置都可以定义自己的一组代码和资源，同时重用所有版本的应用程序通用的部分。 Android Gradle plugin 与构建工具包配合使用，提供特定于构建和测试 Android 应用程序的流程和可配置设置。 Gradle 和 AGP 独立于 Android Studio 运行。 这意味着你可以从 Android Studio、你机器上的命令行或未安装 Android Studio 的机器（例如持续集成服务器）上构建你的 Android 应用程序。 The build process构建过程涉及许多工具和过程，可将你的项目转换为 Android 应用程序包 (APK) 或 Android App Bundle (AAB)。 AGP 为你完成大部分构建过程，但了解构建过程的某些方面可能很有用，这样你就可以调整构建以满足你的要求。 不同的项目可能有不同的构建目标。 例如，第三方库的构建会生成 AAR 或 JAR 库。 但是，应用是最常见的项目类型，应用项目的构建会生成应用的 debug 或 release APK 或 AAB，你可以部署、测试或发布给外部用户。 Android build glossary(词汇表)Gradle 和 AGP 可帮助你配置构建的以下方面： Build types构建类型定义了 Gradle 在构建和打包你的应用程序时使用的某些属性。 构建类型通常针对开发生命周期的不同阶段进行配置。 例如，debug 构建类型启用 debug 选项并使用 debug 密钥对应用程序进行签名，而 release 构建类型可能会收缩、混淆并使用 release 密钥对你的应用程序进行签名以进行分发。 必须至少定义一种构建类型来构建你的应用程序。 Android Studio 默认创建 debug 和 release 构建类型。 Product flavorsProduct flavors 代表你可以向用户发布的应用程序的不同版本，例如免费和付费版本。 可以自定义 Product flavor 以使用不同的代码和资源，同时共享和重用所有版本的应用程序通用的部分。 Product flavor 是可选的，你必须手动创建它们。 Build variantsBuild variants 是 build type 和 product flavor 的交叉产品，是 Gradle 用于构建你的应用程序的配置。 使用构建变体，可以在开发期间构建 product flavors 的 debug 版本，并签名 product flavors 的 release 版本用于分发。 虽然你不直接配置构建变体，但你可以配置构成它们的 build types 和 product flavors。 创建额外的 build types 或 product flavors 也会创建额外的构建变体。 Manifest entries可以在构建变体配置中为清单文件的某些属性指定值。 这些构建值会覆盖清单文件中的现有值。 如果你想使用不同的应用程序名称、最低 SDK 版本或目标 SDK 版本生成应用程序的多个变体，这将非常有用。 当存在多个清单时，清单合并工具合并清单设置。 Dependencies构建系统管理来自本地文件系统和远程存储库的项目依赖项。 这意味着你不必手动搜索、下载依赖项的二进制包并将其复制到项目目录中。 Signing构建系统允许你在构建配置中指定签名设置，并且它可以在构建过程中自动签署你的应用程序。 构建系统使用 使用已知凭证的默认密钥和证书对 debug 版本进行签名，以避免在构建时提示密码。 除非你为此构建明确定义签名配置，否则构建系统不会签署 release 版本。 如果你没有 release 密钥，你可以按照为你的应用程序签名中所述生成一个。 通过大多数应用程序商店分发应用程序需要签名的 release 版本。 Code and resource shrinking构建系统允许你为每个构建变体指定不同的 ProGuard 规则文件。 在构建你的应用程序时，构建系统会应用一组适当的规则来使用其内置的缩减工具（例如 R8）缩减你的代码和资源。 压缩代码和资源有助于减小 APK 或 AAB 的大小。 Multiple APK support构建系统可让你自动构建不同的 APK，每个 APK 仅包含特定屏幕密度或应用程序二进制接口 (ABI) 所需的代码和资源。 Build configuration创建自定义构建配置需要你更改一个或多个构建配置文件或 build.gradle.kts 文件。 这些纯文本文件使用领域特定语言 (DSL) 来描述和操作使用 Kotlin 脚本的构建逻辑，这是 Kotlin 语言的一种风格。 你还可以使用 Groovy（一种用于 Java 虚拟机 (JVM) 的动态语言）来配置你的构建。 用 Groovy 编写的构建脚本称为 build.gradle 文件。 你无需了解 Kotlin 脚本或 Groovy 即可开始配置你的构建，因为 Android Gradle 插件引入了你需要的大部分 DSL 元素。 要了解有关 Android Gradle 插件 DSL 的更多信息，请阅读 DSL 参考文档。 Kotlin 脚本还依赖于底层的 Gradle Kotlin DSL。 当开始一个新项目时，Android Studio 会自动为你创建其中一些文件并根据合理的默认值填充它们。 项目文件结构具有以下布局： 12345678910111213141516171819└── MyApp/ # Project ├── gradle/ │ └── wrapper/ │ └── gradle-wrapper.properties ├── build.gradle(.kts) ├── settings.gradle(.kts) └── app/ # Module ├── build.gradle(.kts) └── build/ ├── libs/ └── src/ └── main/ # Source set ├── java/ │ └── com.example.myapp ├── res/ │ ├── drawable/ │ ├── values/ │ └── ... └── AndroidManifest.xml 有一些 Gradle 构建配置文件是 Android 应用程序的标准项目结构的一部分。 在开始配置构建之前，了解每个文件的范围和用途以及它们定义的基本 DSL 元素非常重要。 The Gradle Wrapper fileGradle wrapper (gradlew) 是一个包含在源代码中的小型应用程序，用于下载并启动 Gradle 本身。 这将创建更加一致的构建执行。 开发人员下载应用程序源并运行 gradlew。 这将下载所需的 Gradle 发行版，并启动 Gradle 来构建你的应用程序。 gradle/wrapper/gradle-wrapper.properties 文件包含一个属性 distributionUrl，它描述了用于运行构建的 Gradle 版本。 提示：如果同时处理多个项目，如果可能，请确保所有项目使用相同的 Gradle 版本。 否则，Gradle 会为每个 Gradle 版本创建 Gradle 守护进程的副本，此外还会为用于运行 Gradle 的每个 JDK 创建单独的副本。 这会增加内存和 CPU 使用率，可能会减慢构建速度或影响计算机上的其他工作。 The Gradle settings filesettings.gradle.kts 文件（对于 Kotlin DSL）或 settings.gradle 文件（对于 Groovy DSL）位于根项目目录中。 此设置文件定义项目级 repository 设置，并通知 Gradle 在构建你的应用程序时应包含哪些模块。 多模块项目需要指定应该进入最终构建的每个模块。 12345678910111213141516171819202122232425262728293031323334353637383940pluginManagement &#123; /** * The pluginManagement.repositories block configures the * repositories Gradle uses to search or download the Gradle plugins and * their transitive dependencies. Gradle pre-configures support for remote * repositories such as JCenter, Maven Central, and Ivy. You can also use * local repositories or define your own remote repositories. The code below * defines the Gradle Plugin Portal, Google&#x27;s Maven repository, * and the Maven Central Repository as the repositories Gradle should use to look for its * dependencies. */ repositories &#123; gradlePluginPortal() google() mavenCentral() &#125;&#125;dependencyResolutionManagement &#123; /** * The dependencyResolutionManagement.repositories * block is where you configure the repositories and dependencies used by * all modules in your project, such as libraries that you are using to * create your application. However, you should configure module-specific * dependencies in each module-level build.gradle file. For new projects, * Android Studio includes Google&#x27;s Maven repository and the Maven Central * Repository by default, but it does not configure any dependencies (unless * you select a template that requires some). */ repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories &#123; google() mavenCentral() &#125;&#125;rootProject.name = &quot;My Application&quot;include(&quot;:app&quot;) The top-level build file顶级 build.gradle.kts 文件（对于 Kotlin DSL）或 build.gradle 文件（对于 Groovy DSL）位于根项目目录中。 它定义了适用于项目中所有模块的依赖项。 默认情况下，顶级构建文件使用 plugins 块来定义项目中所有模块通用的 Gradle 依赖项。 此外，顶级构建文件包含用于清理构建目录的代码。 1234567891011121314plugins &#123; /** * Use `apply false` in the top-level build.gradle file to add a Gradle * plugin as a build dependency but not apply it to the current (root) * project. Don&#x27;t use `apply false` in sub-projects. For more information, * see Applying external plugins with same version to subprojects. */ id &#x27;com.android.application&#x27; version &#x27;8.0.0&#x27; apply false id &#x27;com.android.library&#x27; version &#x27;8.0.0&#x27; apply false id &#x27;org.jetbrains.kotlin.android&#x27; version &#x27;1.8.10&#x27; apply false&#125; Configure project-wide properties对于包含多个模块的 Android 项目，在项目级别定义某些属性并在所有模块之间共享它们可能很有用。 你可以通过向顶级 build.gradle.kts 文件（对于 Kotlin DSL）或 build.gradle 文件（对于 Groovy DSL）中的 ext 块添加额外的属性来做到这一点： 1234567891011// This block encapsulates custom properties and makes them available to all// modules in the project. The following are only a few examples of the types// of properties you can define.ext &#123; sdkVersion = 33 // You can also create properties to specify versions for dependencies. // Having consistent versions between modules can avoid conflicts with behavior. appcompatVersion = &quot;1.6.1&quot; ...&#125; 要从同一项目中的模块访问这些属性，请在模块级构建脚本中使用以下语法。 12345678910111213android &#123; // Use the following syntax to access properties you defined at the project level: // rootProject.ext.property_name compileSdk rootProject.ext.sdkVersion ...&#125;...dependencies &#123; implementation &quot;androidx.appcompat:appcompat:$&#123;rootProject.ext.appcompatVersion&#125;&quot; ...&#125; The module-level build file模块级 build.gradle.kts（对于 Kotlin DSL）或 build.gradle 文件（对于 Groovy DSL）位于每个 project/module/ 目录中。 它允许你为其所在的特定模块配置构建设置。配置这些构建设置可以让你提供自定义打包选项，例如其他 build types and product flavors，并覆盖 main/ 应用程序清单或顶级构建脚本中的设置 . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * 构建配置中的第一部分将 Android Gradle 插件应用于此构建， * 并使 android 块可用于指定特定于 Android 的构建选项。 */plugins &#123; id &#x27;com.android.application&#x27;&#125;/** * 找到（并可能下载）用于构建 kotlin 源代码的 JDK。 这也作为 sourceCompatibility、targetCompatibility 和 jvmTarget 的默认值。 * 请注意，这不会影响使用哪个 JDK 来运行 Gradle 构建本身，并且不需要考虑 Gradle 插件（例如 Android Gradle Plugin）所需的 JDK 版本 */kotlin &#123; jvmToolchain 11&#125;/** * android 块是你配置所有 Android 特定构建选项的地方。 */android &#123; /** * The app&#x27;s namespace. Used primarily to access app resources. */ namespace &#x27;com.example.myapp&#x27; /** * compileSdk 指定 Gradle 应该用来编译你的应用程序的 Android API 级别。 * 这意味着你的应用程序可以使用此 API 级别及更低级别中包含的 API 功能。 */ compileSdk 33 /** * defaultConfig 块封装了所有构建变体的默认设置和条目， * 并且可以从构建系统动态覆盖 main/AndroidManifest.xml 中的一些属性。 * 你可以配置产品 flavor 来覆盖不同版本应用程序的这些值。 */ defaultConfig &#123; // Uniquely identifies the package for publishing. applicationId &#x27;com.example.myapp&#x27; // Defines the minimum API level required to run the app. minSdk 21 // Specifies the API level used to test the app. targetSdk 33 // Defines the version number of your app. versionCode 1 // Defines a user-friendly version name for your app. versionName &quot;1.0&quot; &#125; /** * The buildTypes block is where you can configure multiple build types. * By default, the build system defines two build types: debug and release. The * debug build type is not explicitly shown in the default build configuration, * but it includes debugging tools and is signed with the debug key. The release * build type applies ProGuard settings and is not signed by default. */ buildTypes &#123; /** * By default, Android Studio configures the release build type to enable code * shrinking, using minifyEnabled, and specifies the default ProGuard rules file. */ release &#123; minifyEnabled true // Enables code shrinking for the release build type. proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27; &#125; &#125; /** * The productFlavors block is where you can configure multiple product flavors. * This lets you create different versions of your app that can * override the defaultConfig block with their own settings. Product flavors * are optional, and the build system does not create them by default. * * This example creates a free and paid product flavor. Each product flavor * then specifies its own application ID, so that they can exist on the Google * Play Store, or an Android device, simultaneously. * * If you declare product flavors, you must also declare flavor dimensions * and assign each flavor to a flavor dimension. */ flavorDimensions &quot;tier&quot; productFlavors &#123; free &#123; dimension &quot;tier&quot; applicationId &#x27;com.example.myapp.free&#x27; &#125; paid &#123; dimension &quot;tier&quot; applicationId &#x27;com.example.myapp.paid&#x27; &#125; &#125; /** * 要覆盖源和目标兼容性（如果与toolchain JDK 版本不同），请添加以下内容。 * 所有这些默认值与 kotlin.jvmToolchain 相同。 如果你对这些值和 kotlin.jvmToolchain 使用相同的版本，则可以删除这些块。 */ //compileOptions &#123; // sourceCompatibility JavaVersion.VERSION_11 // targetCompatibility JavaVersion.VERSION_11 //&#125; //kotlinOptions &#123; // jvmTarget = &#x27;11&#x27; //&#125;&#125;/** * The dependencies block in the module-level build configuration file * specifies dependencies required to build only the module itself. * To learn more, go to Add build dependencies. */dependencies &#123; implementation project(&quot;:lib&quot;) implementation &#x27;androidx.appcompat:appcompat:1.6.1&#x27; implementation fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;])&#125; Gradle properties filesGradle 还包含两个属性文件，位于你的根项目目录中，你可以使用它们来指定 Gradle 构建工具包本身的设置： gradle.properties 你可以在此处配置项目范围的 Gradle 设置，例如 Gradle 守护程序的最大堆大小。 local.properties 为构建系统配置本地环境属性，包括以下内容： ndk.dir - NDK 的路径。 此属性已被弃用。 NDK 的任何下载版本都安装在 Android SDK 目录中的 ndk 目录中。 sdk.dir - SDK 的路径。 cmake.dir - CMake 的路径。 ndk.symlinkdir - 在 Android Studio 3.5 及更高版本中，创建指向 NDK 的符号链接，该链接可以比安装的 NDK 路径更短。 Source setsAndroid Studio 在逻辑上将每个模块的源代码和资源分组到 source sets 中。 当你创建一个新模块时，Android Studio 会在该模块中创建一个 main/ source 集。 模块的 main/ 源集包括其所有构建变体使用的代码和资源。 其他源集目录是可选的，Android Studio 不会在你配置新的构建变体时自动为你创建它们。 但是，与 main/ 类似，创建源集有助于组织 Gradle 仅在构建特定版本的应用程序时才应使用的文件和资源： src/main/ 此源集包括所有构建变体通用的代码和资源。 src/buildType/ 创建此源集以仅包含特定构建类型的代码和资源。 src/productFlavor/ 创建此源集以仅包含特定产品风格的代码和资源。 src/productFlavorBuildType/ 创建此源集以仅包含特定构建变体的代码和资源。 例如，要生成应用程序的“fullDebug”版本，构建系统会合并来自以下源集中的代码、设置和资源： src/fullDebug/ (the build variant source set) src/debug/ (the build type source set) src/full/ (the product flavor source set) src/main/ (the main source set) 注意：当你在 Android Studio 中创建新文件或目录时，请使用 File &gt; New 菜单选项为特定源集创建它。 你可以选择的源集基于你的构建配置，Android Studio 会自动创建所需的目录（如果它们尚不存在）。 如果不同的源集包含同一文件的不同版本，Gradle 在决定使用哪个文件时会使用以下优先级顺序。 左侧的源集覆盖右侧源集的文件和设置： build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependencies Java versions in Android builds无论你的源代码是用 Java、Kotlin 还是两者编写的，你都必须在多个地方为你的构建选择 JDK 或 Java 语言版本。 词汇表Java Development Kit (JDK)JDK 包含： 工具，例如编译器、分析器和存档创建器。 这些在构建过程中在幕后用于创建应用程序。 包含可从 Kotlin 或 Java 源代码调用的 API 的库。 请注意，并非所有功能均可在 Android 上使用。 Java 虚拟机 (JVM)，执行 Java 应用程序的解释器。 你使用 JVM 来运行 Android Studio IDE 和 Gradle 构建工具。 Android 设备或模拟器上不使用 JVM。 JetBrains Runtime (JBR)JetBrains Runtime (JBR) 是一个增强的 JDK，随 Android Studio 一起分发。 它包括在 Studio 和相关 JetBrains 产品中使用的多项优化，但也可用于运行其他 Java 应用程序。 如何选择 JDK 来运行 Android Studio？我们建议你使用 JBR 来运行 Android Studio。 它与 Android Studio 一起部署并用于测试 Android Studio，并包含优化 Android Studio 使用的增强功能。 为确保这一点，请勿设置 STUDIO_JDK 环境变量。 Android Studio 的启动脚本按以下顺序查找 JVM： STUDIO_JDK environment variable studio.jdk directory (in the Android Studio distribution) jbr directory (JetBrains Runtime), in the Android Studio distribution. Recommended. JDK_HOME environment variable JAVA_HOME environment variable java executable in the PATH environment variable 如何选择运行我的 Gradle 构建的 JDK？如果你使用 Android Studio 中的按钮运行 Gradle，则将使用 Android Studio 设置中设置的 JDK 来运行 Gradle。 如果你在 Android Studio 内部或外部的终端中运行 Gradle，JAVA_HOME 环境变量（如果设置）将确定哪个 JDK 运行 Gradle 脚本。 如果未设置 JAVA_HOME，它将使用 PATH 环境变量中的 java 命令。 为了获得最一致的结果，请确保设置 JAVA_HOME 环境变量，并将 Android Studio 中的 Gradle JDK 设置为相同的 JDK。 注意：如果你通过右键单击并选择使用 IDE 运行突出显示的命令来在 Android Studio 终端中运行 Gradle 命令，那么它将使用 Android Studio 设置中的 JDK，而不是 JAVA_HOME。 运行构建时，Gradle 会创建一个称为 daemon 的进程来执行实际构建。 只要构建使用相同的 JDK 和 Gradle 版本，就可以重用此过程。 重用 daemon 可以减少启动新 JVM 和初始化构建系统的时间。 如果你使用不同的 JDK 或 Gradle 版本开始构建，则会创建额外的 daemon，从而消耗更多的 CPU 和内存。 提示：同时处理多个项目时，如果可能，请在其 gradle-wrapper.properties 文件中指定相同的 Gradle 版本，以减少创建的 Gradle daemon 的数量。 Set the Gradle JDK in Android Studio要设置并选择下载 Android Studio 用于运行 Gradle 的 JDK，请转至 Settings &gt; Build, Execution, Deployment &gt; Build Tools &gt; Gradle and edit the Gradle JDK field. 确保选择的 JDK 版本高于或等于你在 Gradle 构建中使用的插件所使用的 JDK 版本。 要确定 Android Gradle 插件 (AGP) 所需的最低 JDK 版本，请参阅发行说明中的兼容性表。 例如，Android Gradle 插件版本 8.x 需要 JDK 17。 我可以在 Java 或 Kotlin 源代码中使用哪些 Java API？Android 应用程序可以使用 JDK 中定义的部分 API，但不是全部。 Android SDK 定义了许多 Java 库函数的实现作为其可用 API 的一部分。 compileSdk 属性指定编译 Kotlin 或 Java 源代码时要使用的 Android SDK 版本。 每个版本的 Android 都支持特定版本的 JDK 及其可用 Java API 的子集。 如果你使用的 Java API 在 compileSdk 中可用，而在指定的 minSdk 中不可用，则你可以通过称为脱糖的过程在早期版本的 Android 中使用该 API。 请参阅通过脱糖提供的 Java 11+ API，了解受支持的 API。 使用下表确定每个 Android API 支持哪个 Java 版本，以及在哪里可以找到有关可用 Java API 的详细信息。 Android Java API and language features supported14 (API 34) 17 Core libraries13 (API 33) 11 Core libraries12 (API 32) 11 Java API11 and lower Android versions 哪个 JDK 编译我的 Java 源代码？Java toolchain JDK 包含用于构建任何 Java 源代码的 Java 编译器。 该 JDK 还运行 Kotlin 编译器（在 JVM 上运行）。 toolchain默认为用于运行 Gradle 的 JDK。 如果你使用默认值并在不同的计算机（例如，本地计算机和单独的持续集成服务器）上运行构建，则使用不同的 JDK 版本时，构建的结果可能会有所不同。 要创建更一致的构建，你可以显式指定 Java toolchain版本。 指定这一点： 在运行构建的系统上找到兼容的 JDK。 如果不存在兼容的 JDK（并且定义了toolchain解析器），则下载一个。 公开toolchain Java API 以供源代码调用。 使用 Java 语言版本编译 Java 源代码。 提供 sourceCompatibility 和 targetCompatibility 的默认值。 我们建议你始终指定 Java toolchain，并确保安装了指定的 JDK，或者将toolchain解析器添加到你的构建中。 无论你的源代码是用 Java、Kotlin 还是两者编写的，你都可以指定toolchain。 在模块的 build.gradle(.kts) 文件的顶层指定toolchain。 如果你的源代码仅用 Java 编写，请指定 Java toolchain版本，如下所示： 12345java &#123; toolchain &#123; languageVersion = JavaLanguageVersion.of(17) &#125;&#125; 如果你的源仅是 Kotlin 或 Kotlin 和 Java 的混合，请指定 Java toolchain版本，如下所示： 123kotlin &#123; jvmToolchain 17&#125; toolchain JDK 版本可以与用于运行 Gradle 的 JDK 相同，但请记住它们有不同的用途。 我可以在 Java 源代码中使用哪些 Java 语言源功能？sourceCompatibility 属性确定在编译 Java 源代码期间哪些 Java 语言功能可用。 它不影响 Kotlin 源。 如果未指定，则默认为用于运行 Gradle 的 Java toolchain或 JDK。 我们建议你始终显式指定toolchain（首选）或 sourceCompatibility。 在模块的 build.gradle(.kts) 文件中指定 sourceCompatibility。 12345android &#123; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_17 &#125;&#125; 注意：从 Android Studio Giraffe 开始，导入项目时，sourceCompatibility 选项也用作编写 Java 源代码时 IDE 代码辅助和 linting 的默认选项。 某些 Java 语言功能需要库支持，并且在 Android 上不可用。 compileSdk 选项确定哪些库可用。 其他功能（例如 switch 表达式）仅需要 Java 编译器并可在 Android 上运行。 编译 Kotlin 或 Java 源代码时可以使用哪些 Java 二进制功能？指定 targetCompatibility 和 jvmTarget 分别确定为编译的 Java 和 Kotlin 源生成字节码时使用的 Java 类格式版本。 一些 Kotlin 功能在添加等效的 Java 功能之前就已存在。 早期的 Kotlin 编译器必须创建自己的方式来表示这些 Kotlin 功能。 其中一些功能后来被添加到 Java 中。 在更高的 jvmTarget 级别中，Kotlin 编译器可能会直接使用 Java 功能，这可能会带来更好的性能。 targetCompatibility 默认与 sourceCompatibility 的值相同，但如果指定，则必须大于或等于 sourceCompatibility。 jvmTarget 默认为toolchain版本。 不同版本的Android支持不同版本的Java。 你可以通过增加 targetCompatibility 和 jvmTarget 来利用其他 Java 功能，但这可能会迫使你还增加最低 Android SDK 版本以确保该功能可用。 12345678android &#123; compileOptions &#123; targetCompatibility JavaVersion.VERSION_17 &#125; kotlinOptions &#123; jvmTarget &#x27;17&#x27; &#125;&#125; Configure the app moduleSet the application ID每个 Android 应用程序都有一个唯一的应用程序 ID，看起来像 Java 或 Kotlin 包名称，例如 com.example.myapp。 此 ID 在设备上和 Google Play 商店中唯一标识你的应用程序。 重要提示：一旦你发布了你的应用程序，你就永远不应更改应用程序 ID。 如果你更改应用程序 ID，Google Play 商店会将上传视为完全不同的应用程序。 如果你想上传应用的新版本，你必须使用与最初发布时相同的应用程序 ID 和签名证书。 应用程序 ID 由模块的 build.gradle.kts 文件中的 applicationId 属性定义，如下所示： 12345678910android &#123; defaultConfig &#123; applicationId &quot;com.example.myapp&quot; minSdkVersion 15 targetSdkVersion 24 versionCode 1 versionName &quot;1.0&quot; &#125; ...&#125; 尽管应用程序 ID 看起来像传统的 Kotlin 或 Java 包名称，但应用程序 ID 的命名规则更加严格： 它必须至少有两个段（一个或多个点）。 每个段必须以字母开头。 所有字符都必须是字母数字或下划线 [a-zA-Z0-9_]。 当你在 Android Studio 中创建新项目时，applicationId 会自动分配你在设置期间选择的包名称。 从那时起，你可以在技术上独立切换这两个属性，但不建议这样做。 建议你在设置应用程序 ID 时执行以下操作： 保持应用程序 ID 与命名空间相同。 这两个属性之间的区别可能有点令人困惑，但如果保持它们相同，就没有什么可担心的。 发布应用程序后，请勿更改应用程序 ID。 如果你更改它，Google Play 商店会将后续上传的内容视为新应用。 显式定义应用程序 ID。 如果未使用 applicationId 属性显式定义应用程序 ID，它会自动采用与命名空间相同的值。 这意味着更改命名空间会更改应用程序 ID，这通常不是你想要的。 注意：应用程序 ID 过去直接与代码的包名称相关联，因此某些 Android API 在其方法名称和参数名称中使用术语“包名称”。 这实际上是你的应用程序 ID。 例如，Context.getPackageName() 方法返回你的应用程序 ID。 永远不需要在应用程序代码之外共享代码的真实包名称。 Set the namespace每个 Android 模块都有一个命名空间，用作其生成的 R 和 BuildConfig 类的 Kotlin 或 Java 包名称。 你的命名空间由模块的 build.gradle.kts 文件中的命名空间属性定义，如以下代码片段所示。 命名空间最初设置为你在创建项目时选择的包名称。 在将你的应用程序构建到最终应用程序包 (APK) 中时，Android 构建工具使用该命名空间作为你应用程序生成的 R 类的命名空间，该类用于访问你的应用程序资源。 例如，在前面的构建文件中，R 类是在 com.example.myapp.R 中创建的。 你为 build.gradle.kts 文件的命名空间属性设置的名称应始终与项目的基本包名称相匹配，你可以在其中保存活动和其他应用程序代码。 你的项目中可以有其他子包，但这些文件必须使用 namespace 属性中的命名空间导入 R 类。 Add build dependenciesDependency types要向项目添加依赖项，请在模块的 build.gradle.kts 文件的依赖项块中指定依赖项配置，例如 implementation。 例如，应用模块的以下 build.gradle.kts 文件包含三种不同类型的依赖项： 12345678910111213141516plugins &#123; id &#x27;com.android.application&#x27;&#125;android &#123; ... &#125;dependencies &#123; // Dependency on a local library module implementation project(&#x27;:mylibrary&#x27;) // Dependency on local binaries implementation fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;]) // Dependency on a remote binary implementation &#x27;com.example.android:app-magic:12.3&#x27;&#125; 这些中的每一个都请求不同类型的库依赖性，如下所示： Local library module dependencyimplementation project(&#39;:mylibrary&#39;) 这声明了对名为“mylibrary”的 Android 库模块的依赖（此名称必须与使用 include: 在你的 settings.gradle.kts 文件中定义的库名称相匹配）。 当你构建应用程序时，构建系统会编译库模块并将生成的编译内容打包到应用程序中。 Local binary dependencyimplementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) Gradle 在项目的 module_name/libs/ 目录中声明对 JAR 文件的依赖项（因为 Gradle 读取相对于 build.gradle.kts 文件的路径）。 或者，你可以指定单个文件，如下所示： implementation files(&#39;libs/foo.jar&#39;, &#39;libs/bar.jar&#39;) Remote binary dependencyimplementation &#39;com.example.android:app-magic:12.3&#39; Native dependencies从 Android Gradle 插件 4.0 开始，本机依赖项也可以按照本页所述的方式导入。 依赖公开本机库的 AAR 将自动使它们可用于 externalNativeBuild 使用的构建系统。 要从你的代码访问这些库，你必须在你的本机构建脚本中链接到它们。 在此页面上，请参阅使用本机依赖项。 Dependency configurations在 dependencies 块中，你可以使用几种不同的依赖配置之一来声明库依赖。 每个依赖项配置都为 Gradle 提供了有关如何使用依赖项的不同说明。 下表描述了你可以在 Android 项目中用于依赖项的每个配置。 该表还将这些配置与从 Android Gradle 插件 3.0.0 开始弃用的配置进行了比较。 implementation Gradle 将依赖项添加到编译类路径并将依赖项打包到构建输出。 但是，当你的模块配置 implementation 依赖项时，它会让 Gradle 知道你不希望模块在编译时将依赖项泄露给其他模块。 也就是说，依赖项仅在运行时对其他模块可用。 使用此依赖项配置而不是 api 或 compile（已弃用）可以显着缩短构建时间，因为它减少了构建系统需要重新编译的模块数量。 例如，如果一个 implementation 依赖项更改了它的 API，Gradle 只会重新编译该依赖项和直接依赖它的模块。 大多数应用程序和测试模块应使用此配置。 api Gradle 将依赖项添加到编译类路径和构建输出。 当一个模块包含一个 api 依赖项时，它会让 Gradle 知道该模块想要将该依赖项传递给其他模块，以便它们在运行时和编译时都可用。 此配置的行为就像 compile（现已弃用）一样，但你应该谨慎使用它，并且仅在需要传递到其他上游消费者的依赖项中使用。 这是因为，如果 api 依赖项更改了其外部 API，Gradle 会在编译时重新编译有权访问该依赖项的所有模块。 因此，拥有大量的 api 依赖项会显着增加构建时间。 除非你想将依赖项的 API 公开给单独的模块，否则库模块应该使用 implementation 依赖项。 compileOnly Gradle 仅将依赖项添加到编译类路径（即，它不会添加到构建输出）。 这在你创建 Android 模块并且在编译期间需要依赖项时很有用，但在运行时是否存在它是可选的。 如果你使用此配置，那么你的库模块必须包含一个运行时条件以检查依赖项是否可用，然后优雅地更改其行为，以便在未提供时它仍然可以运行。 这有助于通过不添加不重要的临时依赖项来减小最终应用程序的大小。 此配置的行为与提供的一样（现已弃用）。 runtimeOnly Gradle 仅将依赖项添加到构建输出，以供在运行时使用。 也就是说，它不会添加到编译类路径中。 此配置的行为就像 apk（现已弃用）。 annotationProcessor 要添加对注解处理器库的依赖，你必须使用 annotationProcessor 配置将其添加到注解处理器类路径中。 这是因为使用此配置通过将编译类路径与注释处理器类路径分开来提高构建性能。 如果 Gradle 在编译类路径上找到注解处理器，它会停用避免编译，这会对构建时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注解处理器）。 如果 Android Gradle 插件的 JAR 文件包含以下文件，则它假定依赖项是注解处理器： META-INF&#x2F;services&#x2F;javax.annotation.processing.Processor 如果插件检测到编译类路径上的注解处理器，它会产生构建错误。 注意：Kotlin 项目应该使用 kapt 来声明注释处理器依赖项。 以上所有配置都将依赖项应用于所有构建变体。 如果你只想为特定构建变体源集或测试源集声明依赖项，则必须将配置名称大写，并在其前面加上构建变体或测试源集的名称。 例如，要仅将 implementation 依赖项添加到你的“free” product flavor（使用远程二进制依赖项），它看起来像这样： 123dependencies &#123; freeImplementation &#x27;com.google.firebase:firebase-ads:9.8.0&#x27;&#125; 但是，如果要为结合了 product flavor and a build type 的变体添加依赖项，则必须在 configurations 块中初始化配置名称。 以下示例将 runtimeOnly 依赖项添加到你的“freeDebug”构建变体（使用本地二进制依赖项）。 12345678configurations &#123; // Initializes a placeholder for the freeDebugRuntimeOnly dependency configuration. freeDebugRuntimeOnly &#123;&#125;&#125;dependencies &#123; freeDebugRuntimeOnly fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;])&#125; Migrate build configuration from Groovy to Kotlin注意：Kotlin 是从 Android Studio Giraffe 开始的构建配置的默认语言。 Convert the syntax在方法调用中添加括号Groovy 允许在方法调用中省略括号，而 Kotlin 需要它们。 要迁移你的配置，请为这些类型的方法调用添加括号。 此代码显示如何在 Groovy 中配置设置： 1compileSdkVersion 30 这是用 Kotlin 编写的相同代码： 1compileSdkVersion(30) 添加 &#x3D; 到赋值调用Groovy DSL 允许在分配属性时省略赋值运算符 &#x3D;，而 Kotlin 需要它。 此代码显示如何在 Groovy 中分配属性： 1234java &#123; sourceCompatibility JavaVersion.VERSION_17 targetCompatibility JavaVersion.VERSION_17&#125; 此代码显示如何在 Kotlin 中分配属性： 1234java &#123; sourceCompatibility = JavaVersion.VERSION_17 targetCompatibility = JavaVersion.VERSION_17&#125; Convert strings以下是 Groovy 和 Kotlin 之间的字符串差异： 字符串的双引号：虽然 Groovy 允许使用单引号定义字符串，但 Kotlin 需要双引号。 点分表达式上的字符串插值：在 Groovy 中，可以仅使用 $ 前缀对点分表达式进行字符串插值，但 Kotlin 要求用大括号括起点分表达式。 例如，在 Groovy 中，可以使用 $project.rootDir，如以下代码片段所示：1myRootDirectory = &quot;$project.rootDir/tools/proguard-rules-debug.pro&quot; 然而，在 Kotlin 中，前面的 project 在项目上调用 toString()，而不是在 project.rootDir 上。 要获取根目录的值，请将 $&#123;project.rootDir&#125; 表达式用花括号括起来：1myRootDirectory = &quot;$&#123;project.rootDir&#125;/tools/proguard-rules-debug.pro&quot; Rename file extensions在迁移其内容时将 .kts 附加到每个构建文件。 例如，选择一个构建文件，如 settings.gradle 文件。 将文件重命名为 settings.gradle.kts 并将文件的内容转换为 Kotlin。 确保项目在每个构建文件迁移后仍然可以编译。 先迁移最小的文件，积累经验，然后继续。 你可以在一个项目中混合使用 Kotlin 和 Groovy 构建文件，因此请花点时间谨慎地进行迁移。 Replace def with val or var这是 Groovy 中的变量声明： 1def building64Bit = false 这是用 Kotlin 编写的相同代码： 1val building64Bit = false 布尔属性前缀为 isGroovy 使用基于属性名称的属性推导逻辑。 对于布尔属性 foo，其推导方法可以是 getFoo、setFoo 或 isFoo。 因此，一旦转换为 Kotlin，需要将属性名称更改为 Kotlin 不支持的推导方法。 例如，对于 buildTypes DSL 布尔元素，你需要在它们前面加上 is。 此代码显示如何在 Groovy 中设置布尔属性： 123456789101112android &#123; buildTypes &#123; release &#123; minifyEnabled true shrinkResources true ... &#125; debug &#123; debuggable true ... &#125; ... 以下是 Kotlin 中的相同代码。 请注意，属性以 is 为前缀。 123456789101112android &#123; buildTypes &#123; getByName(&quot;release&quot;) &#123; isMinifyEnabled = true isShrinkResources = true ... &#125; getByName(&quot;debug&quot;) &#123; isDebuggable = true ... &#125; ... Convert lists and mapsGroovy 和 Kotlin 中的列表和映射是使用不同的语法定义的。 Groovy 使用 []，而 Kotlin 使用 listOf 或 mapOf 显式调用集合创建方法。 确保在迁移时将 [] 替换为 listOf 或 mapOf。 下面是在 Groovy 和 Kotlin 中定义列表的方法： 1jvmOptions += [&quot;-Xms4000m&quot;, &quot;-Xmx4000m&quot;, &quot;-XX:+HeapDumpOnOutOfMemoryError&lt;/code&gt;&quot;] 这是用 Kotlin 编写的相同代码： 1jvmOptions += listOf(&quot;-Xms4000m&quot;, &quot;-Xmx4000m&quot;, &quot;-XX:+HeapDumpOnOutOfMemoryError&quot;) 下面是在 Groovy 和 Kotlin 中定义映射的方法： 1def myMap = [key1: &#x27;value1&#x27;, key2: &#x27;value2&#x27;] 这是用 Kotlin 编写的相同代码： 1val myMap = mapOf(&quot;key1&quot; to &quot;value1&quot;, &quot;key2&quot; to &quot;value2&quot;) Configure build types在 Kotlin DSL 中，只有 debug and release 构建类型是隐式可用的。 所有其他自定义构建类型必须手动创建。 在 Groovy 中，可以使用 debug, release 和某些其他构建类型，而无需先创建它们。 以下代码片段显示了 Groovy 中 debug, release, and benchmark 构建类型的配置。 1234567891011buildTypes &#123; debug &#123; ... &#125; release &#123; ... &#125; benchmark &#123; ... &#125;&#125; 要在 Kotlin 中创建等效配置，必须显式创建 benchmark 构建类型。 123456789101112buildTypes &#123; debug &#123; ... &#125; release &#123; ... &#125; register(&quot;benchmark&quot;) &#123; ... &#125;&#125; 从构建脚本迁移到插件块如果你的构建使用 buildscript &#123;&#125; 块向项目添加插件，你应该重构为使用 plugins &#123;&#125; 块。 plugins &#123;&#125; 块使应用插件变得更容易，并且它与 version catalogs 配合得很好。 此外，当在构建文件中使用 plugins &#123;&#125; 块时，即使构建失败，Android Studio 也会知道上下文。 此上下文有助于修复你的 Kotlin DSL 文件，因为它允许 Studio IDE 执行代码完成并提供其他有用的建议。 Find the plugin IDs虽然 buildscript &#123;&#125; 块使用插件的 Maven 坐标将插件添加到构建类路径，例如 com.android.tools.build:gradle:7.4.0，但 plugins &#123;&#125; 块使用插件 ID。 对于大多数插件，插件 ID 是你使用 apply plugin 应用它们时使用的字符串。 例如，以下插件 ID 是 Android Gradle 插件的一部分： com.android.application com.android.library com.android.lint com.android.test Kotlin 插件可以被多个插件 ID 引用。 我们建议使用带命名空间的插件 ID，并通过下表从速记重构为带命名空间的插件 ID：Shorthand plugin IDs Namespaced plugin IDskotlin org.jetbrains.kotlin.jvmkotlin-android org.jetbrains.kotlin.androidkotlin-kapt org.jetbrains.kotlin.kaptkotlin-parcelize org.jetbrains.kotlin.plugin.parcelize 执行重构知道所用插件的 ID 后，请执行以下步骤： 如果你仍有在 buildscript &#123;&#125; 块中声明的插件存储库，请将它们移至 settings.gradle 文件。 将插件添加到顶层 build.gradle 文件中的 plugins &#123;&#125; 块中。 你需要在此处指定插件的 ID 和版本。 如果插件不需要应用于根项目，请使用 apply false。 从顶层 build.gradle.kts 文件中删除 classpath 条目。 通过将插件添加到模块级 build.gradle 文件中的 plugins &#123;&#125; 块来应用插件。 你只需要在这里指定插件的 ID，因为版本是从根项目继承的。 从模块级 build.gradle 文件中删除对插件的 apply plugin 调用。 例如，此设置使用 buildscript &#123;&#125; 块： 1234567891011121314151617// Top-level build.gradle filebuildscript &#123; repositories &#123; google() mavenCentral() gradlePluginPortal() &#125; dependencies &#123; classpath(&quot;com.android.tools.build:gradle:7.4.0&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.8.0&quot;) ... &#125;&#125;// Module-level build.gradle fileapply(plugin: &quot;com.android.application&quot;)apply(plugin: &quot;kotlin-android&quot;) 这是使用 plugins &#123;&#125; 块的等效设置： 12345678910111213141516171819202122// Top-level build.gradle fileplugins &#123; id &#x27;com.android.application&#x27; version &#x27;7.4.0&#x27; apply false id &#x27;org.jetbrains.kotlin.android&#x27; version &#x27;1.8.0&#x27; apply false ...&#125;// Module-level build.gradle fileplugins &#123; id &#x27;com.android.application&#x27; id &#x27;org.jetbrains.kotlin.android&#x27; ...&#125;// settings.gradlepluginManagement &#123; repositories &#123; google() mavenCentral() gradlePluginPortal() &#125;&#125; Convert the plugins block从 plugins &#123;&#125; 块应用插件在 Groovy 和 Kotlin 中是类似的。 以下代码展示了在使用 version catalogs 时如何在 Groovy 中应用插件： 1234567891011// Top-level build.gradle fileplugins &#123; alias libs.plugins.android.application apply false ...&#125;// Module-level build.gradle fileplugins &#123; alias libs.plugins.android.application ...&#125; 以下代码显示了如何在 Kotlin 中执行相同的操作： 1234567891011// Top-level build.gradle.kts fileplugins &#123; alias(libs.plugins.android.application) apply false ...&#125;// Module-level build.gradle.kts fileplugins &#123; alias(libs.plugins.android.application) ...&#125; 以下代码展示了在不使用 version catalogs 时如何在 Groovy 中应用插件： 1234567891011// Top-level build.gradle fileplugins &#123; id &#x27;com.android.application&#x27; version &#x27;7.3.0&#x27; apply false ...&#125;// Module-level build.gradle fileplugins &#123; id &#x27;com.android.application&#x27; ...&#125; 以下代码显示了如何在 Kotlin 中执行相同的操作： 1234567891011// Top-level build.gradle.kts fileplugins &#123; id(&quot;com.android.application&quot;) version &#x27;7.3.0&#x27; apply false ...&#125;// Module-level build.gradle.kts fileplugins &#123; id(&quot;com.android.application&quot;) ...&#125; 其他有关其他功能的 Kotlin 代码示例，请参阅以下文档页面： If you have a ProGuard configuration, refer to Enable shrinking, obfuscation, and optimization. If you have a signingConfig {} block, refer to Remove signing information from your build files. If you use project-wide properties, refer to Configure project-wide properties.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - Animation","slug":"Android-Animation","date":"2023-04-11T07:13:58.000Z","updated":"2023-07-18T03:58:41.833Z","comments":true,"path":"2023/04/11/Android-Animation/","link":"","permalink":"https://azxkenzo.github.io/2023/04/11/Android-Animation/","excerpt":"","text":"关于 Android 中的 animation为 bitmap 设置动画要对 bitmap 图形（例如 icon 或插图）进行动画处理，请使用 drawable animation API。 通常，这些动画是使用 drawable 资源静态定义的，但您也可以在运行时定义动画行为。 例如，向用户传达两个操作相关的一个好方法是为播放按钮设置动画，当点击该按钮时该按钮会转换为暂停按钮。 为 UI 可见性和运动设置动画当您需要更改布局中 view 的可见性或位置时，最好包含微妙的动画来帮助用户了解 UI 的变化方式。 要在当前布局中移动、显示或隐藏 view，您可以使用 android.animation 包提供的 property animation 系统。这些 API 在一段时间内更新 View 对象的 properties，随着属性的变化不断重绘 view。 例如，当您更改 position 属性时，view 会在屏幕上移动。当您更改 alpha 属性时，view 会淡入或淡出。 要创建这些动画的最简单方法，请在布局上启用动画，以便当您更改 view 的可见性时，动画会自动应用。 基于物理的运动只要有可能，将现实世界的物理原理应用到你的动画中，使它们看起来很自然。 例如，当目标发生变化时，他们应该保持动力，并在任何变化期间实现平稳过渡。 为了提供这些行为，Android 支持库包含基于物理的动画 API，它们依靠物理定律来控制动画的发生方式。 两种常见的基于物理的动画如下： Spring animation. Fling animation. 不基于物理的动画（例如使用 ObjectAnimator API 构建的动画）是相当静态的，并且具有固定的持续时间。如果目标值发生变化，则必须取消目标值变化时的动画，使用新值作为新的起始值重新配置动画，并添加新的目标值。从视觉上看，这个过程会导致动画突然停止，然后出现脱节的运动。 使用基于物理的动画 API（例如 DynamicAnimation）构建的动画是由力驱动的。 目标值的变化导致力的变化。新的力作用于现有的速度，从而不断过渡到新的目标。 此过程会产生更加自然的动画。 为布局更改设置动画当在当前 Activity 或 Fragment 内交换布局时，可以使用 transition framework 来创建动画。所需要做的就是指定开始和结束布局以及要使用的动画类型。 然后系统计算出并在两个布局之间执行动画。 可以使用它来交换整个 UI 或仅移动或替换某些 view。 例如，当用户点击某个项目以查看更多信息时，您可以将布局替换为项目详细信息，并应用 transition。 开始和结束布局均存储在 Scene 中，但 starting scene 通常是根据当前布局自动确定的。创建一个 Transition 来告诉系统您想要什么类型的动画，然后调用 TransitionManager.go() ，系统运行动画来交换布局。 在 activity 之间设置动画还可以创建在 Activity 之间过渡的动画。 这基于上一节中描述的相同 transition framework，但它允许您在单独 activity 的布局之间创建动画。 您可以应用简单的动画，例如从侧面滑入新 activity 或使其淡入，但您也可以创建在每个 activity 的共享 view 之间转换的动画。例如，当用户点击某个项目以查看更多信息时，您可以 transition 到带有动画的新 Activity，该动画会无缝地扩展该项目以填满屏幕。 像往常一样，您调用 startActivity()，但向其传递由 ActivityOptions.makeSceneTransitionAnimation() 提供的一组选项。这组选项可能包括哪些 view 在 activity 之间共享，以便 transition framework 可以在动画期间连接它们。 关于 Property Animation属性动画系统是一个强大的框架，允许对几乎所有内容进行动画处理。 可以定义动画来随着时间的推移更改任何对象属性，无论它是否绘制到屏幕上。属性动画会在指定的时间长度内更改属性（对象中的字段）值。 要为某些内容设置动画，可以指定要设置动画的对象属性，例如对象在屏幕上的位置、要设置动画的时间以及要在哪些值之间设置动画。 属性动画系统允许您定义动画的以下特征： Duration: 可以指定动画的持续时间。 默认长度为 300 毫秒。 Time interpolation: 可以指定如何根据动画的当前运行时间来计算属性值。 Repeat count and behavior: 可以指定当动画到达持续时间结束时是否重复动画以及重复动画的次数。 您还可以指定是否希望动画反向播放。 将其设置为反向播放动画向前然后向后重复播放，直到达到重复次数。 Animator sets: 可以将动画分组为逻辑集，这些逻辑集一起播放、按顺序播放或在指定的延迟后播放。 Frame refresh delay: 可以指定刷新动画帧的频率。 默认设置为每 10 毫秒刷新一次，但应用程序刷新帧的速度最终取决于系统整体的繁忙程度以及系统为底层计时器提供服务的速度。 属性动画的工作原理首先，让我们通过一个简单的示例来了解动画的工作原理。 图 1 描绘了一个使用其 x 属性进行动画处理的假设对象，该属性表示其在屏幕上的水平位置。 动画的持续时间设置为 40 毫秒，行进距离为 40 像素。 每 10 毫秒（默认帧刷新率），对象水平移动 10 个像素。 在 40 毫秒结束时，动画停止，对象在水平位置 40 处结束。这是线性插值动画的示例，意味着对象以恒定速度移动。 您还可以指定动画进行非线性插值。 图 2 说明了一个假设的对象，该对象在动画开始时加速，在动画结束时减速。 对象仍会在 40 毫秒内移动 40 个像素，但是是非线性的。 一开始，该动画加速到中间点，然后从中间点减速，直到动画结束。 如图 2 所示，动画开始和结束时的行进距离小于中间的行进距离。 让我们详细看看属性动画系统的重要组件如何计算如上所示的动画。 图 3 描述了主要类如何相互协作。 ValueAnimator 对象跟踪动画的计时，例如动画运行了多长时间，以及它所动画的属性的当前值。 ValueAnimator 封装了 TimeInterpolator（定义动画插值）和 TypeEvaluator（定义如何计算动画属性的值）。 例如，在图 2 中，使用的 TimeInterpolator 为 AccelerateDecelerateInterpolator，TypeEvaluator 为 IntEvaluator。 要启动动画，请创建一个 ValueAnimator 并为其指定要设置动画的属性的起始值和结束值以及动画的持续时间。 当您调用 start() 时，动画开始。在整个动画过程中，ValueAnimator 根据动画的持续时间和已用时间来计算 0 到 1 之间的已用分数。 经过的分数表示动画完成的时间百分比，0 表示 0%，1 表示 100%。例如，在图 1 中，t &#x3D; 10 ms 时的消耗分数将为 0.25，因为总持续时间为 t &#x3D; 40 ms。 当 ValueAnimator 完成计算经过的分数时，它会调用当前设置的 TimeInterpolator 来计算插值分数。 插值分数将经过的分数映射到考虑了所设置的时间插值的新分数。例如，在图 2 中，由于动画缓慢加速，因此在 t &#x3D; 10 ms 时，插值分数（约 0.15）小于经过分数（0.25）。 在图 1 中，插值分数始终与经过分数相同。 计算插值分数时，ValueAnimator 会调用相应的 TypeEvaluator，根据插值分数、动画的起始值和结束值来计算要设置动画的属性的值。例如，在图 2 中，t &#x3D; 10 ms 时的插值分数为 0.15，因此此时的属性值为 0.15 × (40 - 0)，即 6。 属性动画与 view 动画有何不同view 动画系统仅提供对 View 对象进行动画处理的功能，因此如果您想要对非 View 对象进行动画处理，则必须实现自己的代码才能执行此操作。view 动画系统还受到以下事实的限制：它仅公开 View 对象的几个方面进行动画处理，例如 View 的缩放和旋转，但不公开背景颜色。 view 动画系统的另一个缺点是它只修改了绘制 view 的位置，而不是实际的 view 本身。例如，如果您对按钮进行动画处理以使其在屏幕上移动，则该按钮会正确绘制，但您可以单击该按钮的实际位置不会改变，因此您必须实现自己的逻辑来处理此问题。 使用属性动画系统，这些约束被完全消除，您可以为任何对象（view 和非 view）的任何属性设置动画，并且对象本身实际上被修改。属性动画系统在执行动画的方式上也更加稳健。 在较高级别上，您可以将 animator 分配给要设置动画的属性，例如颜色、位置或大小，并且可以定义动画的各个方面，例如多个 animator 的插值和同步。 然而，view 动画系统的设置时间较短，并且需要编写的代码也较少。 如果 view 动画完成了您需要做的一切，或者您现有的代码已经按照您想要的方式工作，则无需使用属性动画系统。 如果出现用例，针对不同情况使用两种动画系统也可能是有意义的。 API 概览可以在 android.animation 中找到大多数属性动画系统的 API。 由于 view 动画系统已经在 android.view.animation 中定义了许多插值器，因此您也可以在属性动画系统中使用这些插值器。 下表描述了属性动画系统的主要组件。 Animator 类提供了创建动画的基本结构。 您通常不直接使用此类，因为它只提供必须扩展才能完全支持动画值的最少功能。 以下子类扩展了 Animator： ValueAnimator: 属性动画的主要计时引擎，还计算要进行动画处理的属性的值。 它具有计算动画值的所有核心功能，并包含每个动画的计时详细信息、有关动画是否重复的信息、接收更新事件的侦听器以及设置要评估的自定义类型的能力。 动画属性有两个部分：计算动画值并在正在动画的对象和属性上设置这些值。 ValueAnimator 不执行第二部分，因此您必须侦听 ValueAnimator 计算的值的更新，并使用您自己的逻辑修改要设置动画的对象。 ObjectAnimator: ValueAnimator 的子类，允许您设置目标对象和对象属性以进行动画处理。 当该类计算动画的新值时，该类会相应地更新属性。 大多数时候您希望使用 ObjectAnimator，因为它使目标对象上的值的动画处理过程变得更加容易。 但是，有时您想直接使用 ValueAnimator，因为 ObjectAnimator 还有一些限制，例如要求目标对象上存在特定的访问器方法。 AnimatorSet: 提供一种将动画分组在一起的机制，以便它们彼此相关地运行。 您可以将动画设置为一起播放、顺序播放或在指定的延迟后播放。 Evaluator 告诉属性动画系统如何计算给定属性的值。 它们获取 Animator 类提供的计时数据、动画的开始值和结束值，并根据该数据计算属性的动画值。属性动画系统提供以下 Evaluator： IntEvaluator: 用于计算 int 属性值的默认 evaluator。 FloatEvaluator: 用于计算浮点属性值的默认 evaluator。 ArgbEvaluator: 用于计算以十六进制值表示的颜色属性值的默认 evaluator。 TypeEvaluator: 允许您创建自己的 evaluator 的 interface。 如果要对不是 int、float 或 color 的对象属性进行动画处理，则必须实现 TypeEvaluator 接口以指定如何计算对象属性的动画值。如果您希望以不同于默认行为的方式处理这些类型，您还可以为 int、float 和 color 值指定自定义 TypeEvaluator。 时间 interpolator 定义如何将动画中的特定值计算为时间的函数。 例如，您可以指定动画在整个动画中线性发生，这意味着动画在整个时间中均匀移动，或者您可以指定动画使用非线性时间，例如在开始时加速并在动画结束时减速。表 3 描述了 android.view.animation 中包含的 interpolator。如果提供的 interpolator 均不能满足您的需求，请实现 TimeInterpolator 接口并创建您自己的 interpolator。 AccelerateDecelerateInterpolator: 其变化率开始和结束缓慢，但在中间加速。 AccelerateInterpolator: 变化率开始缓慢然后加速的插值器。 AnticipateInterpolator: 其变化开始向后然后向前猛冲。 AnticipateOvershootInterpolator: 其变化开始向后，向前猛冲并超过目标值，然后最终返回到最终值。 BounceInterpolator: 其变化在最后反弹的插值器。 CycleInterpolator: 其动画重复指定周期数的插值器。 DecelerateInterpolator: 其变化率开始时很快，然后减速。 LinearInterpolator: 变化率恒定的插值器 OvershootInterpolator: 插值器的变化向前猛冲并超过最后一个值，然后返回。 TimeInterpolator: 允许您实现自己的插值器的接口。 为 drawable 图形设置动画在某些情况下，图像需要动画化。 如果您想要显示由多个图像组成的自定义加载动画，或者想要图标在用户操作后变形，这非常有用。 Android 提供了两种用于绘制 drawable 动画的选项。 第一个选项是使用 AnimationDrawable。 这使您可以指定多个静态 drawable 文件，一次显示一个文件以创建动画。 第二个选项是使用 AnimatedVectorDrawable，它允许您为 vector drawable 的属性设置动画。 使用 AnimationDrawable创建动画的一种方法是加载一系列 drawable 资源，例如一卷胶片。 AnimationDrawable 类是此类 drawable 动画的基础。 您可以使用 AnimationDrawable 类 API 在代码中定义动画的帧，但使用列出构成动画的帧的单个 XML 文件来定义它们会更容易。这种动画的 XML 文件位于 Android 项目的 res/drawable/ 目录中。 在本例中，指令给出了动画中每一帧的顺序和持续时间。 XML 文件由一个作为根节点的 &lt;animation-list&gt; 元素和一系列子 &lt;item&gt; 节点组成，每个子节点定义一个帧 - drawable 资源及其持续时间。 下面是一个 Drawable 动画的 XML 文件示例： 123456&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;true&quot;&gt; &lt;item android:drawable=&quot;@drawable/rocket_thrust1&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/rocket_thrust2&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/rocket_thrust3&quot; android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt; 该动画运行三帧。 将列表的 android:oneshot 属性设置为 true 使其循环一次，然后停止并保持在最后一帧。 如果将 android:oneshot 设置为 false，动画将循环播放。 如果将此 XML 保存为项目的 res/drawable/ 目录中的 rocket_thrust.xml，则可以将其作为 background 图像添加到 View，然后调用 start() 使其播放。下面是一个示例，其中将动画添加到 ImageView，然后在触摸屏幕时进行动画处理： 123456val rocketImage = findViewById&lt;ImageView&gt;(R.id.rocket_image).apply &#123; setBackgroundResource(R.drawable.rocket_thrust) rocketAnimation = background as AnimationDrawable &#125;rocketImage.setOnClickListener(&#123; rocketAnimation.start() &#125;) 需要注意的是，在 Activity 的 onCreate() 方法期间无法调用在 AnimationDrawable 上调用的 start() 方法，因为 AnimationDrawable 尚未完全附加到 window。 要立即播放动画而不需要交互，您可以从 Activity 中的 onStart() 方法调用它，当 Android 使 view 在屏幕上可见时调用该方法。 使用 AnimatedVectorDrawablevector drawable 是一种可缩放且不会像素化或模糊的可绘制对象类型。 AnimatedVectorDrawable 类以及用于向后兼容的 AnimatedVectorDrawableCompat 允许您对 vector drawable 的属性进行动画处理，例如旋转它或更改路径数据以将其变形为不同的图像。 您通常在三个 XML 文件中定义 animated vector drawable： A vector drawable with the &lt;vector&gt; element in res/drawable/. An animated vector drawable with the &lt;animated-vector&gt; element in res/drawable/. One or more object animators with the &lt;objectAnimator&gt; element in res/animator/. Animated vector drawables 可以为 &lt;group&gt; 和 &lt;path&gt; 元素的属性设置动画。 &lt;group&gt; 元素定义一组 path 或 subgroup，&lt;path&gt; 元素定义要绘制的路径。 当您定义要设置动画的 vector drawable 时，请使用 android:name 属性为 group 和 path 分配唯一的名称，以便您可以从 animator 定义中引用它们。 animated vector drawable 定义通过 name 引用 vector drawable 中的 group 和 path： 123456789&lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@drawable/vectordrawable&quot; &gt; &lt;target android:name=&quot;rotationGroup&quot; android:animation=&quot;@animator/rotation&quot; /&gt; &lt;target android:name=&quot;v&quot; android:animation=&quot;@animator/path_morph&quot; /&gt;&lt;/animated-vector&gt; 动画定义表示 ObjectAnimator 或 AnimatorSet 对象。 此示例中的第一个 animator 将目标组旋转 360 度： 12345&lt;objectAnimator android:duration=&quot;6000&quot; android:propertyName=&quot;rotation&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;360&quot; /&gt; 此示例中的第二个 animator 将 vector drawable 的 path 从一种形状变形为另一种形状。 这些 path 必须兼容变形：它们必须具有相同数量的命令以及每个命令相同数量的参数。 为 view 设置动画View Animation可以使用 view 动画系统在 view 上执行 Tween 动画。 Tween(补间)动画使用诸如起点、终点、大小、旋转和动画的其他常见方面等信息来计算动画。 Tween 动画可以对 View 对象的内容执行一系列简单的转换（位置、大小、旋转和透明度）。 因此，如果您有 TextView 对象，则可以移动、旋转、放大或缩小文本。如果它有背景图像，则背景图像将随文本一起变换。 animation package 提供了 tween 动画中使用的所有类。 动画指令序列定义 tween 动画，由 XML 或 Android 代码定义。 与定义布局一样，建议使用 XML 文件，因为它比硬编码动画更具可读性、可重用性和可交换性。在下面的示例中，我们使用 XML。 动画指令定义您想要发生的转换、何时发生以及应用它们需要多长时间。 转换可以是顺序的或同时的 - 例如，您可以让 TextView 的内容从左向右移动，然后旋转 180 度，或者您可以让文本同时移动和旋转。 每个变换都采用一组特定于该变换的参数（尺寸更改的起始尺寸和结束尺寸、旋转的起始角度和结束角度等），以及一组通用参数（例如，开始时间和持续时间） 。要使多个转换同时发生，请给它们相同的开始时间； 要使它们连续，请计算开始时间加上前面转换的持续时间。 动画 XML 文件位于 Android 项目的 res&#x2F;anim&#x2F; 目录中。 文件必须有一个根元素：这将是单个 、、、、插值器元素或保存这些元素组的 元素（可能包括另一个元素） &lt;设置&gt;）。默认情况下，所有动画指令同时应用。 要使它们按顺序发生，您必须指定 startOffset 属性，如下例所示。 使用动画显示或隐藏 view显示或隐藏 view 时可以使用三种常见的动画。 您可以使用圆形显示动画、交叉淡入淡出动画或卡片翻转动画。 创建 crossfade animationCrossfade(交叉淡入淡出)动画（也称为溶解）逐渐淡出一个 View 或 ViewGroup，同时淡入另一个 View 或 ViewGroup。 此动画对于您想要在应用程序中切换内容或 view 的情况非常有用。此处显示的 crossfade 动画使用 ViewPropertyAnimator。 创建 view首先，您需要创建要 crossfade 的两个 view。 以下示例创建一个 progress indicator 和一个可滚动 text view： 设置 crossfade 动画要设置 crossfade 动画： 为要 crossfade 的 view 创建成员变量。 稍后在动画期间修改 view 时需要这些引用。 对于正在淡入的视图，将其可见性设置为 GONE。 这可以防止 view 占用布局空间并在布局计算中忽略它，从而加快处理速度。 将 config_shortAnimTime 系统属性缓存在成员变量中。 此属性定义动画的标准 “短” 持续时间。 此持续时间对于微妙的动画或频繁出现的动画来说是理想的选择。如果您想使用 config_longAnimTime 和 config_mediumAnimTime 也可以使用。 Crossfade the views现在 view 已正确设置，通过执行以下操作来 crossfade 它们： 对于淡入的 view，将 alpha 值设置为 0，将可见性设置为 VISIBLE。 （请记住，它最初设置为 GONE。）这使得 view 可见但完全透明。 对于淡入的 view，将其 alpha 值从 0 动画化到 1。对于淡出的 view，将 alpha 值从 1 动画化到 0。 在 Animator.AnimatorListener 中使用 onAnimationEnd()，将淡出的 view 的可见性设置为 GONE。 尽管 alpha 值为 0，但将 view 的可见性设置为 GONE 可以防止 view 占用布局空间并在布局计算中忽略它，从而加快处理速度。 1234567891011121314151617181920212223242526private fun crossfade() &#123; contentView.apply &#123; // Set the content view to 0% opacity but visible, so that it is visible // (but fully transparent) during the animation. alpha = 0f visibility = View.VISIBLE // Animate the content view to 100% opacity, and clear any animation // listener set on the view. animate() .alpha(1f) .setDuration(shortAnimationDuration.toLong()) .setListener(null) &#125; // Animate the loading view to 0% opacity. After the animation ends, // set its visibility to GONE as an optimization step (it won&#x27;t // participate in layout passes, etc.) loadingView.animate() .alpha(0f) .setDuration(shortAnimationDuration.toLong()) .setListener(object : AnimatorListenerAdapter() &#123; override fun onAnimationEnd(animation: Animator) &#123; loadingView.visibility = View.GONE &#125; &#125;)&#125; 创建卡片翻转动画卡片通过显示模拟卡片翻转的动画，在内容 view 之间翻转动画。 此处显示的卡片翻转动画使用 FragmentTransaction。 创建 Animator object为了创建卡片翻转动画，总共需要四个 animator。 两个 animator，用于卡正面向左向外和从左侧向内动画。 还需要两个 animator来处理卡片背面从右侧进出以及从右侧进出的动画。 card_flip_left_in.xml 123456789101112131415161718192021222324&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- Before rotating, immediately set the alpha to 0. --&gt; &lt;objectAnimator android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;0.0&quot; android:propertyName=&quot;alpha&quot; android:duration=&quot;0&quot; /&gt; &lt;!-- Rotate. --&gt; &lt;objectAnimator android:valueFrom=&quot;-180&quot; android:valueTo=&quot;0&quot; android:propertyName=&quot;rotationY&quot; android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; android:duration=&quot;@integer/card_flip_time_full&quot; /&gt; &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 1. --&gt; &lt;objectAnimator android:valueFrom=&quot;0.0&quot; android:valueTo=&quot;1.0&quot; android:propertyName=&quot;alpha&quot; android:startOffset=&quot;@integer/card_flip_time_half&quot; android:duration=&quot;1&quot; /&gt;&lt;/set&gt; card_flip_left_out.xml 1234567891011121314151617&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- Rotate. --&gt; &lt;objectAnimator android:valueFrom=&quot;0&quot; android:valueTo=&quot;180&quot; android:propertyName=&quot;rotationY&quot; android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; android:duration=&quot;@integer/card_flip_time_full&quot; /&gt; &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 0. --&gt; &lt;objectAnimator android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;0.0&quot; android:propertyName=&quot;alpha&quot; android:startOffset=&quot;@integer/card_flip_time_half&quot; android:duration=&quot;1&quot; /&gt;&lt;/set&gt; card_flip_right_in.xml 123456789101112131415161718192021222324&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- Before rotating, immediately set the alpha to 0. --&gt; &lt;objectAnimator android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;0.0&quot; android:propertyName=&quot;alpha&quot; android:duration=&quot;0&quot; /&gt; &lt;!-- Rotate. --&gt; &lt;objectAnimator android:valueFrom=&quot;180&quot; android:valueTo=&quot;0&quot; android:propertyName=&quot;rotationY&quot; android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; android:duration=&quot;@integer/card_flip_time_full&quot; /&gt; &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 1. --&gt; &lt;objectAnimator android:valueFrom=&quot;0.0&quot; android:valueTo=&quot;1.0&quot; android:propertyName=&quot;alpha&quot; android:startOffset=&quot;@integer/card_flip_time_half&quot; android:duration=&quot;1&quot; /&gt;&lt;/set&gt; card_flip_right_out.xml 1234567891011121314151617&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- Rotate. --&gt; &lt;objectAnimator android:valueFrom=&quot;0&quot; android:valueTo=&quot;-180&quot; android:propertyName=&quot;rotationY&quot; android:interpolator=&quot;@android:interpolator/accelerate_decelerate&quot; android:duration=&quot;@integer/card_flip_time_full&quot; /&gt; &lt;!-- Half-way through the rotation (see startOffset), set the alpha to 0. --&gt; &lt;objectAnimator android:valueFrom=&quot;1.0&quot; android:valueTo=&quot;0.0&quot; android:propertyName=&quot;alpha&quot; android:startOffset=&quot;@integer/card_flip_time_half&quot; android:duration=&quot;1&quot; /&gt;&lt;/set&gt; 创建 view“卡片”的每一面都是一个单独的布局，可以包含您想要的任何内容，例如两个 text view、两个图像或要在之间翻转的 view 的任意组合。然后，将在稍后设置动画的 fragment 中使用这两种布局。 以下布局创建显示文本的卡片的一侧： 创建 fragment为卡片的正面和背面创建 fragment 类。 这些类返回您之前在每个 fragment 的 onCreateView() 方法中创建的布局。然后，您可以在要显示卡片的父 activity 中创建此 fragment 的实例。 以下示例显示了使用它们的父 activity 内部的嵌套 fragment 类： 设置卡片翻转动画现在，需要在父 activity 内显示 fragment。 为此，首先为 activity 创建布局。 以下示例创建一个 FrameLayout，可以在运行时向其中添加 fragment： 在 activity 代码中，将 content view 设置为刚刚创建的布局。 创建 activity 时显示默认 fragment 也是一个好主意 现在已经显示了卡片的正面，可以在适当的时候通过翻转动画显示卡片的背面。 创建一个方法来显示卡片的另一面，该方法执行以下操作： 设置之前为 fragment 过渡创建的自定义动画。 将当前显示的 fragment 替换为新 fragment，并使用创建的自定义动画为该事件设置动画。 将先前显示的 fragment添加到 fragment 后堆栈中，以便当用户按下“后退”按钮时，卡片会翻转回来。 123456789101112131415161718192021222324252627282930313233343536373839private fun flipCard() &#123; if (showingBack) &#123; supportFragmentManager.popBackStack() return &#125; // Flip to the back. showingBack = true // Create and commit a new fragment transaction that adds the fragment for // the back of the card, uses custom animations, and is part of the fragment // manager&#x27;s back stack. supportFragmentManager.beginTransaction() // Replace the default fragment animations with animator resources // representing rotations when switching to the back of the card, as // well as animator resources representing rotations when flipping // back to the front (e.g. when the system Back button is pressed). .setCustomAnimations( R.animator.card_flip_right_in, R.animator.card_flip_right_out, R.animator.card_flip_left_in, R.animator.card_flip_left_out ) // Replace any fragments currently in the container view with a // fragment representing the next page (indicated by the // just-incremented currentPage variable). .replace(R.id.container, CardBackFragment()) // Add this transaction to the back stack, allowing users to press // Back to get to the front of the card. .addToBackStack(null) // Commit the transaction. .commit()&#125; 使用动画移动 view使用 fling 动画移动 view基于 Fling 的动画使用与对象速度成正比的摩擦力。 使用它来为对象的属性设置动画并逐渐结束动画。 它有一个初始动量，主要来自手势速度，然后逐渐减慢。 当动画的速度足够低以至于在设备屏幕上没有发生明显变化时，动画就会结束。 Add the AndroidX library123dependencies &#123; implementation &#x27;androidx.dynamicanimation:dynamicanimation:1.0.0&#x27;&#125; Create a fling animationFlingAnimation 类允许为对象创建 fling 动画。 要构建 fling 动画，创建 FlingAnimation 类的实例并提供要设置动画的对象和对象的属性。 1val fling = FlingAnimation(view, DynamicAnimation.SCROLL_X) Set velocity(速度)起始速度定义动画属性在动画开始时发生变化的速度。 默认起始速度设置为每秒零像素。 因此，必须定义一个开始速度以确保动画不会立即结束。 可以使用固定值作为起始速度，也可以将其基于触摸手势的速度。 如果您选择提供固定值，则应以每秒 dp 为单位定义该值，然后将其转换为每秒像素数。 定义每秒 dp 的值可以使速度独立于设备的密度和外形尺寸。 要设置速度，请调用 setStartVelocity() 方法并传递以每秒像素为单位的速度。 该方法返回设置了速度的 fling 对象。 1注意：使用 GestureDetector.OnGestureListener 和 VelocityTracker 类分别检索和计算触摸手势的速度。 Set an animation value range当想将属性值限制在一定范围内时，可以设置最小和最大动画值。 当您为具有固有范围（例如 alpha（从 0 到 1））的属性设置动画时，此范围控件特别有用。 1注意：当fling动画的值达到最小值或最大值时，动画结束。 要设置最小值和最大值，分别调用 setMinValue() 和 setMaxValue() 方法。 两种方法都会返回已设置值的动画对象。 Set friction(摩擦力)setFriction() 方法可让更改动画的摩擦力。 它定义了动画中速度降低的速度。 1注意：如果在动画开始时未设置摩擦力，则动画将使用默认摩擦力值 1。 Set the minimum visible change当对未以像素为单位定义的自定义属性进行动画处理时，应该设置用户可见的动画值的最小变化。 它确定结束动画的合理阈值。 对 DynamicAnimation.ViewProperty 进行动画处理时无需调用此方法，因为最小的可见更改是从属性派生的。 例如： 对于 TRANSLATION_X、TRANSLATION_Y、TRANSLATION_Z、SCROLL_X 和 SCROLL_Y 等视图属性，默认的最小可见更改值为 1 像素。 对于使用旋转的动画（例如 ROTATION、ROTATION_X 和 ROTATION_Y），最小可见变化为 MIN_VISIBLE_CHANGE_ROTATION_DEGREES 或 1&#x2F;10 像素。 对于使用不透明度的动画，最小可见变化为 MIN_VISIBLE_CHANGE_ALPHA 或 1&#x2F;256。 要设置动画的最小可见更改，调用 setMinimumVisibleChange() 方法并传递最小可见常量之一或需要为自定义属性计算的值。 计算 minimum visible change value要计算自定义属性的最小可见变化值，请使用以下公式： 最小可见变化 &#x3D; 自定义属性值范围 &#x2F; 动画范围（以像素为单位） 例如，您想要设置动画的属性从 0 进展到 100。这对应于 200 像素的变化。 根据公式，最小可见变化值为 100 &#x2F; 200 等于 0.5 像素。 使用缩放动画放大 view本指南演示了如何实现点击缩放动画。 点击缩放功能可让照片库等应用程序以缩略图的形式呈现 view 动画以填充屏幕。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"SQLite","slug":"SQLite","date":"2023-04-01T04:32:50.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2023/04/01/SQLite/","link":"","permalink":"https://azxkenzo.github.io/2023/04/01/SQLite/","excerpt":"","text":"什么是 SQLite？SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库不一样，您不需要在系统中配置。 就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。 SQLite 语法大小写敏感性SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。 SQLite Insert 语句INSERT INTO 语句用于向数据库的某个表中添加新的数据行。 INSERT INTO 语句有两种基本语法，如下所示： 12INSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)] VALUES (value1, value2, value3,...valueN); 在这里，column1, column2,…columnN 是要插入数据的表中的列的名称。 如果要为表中的所有列添加值，您也可以不需要在 SQLite 查询中指定列名称。但要确保值的顺序与列在表中的顺序一致。SQLite 的 INSERT INTO 语法如下： 1INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);","categories":[],"tags":[]},{"title":"Android - MediaStore","slug":"Android-MediaStore","date":"2023-03-28T09:33:10.000Z","updated":"2023-07-14T04:40:17.261Z","comments":true,"path":"2023/03/28/Android-MediaStore/","link":"","permalink":"https://azxkenzo.github.io/2023/03/28/Android-MediaStore/","excerpt":"","text":"系统自动扫描外部存储卷并将媒体文件添加到以下定义明确的集合中： Images，包括照片和屏幕截图，它们存储在 DCIM/ 和 Pictures/ 目录中。 系统将这些文件添加到 MediaStore.Images 表中。 Videos，它们存储在 DCIM/、Movies/ 和 Pictures/ 目录中。 系统将这些文件添加到 MediaStore.Video 表中。 Audio files，它们存储在 Alarms/、Audiobooks/、Music/、Notifications/、Podcasts/ 和 Ringtones/ 目录中。 此外，系统可以识别 Music/ 或 Movies/ 目录中的音频播放列表，以及 Recordings/ 目录中的录音。 系统将这些文件添加到 MediaStore.Audio 表中。 recordings 目录在 Android 11（API 级别 30）及更低版本上不可用。 Downloaded files，它们存储在 Download/ 目录中。 在运行 Android 10（API 级别 29）及更高版本的设备上，这些文件存储在 MediaStore.Downloads 表中。 此表不适用于 Android 9（API 级别 28）及更低版本。 media store 还包括一个名为 MediaStore.Files 的集合。 其内容取决于应用是否使用分区存储，适用于面向 Android 10 或更高版本的应用： 如果启用分区存储，则集合仅显示您的应用创建的照片、视频和音频文件。 大多数开发人员不需要使用 MediaStore.Files 查看来自其他应用程序的媒体文件，但如果您有特定要求，您可以声明 READ_EXTERNAL_STORAGE 权限。 但是，建议您使用 MediaStore API 打开您的应用程序尚未创建的文件。 如果分区存储不可用或未被使用，则该集合会显示所有类型的媒体文件。 请求必要权限如果只访问自己的媒体文件，则不需要任何权限在运行 Android 10 或更高版本的设备上，不需要任何与存储相关的权限来访问和修改您的应用拥有的媒体文件，包括 MediaStore.Downloads 集合中的文件。 例如，如果您正在开发相机应用程序，则无需请求与存储相关的权限，因为您的应用程序拥有您正在写入媒体存储的图像。 访问其他应用程序的媒体文件要访问其他应用创建的媒体文件，必须声明适当的存储相关权限，并且这些文件必须位于以下媒体集合之一中： MediaStore.Images MediaStore.Video MediaStore.Audio 只要文件可从 MediaStore.Images、MediaStore.Video 或 MediaStore.Audio 查询查看，它也可以使用 MediaStore.Files 查询查看。 以下代码片段演示了如何声明适当的存储权限： 12345678910111213141516&lt;!-- Required only if your app needs to access images or photos that other apps created. --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_IMAGES&quot; /&gt;&lt;!-- Required only if your app needs to access videos that other apps created. --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_VIDEO&quot; /&gt;&lt;!-- Required only if your app needs to access audio files that other apps created. --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_AUDIO&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; android:maxSdkVersion=&quot;29&quot; /&gt; 如果同时请求 READ_MEDIA_IMAGES 权限和 READ_MEDIA_VIDEO 权限，系统会显示一个包含这两个权限的运行时权限对话框。 检查 media store 的更新要更可靠地访问媒体文件，特别是如果您的应用缓存 URI 或来自 media store 的数据，请检查 media store 版本与上次同步媒体数据时相比是否发生了变化。 要执行此更新检查，请调用 MediaStore.getVersion()。 返回的版本是一个唯一的字符串，只要媒体存储发生重大变化，它就会发生变化。 如果返回的版本与上次同步的版本不同，请重新扫描并重新同步您应用的媒体缓存。 在应用进程启动时完成此检查。 每次查询 media store 时都无需检查版本。 注意：media store 版本号不会因应用端更改而改变，例如当应用添加媒体文件时。 有一种单独的方法可以帮助您检测媒体文件的更新。 检测媒体文件的更新与之前的时间点相比，应用可能需要识别包含应用添加或修改的媒体文件的 storage volume。 要最可靠地检测这些更改，请将感兴趣的 storage volume 传递给 MediaStore.getGeneration()。 只要 media store 版本不变，此方法的返回值就会随时间单调增加。 特别是，getGeneration() 比媒体列中的日期更可靠，例如 DATE_ADDED 和 DATE_MODIFIED。 这是因为当应用程序调用 setLastModified() 或用户更改系统时钟时，这些媒体列值可能会更改。 123456789101112131415161718191:1402:aec29684-646c-4b9c-9c77-750ea496e1171402:aec29684-646c-4b9c-9c77-750ea496e11729407962:1402:aec29684-646c-4b9c-9c77-750ea496e1171402:aec29684-646c-4b9c-9c77-750ea496e1172940796拍照后：1402:aec29684-646c-4b9c-9c77-750ea496e1171402:aec29684-646c-4b9c-9c77-750ea496e1172940805删除后：1402:aec29684-646c-4b9c-9c77-750ea496e1171402:aec29684-646c-4b9c-9c77-750ea496e1172940813 访问媒体内容时的注意事项Cached data如果您的应用缓存 media store 的 URI 或数据，请定期检查 media store 的更新。 此检查允许您的应用程序端缓存数据与系统端提供程序数据保持同步。 Performance当您使用直接文件路径执行媒体文件的顺序读取时，性能可与 MediaStore API 相媲美。 但是，当您使用直接文件路径对媒体文件执行随机读取和写入时，该过程可能会慢两倍。 在这些情况下，我们建议改用 MediaStore API。 DATA column当您访问现有媒体文件时，您可以在逻辑中使用 DATA 列的值。 那是因为这个值有一个有效的文件路径。 但是，不要假设该文件始终可用。 准备好处理可能发生的任何基于文件的 I&#x2F;O 错误。 另一方面，要创建或更新媒体文件，请不要使用 DATA 列的值。 相反，使用 DISPLAY_NAME 和 RELATIVE_PATH 列的值。 Storage volumes以 Android 10 或更高版本为目标的应用程序可以访问系统分配给每个外部存储卷的唯一名称。 此命名系统可帮助您有效地组织和索引内容，并让您控制新媒体文件的存储位置。 记住以下几卷特别有用： VOLUME_EXTERNAL 卷提供设备上所有共享存储卷的视图。 您可以阅读此合成卷的内容，但不能修改其中的内容。 VOLUME_EXTERNAL_PRIMARY 卷表示设备上的主要共享存储卷。 您可以阅读和修改本卷的内容。 可以通过调用 MediaStore.getExternalVolumeNames() 发现其他卷","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - View绘制流程","slug":"Android-View绘制流程","date":"2023-03-01T08:50:31.000Z","updated":"2023-07-18T04:22:50.358Z","comments":true,"path":"2023/03/01/Android-View绘制流程/","link":"","permalink":"https://azxkenzo.github.io/2023/03/01/Android-View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/","excerpt":"","text":"Activity 与 Window 和 DecorView 等之间等关系： Activity：每个 Activity 都持有一个 Window 对象 Window：顶层 Window 外观和行为策略的抽象基类。 此类的实例应该用作添加到 window manager 的顶层view。 它提供标准的 UI 策略，例如背景、标题区域、默认键处理等。 PhoneWindow：Window 类的指定实现。PhoneWindow 持有 DecorView 对象。 DecorView：继承自 FrameLayout，是 Window 的 顶层View。DecorView 初始化时会根据主题、配置等的不同来选择子布局 WindowManager：用来与 window manager 对话的接口。每个 window manager 实例都绑定到一个 Display。存在两种类型的 WindowManager：一个是系统级别的 WindowManager；另一个是与 Window 实例相关联的 WindowManager ViewRootImpl：View层次结构的顶部，实现 view 和 WindowManager 之间所需的协议。 这大部分是 WindowManagerGlobal 的内部实现细节。 AppCompatActivitysetContentView()1234public void setContentView(View view) &#123; initViewTreeOwners(); getDelegate().setContentView(view);&#125; 调用 AppCompatDelegateImpl.setContentView()。 AppCompatDelegateImpl1234567public void setContentView(View v) &#123; ensureSubDecor(); ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); contentParent.addView(v); mAppCompatWindowCallback.getWrapped().onContentChanged();&#125; 调用 ensureSubDecor() 确保 SubDecor 已创建。在此过程中会调用 Window.getDecorView() 来确保 Window 的 DecorView 已创建, 然后把 SubDecor 添加到 DecorView 中 从 SubDecor 获取 contentParent，清空 contentParent 的子View，然后把指定的 view 添加到 contentParent 中。 1234567// class PhoneWindowpublic final @NonNull View getDecorView() &#123; if (mDecor == null || mForceDecorInstall) &#123; installDecor(); &#125; return mDecor;&#125; ActivityThreadActivityThread 管理应用程序进程中主线程的执行，根据 activity manager 的请求调度和执行 activity、广播和其他操作。 main()程序的入口点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); // Install selective syscall interception AndroidOs.install(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); // Call per-process mainline module initialization. initializeMainlineModules(); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format &quot;seq=114&quot; long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; Looper.prepareMainLooper() thread.attach() sMainThreadHandler &#x3D; thread.getHandler() Looper.loop() handleResumeActivity()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public void handleResumeActivity(ActivityClientRecord r, boolean finalStateRequest, boolean isForward, String reason) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration // skip below steps for double-resume and r.mFinish = true case. if (!performResumeActivity(r, finalStateRequest, reason)) &#123; return; &#125; if (mActivitiesToBeDestroyed.containsKey(r.token)) &#123; // Although the activity is resumed, it is going to be destroyed. So the following // UI operations are unnecessary and also prevents exception because its token may // be gone that window manager cannot recognize it. All necessary cleanup actions // performed below will be done while handling destruction. return; &#125; final Activity a = r.activity; if (localLOGV) &#123; Slog.v(TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; + a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow + &quot;, finished: &quot; + a.mFinished); &#125; final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn&#x27;t yet been added to the window manager, // and this guy didn&#x27;t finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; willBeVisible = ActivityClient.getInstance().willActivityBeVisible( a.getActivityToken()); &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; else &#123; // The activity will get a callback for this &#123;@link LayoutParams&#125; change // earlier. However, at that time the decor will not be set (this is set // in this method), so no action will be taken. This call ensures the // callback occurs with the decor set. a.onWindowAttributesChanged(l); &#125; &#125; // If the window has already been added, but during resume // we started another activity, then don&#x27;t yet make the // window visible. &#125; else if (!willBeVisible) &#123; if (localLOGV) Slog.v(TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; &#125; // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r, false /* force */); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); ViewRootImpl impl = r.window.getDecorView().getViewRootImpl(); WindowManager.LayoutParams l = impl != null ? impl.mWindowAttributes : r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) &#123; l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) &#123; ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); &#125; &#125; r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v(TAG, &quot;Scheduling idle handler for &quot; + r); Looper.myQueue().addIdleHandler(new Idler());&#125; performResumeActivity()，进而调用 Activity.performResume() Activity.getWindow()，Activity 的 Window 在其 attach() 方法中初始化，是一个 PhoneWindow 对象。 decor.setVisibility(View.INVISIBLE)； a.mDecor &#x3D; decor a.getWindowManager()； wm.addView(decor, l)。 Activity 的 WindowManager 从 Window.getWindowManager() 获取，Window 的 WindowManager 从 Context.getSystemService(Context.WINDOW_SERVICE) (实例是 WindowManagerImpl) 的 createLocalWindowManager() 获取 在调起了输入法的情况下，调用 WindowManager.updateViewLayout(decor, l) 来更新 DecorView 的布局 调用 Activity.makeVisible() 来确保 DecorView 被添加到 WindowManager 中，并将 DecorView 设置为 VISIBLE WindowManagerWindowManager 的实现类是 WindowManagerImpl。 addView()WindowManagerImpl 把 addView() 委托给 WindowManagerGlobal 去执行。 12345public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyTokens(params); mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow, mContext.getUserId());&#125; WindowManagerGlobalWindowManagerGlobal 是一个单例对象。 addView()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow, int userId) &#123; if (view == null) &#123; throw new IllegalArgumentException(&quot;view must not be null&quot;); &#125; if (display == null) &#123; throw new IllegalArgumentException(&quot;display must not be null&quot;); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; // If there&#x27;s no parent, then hardware acceleration for this view is // set from the application&#x27;s hardware acceleration setting. final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; // Start watching for system property changes. if (mSystemPropertyUpdater == null) &#123; mSystemPropertyUpdater = new Runnable() &#123; @Override public void run() &#123; synchronized (mLock) &#123; for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123; mRoots.get(i).loadSystemProperties(); &#125; &#125; &#125; &#125;; SystemProperties.addChangeCallback(mSystemPropertyUpdater); &#125; int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don&#x27;t wait for MSG_DIE to make it&#x27;s way through root&#x27;s queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); &#125; // The previous removeView() had not completed executing. Now it has. &#125; // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; final int count = mViews.size(); for (int i = 0; i &lt; count; i++) &#123; if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123; panelParentView = mViews.get(i); &#125; &#125; &#125; IWindowSession windowlessSession = null; // If there is a parent set, but we can&#x27;t find it, it may be coming // from a SurfaceControlViewHost hierarchy. if (wparams.token != null &amp;&amp; panelParentView == null) &#123; for (int i = 0; i &lt; mWindowlessRoots.size(); i++) &#123; ViewRootImpl maybeParent = mWindowlessRoots.get(i); if (maybeParent.getWindowToken() == wparams.token) &#123; windowlessSession = maybeParent.getWindowSession(); break; &#125; &#125; &#125; if (windowlessSession == null) &#123; root = new ViewRootImpl(view.getContext(), display); &#125; else &#123; root = new ViewRootImpl(view.getContext(), display, windowlessSession); &#125; view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView, userId); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125;&#125; 创建 ViewRootImpl view.setLayoutParams(wparams), DecorView 设置 WindowManager.LayoutParams DecorView 添加到 mViews 中 ViewRootImpl 添加到 mRoots 中 ViewRootImpl.setView(view, wparams, panelParentView, userId) ViewRootImplsetView() 保存 DecorView: mView &#x3D; view mAttachInfo.mRootView &#x3D; view 调用 requestLayout()，在添加到 window manager 之前安排第一个 layout，以确保在从系统接收任何其他事件之前进行重新布局。 view.assignParent(this), 设置 DecorView 的 mParent 为 ViewRootImpl requestLayout()1234567public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; 12345678910void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; 向 Looper 的 Queue 中提交 SyncBarrier mChoreographer 提交执行 mTraversalRunnable 的 Message SyncBarrier1234567891011121314151617181920212223242526272829// class MessageQueueprivate int postSyncBarrier(long when) &#123; // Enqueue a new sync barrier token. // We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125;&#125; 将新的同步屏障令牌放入队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// class MessageQueueMessage next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; ...... &#125;&#125; 遇到同步屏障后，查找队列中的下一条异步消息(!msg.isAsynchronous())。 Choreographer1234567891011121314151617181920212223private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, &quot;PostCallback: type=&quot; + callbackType + &quot;, action=&quot; + action + &quot;, token=&quot; + token + &quot;, delayMillis=&quot; + delayMillis); &#125; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; 提交异步 Message (setAsynchronous(true)) performTraversals()mTraversalRunnable 会调用 doTraversal()，doTraversal() 调用 performTraversals() 调用 performMeasure()，执行 DecorView 的 Measure 流程 调用 performLayout()，执行 DecorView 的 Layout 流程 调用 performDraw()，执行 DecorView 的 Draw 流程 DecorView 的 Measure 流程ViewRootImpl.performTraversals() 中， 定义期望的 Window 的宽、高变量 desiredWindowWidth、desiredWindowHeight 根据规则计算出 desiredWindowWidth、desiredWindowHeight 的值 调用 measureHierarchy()，使用 desiredWindowWidth、desiredWindowHeight 计算 DecorView 的想要的大小 在 measureHierarchy() 中， 调用 getRootMeasureSpec()， 计算出 Window 中 root view 的 measure spec。这一步会将 Dialog 和 其他情况分开处理。看下 getRootMeasureSpec是怎么做的： 1234567891011121314151617181920private static int getRootMeasureSpec(int windowSize, int measurement, int privateFlags) &#123; int measureSpec; final int rootDimension = (privateFlags &amp; PRIVATE_FLAG_LAYOUT_SIZE_EXTENDED_BY_CUTOUT) != 0 ? MATCH_PARENT : measurement; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&#x27;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec;&#125; 调用 performMeasure()，使用刚计算好的宽高限定计算 DecorView 的宽高 performMeasure() 会调用 DecorView 的 measure()，看下 measure() 里面是怎么做的： 判断是否是强制布局。当 mPrivateFlags 中包含 PFLAG_FORCE_LAYOUT 标志时则是强制布局。如调用 View.requestLayout() 时会在 mPrivateFlags 中加入此标记 判断是否需要布局 如果是强制布局或需要布局，就调用 onMeasure() 来测量子View 或直接使用缓存中保存的值 检查是否调用 setMeasuredDimension() 来保存测量好的值，若没有则抛出异常 在 mPrivateFlags 中添加 PFLAG_LAYOUT_REQUIRED 标志，表示可以进行测量 看下 DecorView.onMeasure() 做了什么： 如果宽模式为 AT_MOST，就对 widthMeasureSpec 做一下调整 如果高模式为 AT_MOST，就对 heightMeasureSpec 做一下调整 调用父类即 FrameLayout 的 onMeasure() 对 子View 进行测量 看下 FrameLayout 的 onMeasure() 做了什么： 遍历子View，调用 measureChildWithMargins() 测量子View的大小。然后根据子view测量完的大小和子view的margin值来确定自身的maxWidth和maxHeight。此时如果 FrameLayout 的宽高模式中只要有一个不是 EXACTLY 的话，就把布局参数的宽或高为 MATCH_PARENT 的 子view 保存到 mMatchParentChildren 中 使用自身的padding更新maxWidth和maxHeight；使用最小宽高更新 maxWidth 和 maxHeight；使用Foreground的最小宽高更新maxWidth和maxHeight 调用 setMeasuredDimension() 保存使用 resolveSizeAndState() 计算出来的宽高 遍历 mMatchParentChildren 中保存的子view，对其进行重新测量 measureChildWithMargins()是怎么做的： 1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 调用 getChildMeasureSpec() 计算出 子View 的 MeasureSpec，然后调用 measure() 来测量子view。getChildMeasureSpec() 是如何计算子view的 MeasureSpec 的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&#x27;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&#x27;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let them have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 子view 的 mode 和 size 由 父view 的 mode 和 子view LayoutParams 的 width&#x2F;height 共同决定： 子view 尺寸为 具体数值 时，mode 均为 MeasureSpec.EXACTLY，size 为 子view LayoutParams中设定的值 子view 尺寸为 MATCH_PARENT 时，mode 取 父view mode，size 为 父view size 减去相应 padding 子view 尺寸为 WRAP_CONTENT 时，在父view mode为EXACTLY&#x2F;AT_MOST时取AT_MOST，父view mode为UNSPECIFIED时取UNSPECIFIED；size 为 父view size 减去相应 padding 在测量完所有子View并计算出最大宽高后，就会调用 resolveSizeAndState() 计算出自身的大小，看下是怎么做的： 123456789101112131415161718192021public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) &#123; final int specMode = MeasureSpec.getMode(measureSpec); final int specSize = MeasureSpec.getSize(measureSpec); final int result; switch (specMode) &#123; case MeasureSpec.AT_MOST: if (specSize &lt; size) &#123; result = specSize | MEASURED_STATE_TOO_SMALL; &#125; else &#123; result = size; &#125; break; case MeasureSpec.EXACTLY: result = specSize; break; case MeasureSpec.UNSPECIFIED: default: result = size; &#125; return result | (childMeasuredState &amp; MEASURED_STATE_MASK);&#125; DecorView 的 Layout 流程在 Measure 流程执行完后，会调用 performLayout() 开始 layout 流程。performLayout() 里面做了什么： 调用 DecorView 的 layout(0, 0, measuredWidth, measuredHeight) 对 DecorView 进行布局 如果在 DecorView 布局过程中有收到布局请求，则在DecorView 布局执行完后，筛选出有效的布局请求并执行，然后再对DecorView进行重新测量和布局 调用 DecorView 的 layout() 对其进行布局，看下里面是怎么做的： 调用 setFrame() 保存 view 的大小和位置 如果大小改变或需要布局，就调用 onLayout() 进行布局 setFrame() 做了什么： 判断 view 的位置是否改变 若 view 的位置改变则再判断 view 的大小是否改变，并调用 invalidate() 使旧位置无效，然后保存新的位置。 若 view 的大小是否改变，就调用 sizeChange() 进行通知。sizeChange() 中会调用 onSizeChanged() 回调 DecorView 在确定好自身位置之后，就会调用 onLayout() 来确定子view的位置。FrameLayout 中 onLayout() 把工作委托给了 layoutChildren()，看下里面做了什么： 计算 DecorView 的剩余空间范围 遍历子view，根据 子view 的 layout_gravity 属性、布局方向 使用 父View的剩余空间范围、子view的测量宽度和子view的左右margin 计算 子view的左坐标；根据 子view 的 layout_gravity 属性 使用 父View的剩余空间范围、子view的测量高度和子view的上下margin 计算 子view的上坐标 调用 子view 的 layout()，传入刚才计算好的子view的位置 DecorView 的 Draw 流程在 Layout 流程执行完后，会调用 performDraw() 开始 Draw 流程。performDraw() 通过调用 draw(fullRedrawNeeded, forceDraw) 来处理绘制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172private boolean draw(boolean fullRedrawNeeded, boolean forceDraw) &#123; Surface surface = mSurface; if (!surface.isValid()) &#123; return false; &#125; if (DEBUG_FPS) &#123; trackFPS(); &#125; if (!sFirstDrawComplete) &#123; synchronized (sFirstDrawHandlers) &#123; sFirstDrawComplete = true; final int count = sFirstDrawHandlers.size(); for (int i = 0; i&lt; count; i++) &#123; mHandler.post(sFirstDrawHandlers.get(i)); &#125; &#125; &#125; scrollToRectOrFocus(null, false); if (mAttachInfo.mViewScrollChanged) &#123; mAttachInfo.mViewScrollChanged = false; mAttachInfo.mTreeObserver.dispatchOnScrollChanged(); &#125; boolean animating = mScroller != null &amp;&amp; mScroller.computeScrollOffset(); final int curScrollY; if (animating) &#123; curScrollY = mScroller.getCurrY(); &#125; else &#123; curScrollY = mScrollY; &#125; if (mCurScrollY != curScrollY) &#123; mCurScrollY = curScrollY; fullRedrawNeeded = true; if (mView instanceof RootViewSurfaceTaker) &#123; ((RootViewSurfaceTaker) mView).onRootViewScrollYChanged(mCurScrollY); &#125; &#125; final float appScale = mAttachInfo.mApplicationScale; final boolean scalingRequired = mAttachInfo.mScalingRequired; final Rect dirty = mDirty; if (mSurfaceHolder != null) &#123; // The app owns the surface, we won&#x27;t draw. dirty.setEmpty(); if (animating &amp;&amp; mScroller != null) &#123; mScroller.abortAnimation(); &#125; return false; &#125; if (fullRedrawNeeded) &#123; dirty.set(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f)); &#125; mAttachInfo.mTreeObserver.dispatchOnDraw(); int xOffset = -mCanvasOffsetX; int yOffset = -mCanvasOffsetY + curScrollY; final WindowManager.LayoutParams params = mWindowAttributes; final Rect surfaceInsets = params != null ? params.surfaceInsets : null; if (surfaceInsets != null) &#123; xOffset -= surfaceInsets.left; yOffset -= surfaceInsets.top; // Offset dirty rect for surface insets. dirty.offset(surfaceInsets.left, surfaceInsets.top); &#125; boolean accessibilityFocusDirty = false; final Drawable drawable = mAttachInfo.mAccessibilityFocusDrawable; if (drawable != null) &#123; final Rect bounds = mAttachInfo.mTmpInvalRect; final boolean hasFocus = getAccessibilityFocusedRect(bounds); if (!hasFocus) &#123; bounds.setEmpty(); &#125; if (!bounds.equals(drawable.getBounds())) &#123; accessibilityFocusDirty = true; &#125; &#125; mAttachInfo.mDrawingTime = mChoreographer.getFrameTimeNanos() / TimeUtils.NANOS_PER_MS; boolean useAsyncReport = false; if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123; if (isHardwareEnabled()) &#123; // If accessibility focus moved, always invalidate the root. boolean invalidateRoot = accessibilityFocusDirty || mInvalidateRootRequested; mInvalidateRootRequested = false; // Draw with hardware renderer. mIsAnimating = false; if (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) &#123; mHardwareYOffset = yOffset; mHardwareXOffset = xOffset; invalidateRoot = true; &#125; if (invalidateRoot) &#123; mAttachInfo.mThreadedRenderer.invalidateRoot(); &#125; dirty.setEmpty(); // Stage the content drawn size now. It will be transferred to the renderer // shortly before the draw commands get send to the renderer. final boolean updated = updateContentDrawBounds(); if (mReportNextDraw) &#123; // report next draw overrides setStopped() // This value is re-sync&#x27;d to the value of mStopped // in the handling of mReportNextDraw post-draw. mAttachInfo.mThreadedRenderer.setStopped(false); &#125; if (updated) &#123; requestDrawWindow(); &#125; useAsyncReport = true; if (forceDraw) &#123; mAttachInfo.mThreadedRenderer.forceDrawNextFrame(); &#125; mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this); &#125; else &#123; // If we get here with a disabled &amp; requested hardware renderer, something went // wrong (an invalidate posted right before we destroyed the hardware surface // for instance) so we should just bail out. Locking the surface with software // rendering at this point would lock it forever and prevent hardware renderer // from doing its job when it comes back. // Before we request a new frame we must however attempt to reinitiliaze the // hardware renderer if it&#x27;s in requested state. This would happen after an // eglTerminate() for instance. if (mAttachInfo.mThreadedRenderer != null &amp;&amp; !mAttachInfo.mThreadedRenderer.isEnabled() &amp;&amp; mAttachInfo.mThreadedRenderer.isRequested() &amp;&amp; mSurface.isValid()) &#123; try &#123; mAttachInfo.mThreadedRenderer.initializeIfNeeded( mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets); &#125; catch (OutOfResourcesException e) &#123; handleOutOfResourcesException(e); return false; &#125; mFullRedrawNeeded = true; scheduleTraversals(); return false; &#125; if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets)) &#123; return false; &#125; &#125; &#125; if (animating) &#123; mFullRedrawNeeded = true; scheduleTraversals(); &#125; return useAsyncReport;&#125; 分两种情况进行处理： 启用了硬件渲染：mAttachInfo.mThreadedRenderer.draw() -&gt; updateRootDisplayList() -&gt; view.updateDisplayListIfDirty() -&gt; draw(canvas) 未启用硬件渲染：drawSoftware() -&gt; mView.draw(canvas) Viewdraw(Canvas canvas) 调用 drawBackground() 绘制 background 如有必要，保存 canvas 的 layers 以备 fading 调用 onDraw() 绘制 view 的内容 调用 dispatchDraw() 绘制 children 如有必要，绘制 fading 边缘并恢复 layers 调用 onDrawForeground() 绘制 decorations（例如 scrollbars） 如有必要，调用 drawDefaultFocusHighlight() 绘制默认焦点高亮 dispatchDraw()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130protected void dispatchDraw(Canvas canvas) &#123; final int childrenCount = mChildrenCount; final View[] children = mChildren; int flags = mGroupFlags; if ((flags &amp; FLAG_RUN_ANIMATION) != 0 &amp;&amp; canAnimate()) &#123; for (int i = 0; i &lt; childrenCount; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123; final LayoutParams params = child.getLayoutParams(); attachLayoutAnimationParameters(child, params, i, childrenCount); bindLayoutAnimation(child); &#125; &#125; final LayoutAnimationController controller = mLayoutAnimationController; if (controller.willOverlap()) &#123; mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE; &#125; controller.start(); mGroupFlags &amp;= ~FLAG_RUN_ANIMATION; mGroupFlags &amp;= ~FLAG_ANIMATION_DONE; if (mAnimationListener != null) &#123; mAnimationListener.onAnimationStart(controller.getAnimation()); &#125; &#125; int clipSaveCount = 0; final boolean clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK; if (clipToPadding) &#123; clipSaveCount = canvas.save(Canvas.CLIP_SAVE_FLAG); canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop, mScrollX + mRight - mLeft - mPaddingRight, mScrollY + mBottom - mTop - mPaddingBottom); &#125; // We will draw our child&#x27;s animation, let&#x27;s reset the flag mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION; mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED; boolean more = false; final long drawingTime = getDrawingTime(); canvas.enableZ(); final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size(); int transientIndex = transientCount != 0 ? 0 : -1; // Only use the preordered list if not HW accelerated, since the HW pipeline will do the // draw reordering internally final ArrayList&lt;View&gt; preorderedList = drawsWithRenderNode(canvas) ? null : buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); for (int i = 0; i &lt; childrenCount; i++) &#123; while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123; final View transientChild = mTransientViews.get(transientIndex); if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; transientIndex++; if (transientIndex &gt;= transientCount) &#123; transientIndex = -1; &#125; &#125; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; while (transientIndex &gt;= 0) &#123; // there may be additional transient views after the normal views final View transientChild = mTransientViews.get(transientIndex); if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; transientIndex++; if (transientIndex &gt;= transientCount) &#123; break; &#125; &#125; if (preorderedList != null) preorderedList.clear(); // Draw any disappearing views that have animations if (mDisappearingChildren != null) &#123; final ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren; final int disappearingCount = disappearingChildren.size() - 1; // Go backwards -- we may delete as animations finish for (int i = disappearingCount; i &gt;= 0; i--) &#123; final View child = disappearingChildren.get(i); more |= drawChild(canvas, child, drawingTime); &#125; &#125; canvas.disableZ(); if (isShowingLayoutBounds()) &#123; onDebugDraw(canvas); &#125; if (clipToPadding) &#123; canvas.restoreToCount(clipSaveCount); &#125; // mGroupFlags might have been updated by drawChild() flags = mGroupFlags; if ((flags &amp; FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) &#123; invalidate(true); &#125; if ((flags &amp; FLAG_ANIMATION_DONE) == 0 &amp;&amp; (flags &amp; FLAG_NOTIFY_ANIMATION_LISTENER) == 0 &amp;&amp; mLayoutAnimationController.isDone() &amp;&amp; !more) &#123; // We want to erase the drawing cache and notify the listener after the // next frame is drawn because one extra invalidate() is caused by // drawChild() after the animation is over mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER; final Runnable end = new Runnable() &#123; @Override public void run() &#123; notifyAnimationListener(); &#125; &#125;; post(end); &#125;&#125; 调用 drawChild() 绘制子 view。drawChild() 调用子 view 的 draw(Canvas canvas, ViewGroup parent, long drawingTime) draw(Canvas canvas, ViewGroup parent, long drawingTime)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated(); boolean drawingWithRenderNode = drawsWithRenderNode(canvas); boolean more = false; final boolean childHasIdentityMatrix = hasIdentityMatrix(); final int parentFlags = parent.mGroupFlags; if ((parentFlags &amp; ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) &#123; parent.getChildTransformation().clear(); parent.mGroupFlags &amp;= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION; &#125; Transformation transformToApply = null; boolean concatMatrix = false; final boolean scalingRequired = mAttachInfo != null &amp;&amp; mAttachInfo.mScalingRequired; final Animation a = getAnimation(); if (a != null) &#123; more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired); concatMatrix = a.willChangeTransformationMatrix(); if (concatMatrix) &#123; mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM; &#125; transformToApply = parent.getChildTransformation(); &#125; else &#123; if ((mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) &#123; // No longer animating: clear out old animation matrix mRenderNode.setAnimationMatrix(null); mPrivateFlags3 &amp;= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM; &#125; if (!drawingWithRenderNode &amp;&amp; (parentFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) &#123; final Transformation t = parent.getChildTransformation(); final boolean hasTransform = parent.getChildStaticTransformation(this, t); if (hasTransform) &#123; final int transformType = t.getTransformationType(); transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null; concatMatrix = (transformType &amp; Transformation.TYPE_MATRIX) != 0; &#125; &#125; &#125; concatMatrix |= !childHasIdentityMatrix; // Sets the flag as early as possible to allow draw() implementations // to call invalidate() successfully when doing animations mPrivateFlags |= PFLAG_DRAWN; if (!concatMatrix &amp;&amp; (parentFlags &amp; (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN &amp;&amp; canvas.quickReject(mLeft, mTop, mRight, mBottom) &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) == 0) &#123; mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED; return more; &#125; mPrivateFlags2 &amp;= ~PFLAG2_VIEW_QUICK_REJECTED; if (hardwareAcceleratedCanvas) &#123; // Clear INVALIDATED flag to allow invalidation to occur during rendering, but // retain the flag&#x27;s value temporarily in the mRecreateDisplayList flag mRecreateDisplayList = (mPrivateFlags &amp; PFLAG_INVALIDATED) != 0; mPrivateFlags &amp;= ~PFLAG_INVALIDATED; &#125; RenderNode renderNode = null; Bitmap cache = null; int layerType = getLayerType(); // TODO: signify cache state with just &#x27;cache&#x27; local if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) &#123; if (layerType != LAYER_TYPE_NONE) &#123; // If not drawing with RenderNode, treat HW layers as SW layerType = LAYER_TYPE_SOFTWARE; buildDrawingCache(true); &#125; cache = getDrawingCache(true); &#125; if (drawingWithRenderNode) &#123; // Delay getting the display list until animation-driven alpha values are // set up and possibly passed on to the view renderNode = updateDisplayListIfDirty(); if (!renderNode.hasDisplayList()) &#123; // Uncommon, but possible. If a view is removed from the hierarchy during the call // to getDisplayList(), the display list will be marked invalid and we should not // try to use it again. renderNode = null; drawingWithRenderNode = false; &#125; &#125; int sx = 0; int sy = 0; if (!drawingWithRenderNode) &#123; computeScroll(); sx = mScrollX; sy = mScrollY; &#125; final boolean drawingWithDrawingCache = cache != null &amp;&amp; !drawingWithRenderNode; final boolean offsetForScroll = cache == null &amp;&amp; !drawingWithRenderNode; int restoreTo = -1; if (!drawingWithRenderNode || transformToApply != null) &#123; restoreTo = canvas.save(); &#125; if (offsetForScroll) &#123; canvas.translate(mLeft - sx, mTop - sy); &#125; else &#123; if (!drawingWithRenderNode) &#123; canvas.translate(mLeft, mTop); &#125; if (scalingRequired) &#123; if (drawingWithRenderNode) &#123; // TODO: Might not need this if we put everything inside the DL restoreTo = canvas.save(); &#125; // mAttachInfo cannot be null, otherwise scalingRequired == false final float scale = 1.0f / mAttachInfo.mApplicationScale; canvas.scale(scale, scale); &#125; &#125; float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha()); if (transformToApply != null || alpha &lt; 1 || !hasIdentityMatrix() || (mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) &#123; if (transformToApply != null || !childHasIdentityMatrix) &#123; int transX = 0; int transY = 0; if (offsetForScroll) &#123; transX = -sx; transY = -sy; &#125; if (transformToApply != null) &#123; if (concatMatrix) &#123; if (drawingWithRenderNode) &#123; renderNode.setAnimationMatrix(transformToApply.getMatrix()); &#125; else &#123; // Undo the scroll translation, apply the transformation matrix, // then redo the scroll translate to get the correct result. canvas.translate(-transX, -transY); canvas.concat(transformToApply.getMatrix()); canvas.translate(transX, transY); &#125; parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; &#125; float transformAlpha = transformToApply.getAlpha(); if (transformAlpha &lt; 1) &#123; alpha *= transformAlpha; parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; &#125; &#125; if (!childHasIdentityMatrix &amp;&amp; !drawingWithRenderNode) &#123; canvas.translate(-transX, -transY); canvas.concat(getMatrix()); canvas.translate(transX, transY); &#125; &#125; // Deal with alpha if it is or used to be &lt;1 if (alpha &lt; 1 || (mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) &#123; if (alpha &lt; 1) &#123; mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA; &#125; else &#123; mPrivateFlags3 &amp;= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA; &#125; parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; if (!drawingWithDrawingCache) &#123; final int multipliedAlpha = (int) (255 * alpha); if (!onSetAlpha(multipliedAlpha)) &#123; if (drawingWithRenderNode) &#123; renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha()); &#125; else if (layerType == LAYER_TYPE_NONE) &#123; canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha); &#125; &#125; else &#123; // Alpha is handled by the child directly, clobber the layer&#x27;s alpha mPrivateFlags |= PFLAG_ALPHA_SET; &#125; &#125; &#125; &#125; else if ((mPrivateFlags &amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) &#123; onSetAlpha(255); mPrivateFlags &amp;= ~PFLAG_ALPHA_SET; &#125; if (!drawingWithRenderNode) &#123; // apply clips directly, since RenderNode won&#x27;t do it for this draw if ((parentFlags &amp; ViewGroup.FLAG_CLIP_CHILDREN) != 0 &amp;&amp; cache == null) &#123; if (offsetForScroll) &#123; canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight()); &#125; else &#123; if (!scalingRequired || cache == null) &#123; canvas.clipRect(0, 0, getWidth(), getHeight()); &#125; else &#123; canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight()); &#125; &#125; &#125; if (mClipBounds != null) &#123; // clip bounds ignore scroll canvas.clipRect(mClipBounds); &#125; &#125; if (!drawingWithDrawingCache) &#123; if (drawingWithRenderNode) &#123; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; ((RecordingCanvas) canvas).drawRenderNode(renderNode); &#125; else &#123; // Fast path for layouts with no backgrounds if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; dispatchDraw(canvas); &#125; else &#123; draw(canvas); &#125; &#125; &#125; else if (cache != null) &#123; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) &#123; // no layer paint, use temporary paint to draw bitmap Paint cachePaint = parent.mCachePaint; if (cachePaint == null) &#123; cachePaint = new Paint(); cachePaint.setDither(false); parent.mCachePaint = cachePaint; &#125; cachePaint.setAlpha((int) (alpha * 255)); canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint); &#125; else &#123; // use layer paint to draw the bitmap, merging the two alphas, but also restore int layerPaintAlpha = mLayerPaint.getAlpha(); if (alpha &lt; 1) &#123; mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha)); &#125; canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint); if (alpha &lt; 1) &#123; mLayerPaint.setAlpha(layerPaintAlpha); &#125; &#125; &#125; if (restoreTo &gt;= 0) &#123; canvas.restoreToCount(restoreTo); &#125; if (a != null &amp;&amp; !more) &#123; if (!hardwareAcceleratedCanvas &amp;&amp; !a.getFillAfter()) &#123; onSetAlpha(255); &#125; parent.finishAnimatingView(this, a); &#125; if (more &amp;&amp; hardwareAcceleratedCanvas) &#123; if (a.hasAlpha() &amp;&amp; (mPrivateFlags &amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) &#123; // alpha animations should cause the child to recreate its display list invalidate(true); &#125; &#125; mRecreateDisplayList = false; return more;&#125; 判断是否支持硬件加速 若支持硬件加速，则调用 updateDisplayListIfDirty() 更新 renderNode 判断是否使用 cache 进行绘制： 使用 cache：canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint) 不使用 cache：若支持硬件加速，((RecordingCanvas) canvas).drawRenderNode(renderNode)；否则，draw(canvas) 或者 dispatchDraw(canvas) updateDisplayListIfDirty()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public RenderNode updateDisplayListIfDirty() &#123; final RenderNode renderNode = mRenderNode; if (!canHaveDisplayList()) &#123; // can&#x27;t populate RenderNode, don&#x27;t try return renderNode; &#125; if ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0 || !renderNode.hasDisplayList() || (mRecreateDisplayList)) &#123; // Don&#x27;t need to recreate the display list, just need to tell our // children to restore/recreate theirs if (renderNode.hasDisplayList() &amp;&amp; !mRecreateDisplayList) &#123; mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; dispatchGetDisplayList(); return renderNode; // no work needed &#125; // If we got here, we&#x27;re recreating it. Mark it as such to ensure that // we copy in child display lists into ours in drawChild() mRecreateDisplayList = true; int width = mRight - mLeft; int height = mBottom - mTop; int layerType = getLayerType(); // Hacky hack: Reset any stretch effects as those are applied during the draw pass // instead of being &quot;stateful&quot; like other RenderNode properties renderNode.clearStretch(); final RecordingCanvas canvas = renderNode.beginRecording(width, height); try &#123; if (layerType == LAYER_TYPE_SOFTWARE) &#123; buildDrawingCache(true); Bitmap cache = getDrawingCache(true); if (cache != null) &#123; canvas.drawBitmap(cache, 0, 0, mLayerPaint); &#125; &#125; else &#123; computeScroll(); canvas.translate(-mScrollX, -mScrollY); mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; // Fast path for layouts with no backgrounds if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123; dispatchDraw(canvas); drawAutofilledHighlight(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().draw(canvas); &#125; if (isShowingLayoutBounds()) &#123; debugDrawFocus(canvas); &#125; &#125; else &#123; draw(canvas); &#125; &#125; &#125; finally &#123; renderNode.endRecording(); setDisplayListProperties(renderNode); &#125; &#125; else &#123; mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; &#125; return renderNode;&#125; 获取 canvas： RecordingCanvas canvas &#x3D; renderNode.beginRecording(width, height) 绘制： layerType &#x3D;&#x3D; LAYER_TYPE_SOFTWARE：调用 buildDrawingCache() 构建 cache，然后 canvas.drawBitmap(cache, 0, 0, mLayerPaint) else： draw(canvas) 或者 dispatchDraw(canvas)","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - Bitmap","slug":"Android-Bitmap","date":"2023-02-28T06:43:37.000Z","updated":"2023-07-14T04:40:17.261Z","comments":true,"path":"2023/02/28/Android-Bitmap/","link":"","permalink":"https://azxkenzo.github.io/2023/02/28/Android-Bitmap/","excerpt":"","text":"Bitmap 类的定义： 1public final class Bitmap implements Parcelable 主要方法和属性 mNativePtr: 方便JNI访问 getDensity(): 返回此 Bitmap 的密度 setDensity(): 指定此 Bitmap 的密度。 当 Bitmap 被绘制到同样具有密度的 Canvas 时，它会被适当缩放。 reconfigure(): 修改 Bitmap 使具有指定的宽度、高度和 Bitmap.Config，而不影响支持 bitmap 的底层分配。不会为新配置重新初始化 bitmap 像素数据。此方法可用于避免分配新的 bitmap，而是将现有 bitmap 的分配重新用于大小相等或更小的新配置。 recycle(): 释放与此 bitmap 关联的 native 对象，并清除对像素数据的引用。 这不会同步释放像素数据； 如果没有其他引用，它只是允许它被垃圾收集。 bitmap 被标记为“ dead”，这意味着如果调用 getPixels() 或 setPixels() 它将抛出异常，并且不会绘制任何内容。 此操作无法撤消，因此只有在确定该位图不再有其他用途时才应调用它。 这是一个高级调用，通常不需要调用，因为正常的 GC 过程将在不再引用此 bitmap 时释放此内存。 getGenerationId(): 返回此 bitmap 的生成 ID。 每当修改 bitmap 时，生成 ID 都会更改。 这可以用作检查 bitmap 是否已更改的有效方法。 copy(): 尝试根据此 Bitmap 的尺寸制作新 Bitmap，将新 Bitmap 的配置设置为指定的配置，然后将此 Bitmap 的像素复制到新 Bitmap 中。 如果不支持转换，或者分配器失败，则返回 NULL。 返回的 Bitmap 与原始 Bitmap 具有相同的密度和颜色空间，但以下情况除外。 复制到 Bitmap.Config.ALPHA_8 时，颜色空间被丢弃。 一系列 createBitmap() 重载方法 compress(): 将 Bitmap 的压缩版本写入指定的输出流。 如果返回 true，则可以通过将相应的输入流传递给 BitmapFactory.decodeStream() 来重建位图。 注意：并非所有格式都直接支持所有位图配置，因此从 BitmapFactory 返回的位图可能具有不同的位深度，和&#x2F;或可能丢失了每像素 alpha（例如 JPEG 仅支持不透明像素）。 Bitmap.ConfigConfig 类表示可能的 bitmap 配置。 bitmap 配置描述了像素的存储方式。 这会影响质量（颜色深度）以及显示透明&#x2F;半透明颜色的能力。 Config 有以下枚举值： ALPHA_8(1): 每个像素都存储为单个半透明 (alpha) 通道。 例如，这对于有效存储掩码非常有用。 不存储颜色信息。 使用此配置，每个像素需要 1 个字节的内存。 RGB_565(3): 每个像素存储在 2 个字节上，仅对 RGB 通道进行编码：红色以 5 位精度存储（32 个可能值），绿色以 6 位精度存储（64 个可能值），蓝色以 5 位精度存储。 ARGB_8888(5): 每个像素存储在 4 个字节上。 每个通道（半透明的 RGB 和 alpha）都以 8 位精度（256 个可能的值）存储。这种配置非常灵活并提供最佳质量。 应尽可能使用它。 RGBA_F16(6): 每个像素存储在 8 个字节上。 每个通道（用于半透明的 RGB 和 alpha）都存储为半精度浮点值。 此配置特别适合广色域和 HDR 内容。 HARDWARE(7): 特殊配置，当位图仅存储在图形内存中时。 此配置中的位图始终是不可变的。 当对位图的唯一操作是在屏幕上绘制它时，它是最佳的情况。 RGBA_1010102(8): 每个像素存储在 4 个字节上。 每个 RGB 通道都以 10 位精度（1024 个可能值）存储。 有一个额外的 alpha 通道，它以 2 位精度（4 个可能的值）存储。 此配置适用于不需要 alpha 混合的广色域和 HDR 内容，因此内存成本与 ARGB_8888 相同，同时实现更高的颜色精度。 Bitmap.CompressFormatCompressFormat 类指定 Bitmap 可以压缩成的已知格式 有这几个值：JPEG、PNG、WEBP_LOSSY、WEBP_LOSSLESS BitmapFactoryBitmapFactory 用于从各种来源创建 bitmap 对象，包括文件、流和字节数组。 主要方法 decodeByteArray decodeFile decodeFileDescriptor decodeResource decodeStream BitmapFactory.OptionsOptions 是一个解码的配置类 主要参数： inBitmap: 如果设置，采用 Options 对象的解码方法将在加载内容时尝试重用此 bitmap。 如果解码操作不能使用此 bitmap，则解码方法将抛出 IllegalArgumentException。 当前的实现要求重用 bitmap 是 mutable 的，并且即使在解码通常会导致 bitmap immutable 的资源时，生成的重用 bitmap 也将继续保持 mutable。 inJustDecodeBounds: 如果设置为 true，解码器将返回 null（无位图），但 out… 字段仍将被设置，允许调用者查询位图而无需为其像素分配内存。 inSampleSize: 如果设置为 &gt; 1 的值，则请求解码器对原始图像进行子采样，返回较小的图像以节省内存。 样本大小是与解码位图中的单个像素相对应的任一维度中的像素数。 例如，inSampleSize &#x3D;&#x3D; 4 返回的图像是原始宽度&#x2F;高度的 1&#x2F;4，像素数的 1&#x2F;16。 任何 &lt;&#x3D; 1 的值都被视为与 1 相同。注意：解码器使用基于 2 的幂的最终值，任何其他值将向下舍入为最接近的 2 的幂。 inTargetDensity: 此 bitmap 将绘制到的目标的像素密度。 这与 inDensity 和 inScaled 结合使用，以确定在返回位图之前是否以及如何缩放位图。 inDensity: 用于 bitmap 的像素密度。这将始终导致返回的 bitmap 具有为其设置的密度。此外，如果设置了 inScaled（默认设置）并且此密度与 inTargetDensity 不匹配，则位图将在返回之前缩放到目标密度。 outColorSpace: 解码位图将具有的颜色空间。 请注意，output 颜色空间不能保证是位图编码的颜色空间。 如果未知（例如，当配置为 Bitmap.Config.ALPHA_8 时），或出现错误，则将其设置为空。 outConfig outHeight: 位图的结果高度。 如果 inJustDecodeBounds 设置为 false，这将是应用任何缩放后输出位图的高度。 如果为真，它将是输入图像的高度，不考虑缩放。 outMimeType outWidth BitmapRegionDecoderBitmapRegionDecoder 可用于从图像中解码矩形区域。 当原始图像很大并且只需要图像的一部分时，BitmapRegionDecoder 特别有用。要创建 BitmapRegionDecoder，调用 newInstance(…)。 给定一个 BitmapRegionDecoder，用户可以重复调用 decodeRegion() 以获得指定区域的解码位图。 Bitmap 内存占用Bitmap 内存占用大小 &#x3D; Bitmap.width * Bitmap.height * 像素点大小 像素点大小由 Bitmap.Config 的值控制。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - RecyclerView","slug":"Android-RecyclerView","date":"2023-02-24T09:28:34.000Z","updated":"2023-07-18T04:22:50.370Z","comments":true,"path":"2023/02/24/Android-RecyclerView/","link":"","permalink":"https://azxkenzo.github.io/2023/02/24/Android-RecyclerView/","excerpt":"","text":"RecyclerView Adapter：提供表示数据集中 item 的 view Position：Adapter 中数据项的位置 Index：调用 ViewGroup.getChildAt 时使用的 attached 子View 的索引 Binding：准备子View以显示与 Adapter 内某个 position 对应数据的过程 Recycle(view)：之前用于显示特定 adapter position 的数据的 view 可能会被放置在缓存中以供以后重用以稍后再次显示相同类型的数据 Scrap(view)：在 layout 时进入暂时分离状态的子View。可以在不完全脱离父RecyclerView的情况下重用 Scrap view，如果不需要重新绑定则不修改，或者 view 被认为是 dirty 则由 adapter 修改 Dirty(view)：一个子View，在显示之前必须被 adapter 重新绑定 PositionRecyclerView 中有两类 position 相关的方法： layout position：item 在最新的 layout计算 中的 position adapter position：item 在 adapter 中的位置 除了调度 adapter.notify* 事件和计算 updated layout 的时间之外，这两个 position 是相同的 返回或接收 LayoutPosition 的方法使用最新布局计算的 position。这些 position 包括最后一次布局计算之前的所有更改。可以依赖这些 position 来与当前屏幕上看到的内容保持一致 另一组方法采用 AdapterPosition 形式。当需要使用最新的 adapter position 时应该使用这些方法，即使它们可能还没有反映到 layout 呈现动态数据在 Recycler 中显示可更新数据，adapter 要发出 insert、move 和 delete 信号。可以通过在内容更改时手动调用 adapter.notify* 方法，或者使用 RecyclerView 提供的解决方案： 使用 DiffUtil 列出差异：如果 RecyclerView 显示的列表是为每次更新从头开始重新获取的（例如从网络或数据库），DiffUtil 可以计算列表版本之间的差异。DiffUtil 将两个列表作为输入并计算差异，可以将差异传递给 RecyclerView 以触发最少的动画和更新以保持 UI 性能和动画有意义。这种方法要求每个列表在内存中以不可变的内容表示，并依赖于接收更新作为列表的新实例。 如果 UI 层没有实现排序，这种方法也是理想的，它只是按照给定的顺序显示数据。这种方法最好的部分是它扩展到任何任意更改——项目更新、移动、添加和删除都可以用相同的方式计算和处理。 虽然在比较时必须在内存中保留列表的两个副本，并且必须避免改变它们，但可以在列表版本之间共享未修改的元素。对于 RecyclerView，主要有三种方法可以做到这一点。 建议从 ListAdapter 开始，它是在后台线程上用最少的代码构建在 List diffing 中的更高级别的 API。 AsyncListDiffer 也提供了这种行为，但没有为子类定义适配器。 如果想要更多的控制，DiffUtil 是可以用来自己计算差异的低级 API。 每种方法都允许指定应如何根据项目数据计算差异。 使用 SortedList 列出变异：如果 RecyclerView 以增量方式接收更新，例如 插入item X，或删除item Y，可以使用 SortedList 来管理列表。定义如何 order item，它会自动触发 RecyclerView 可以使用的更新信号。 如果只需要处理插入和删除事件，SortedList 就可以工作，并且好处是只需要在内存中拥有一个列表副本。 它还可以计算与 SortedList.replaceAll(Object[]) 的差异，但此方法比上面的列表差异行为更受限制。 布局过程onLayout() -&gt; dispatchLayout() -&gt; dispatchLayoutStep1() -&gt; dispatchLayoutStep2() -&gt; LayoutManager.onLayoutChildren() -&gt; dispatchLayoutStep3() dispatchLayout()：layoutChildren() 的包装器，用于处理由布局引起的动画变化。 dispatchLayoutStep1()：布局的第一步； - 处理 adapter 更新 - 决定应该运行哪个动画 - 保存有关当前 views 的信息 - 如有必要，运行预测布局并保存其信息 dispatchLayoutStep2()：第二个布局步骤，对最终状态的 view 进行实际布局。 如有必要（例如测量），此步骤可能会运行多次。 LayoutManager.onLayoutChildren()：布置给定 adapter 的所有相关子视图。 dispatchLayoutStep3()：布局的最后一步，保存有关用于动画的 view 的信息，触发动画并进行任何必要的清理。 测量流程RecyclerView.onMeasure() 做了什么： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556protected void onMeasure(int widthSpec, int heightSpec) &#123; if (mLayout == null) &#123; defaultOnMeasure(widthSpec, heightSpec); return; &#125; if (mLayout.isAutoMeasureEnabled()) &#123; final int widthMode = MeasureSpec.getMode(widthSpec); final int heightMode = MeasureSpec.getMode(heightSpec); /** * This specific call should be considered deprecated and replaced with * &#123;@link #defaultOnMeasure(int, int)&#125;. It can&#x27;t actually be replaced as it could * break existing third party code but all documentation directs developers to not * override &#123;@link LayoutManager#onMeasure(int, int)&#125; when * &#123;@link LayoutManager#isAutoMeasureEnabled()&#125; returns true. */ mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); // 计算并跟踪是否应该在此处跳过测量，因为两个维度中的 MeasureSpec 模式都是 EXACTLY。 mLastAutoMeasureSkippedDueToExact = widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY; if (mLastAutoMeasureSkippedDueToExact || mAdapter == null) &#123; return; &#125; // 第一步 if (mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); &#125; // 在第二步中设置尺寸。 为了保持一致性，应该使用旧尺寸进行预布局 mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; // 第二步 dispatchLayoutStep2(); // 现在可以从 children 那里得到宽度和高度。 mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); // 如果 RecyclerView 的宽度和高度不准确，并且至少有一个 child 的宽度和高度也不准确，必须重新测量。 if (mLayout.shouldMeasureTwice()) &#123; mLayout.setMeasureSpecs( MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY)); mState.mIsMeasuring = true; dispatchLayoutStep2(); mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); &#125; mLastAutoMeasureNonExactMeasuredWidth = getMeasuredWidth(); mLastAutoMeasureNonExactMeasuredHeight = getMeasuredHeight(); &#125; else &#123; &#125;&#125; State.mLayoutStep 有 3 种取值情况： STEP_START：默认值，这种情况下，表示 RecyclerView 还未经历 dispatchLayoutStep1，因为 dispatchLayoutStep1 调用之后 mState.mLayoutStep 会变为 State.STEP_LAYOUT。 STEP_LAYOUT：当 mState.mLayoutStep 为 State.STEP_LAYOUT 时，表示此时处于 layout 阶段，这个阶段会调用 dispatchLayoutStep2 方法 layout RecyclerView 的children。调用 dispatchLayoutStep2 方法之后，此时 mState.mLayoutStep 变为了 State.STEP_ANIMATIONS。 STEP_ANIMATIONS：当 mState.mLayoutStep 为 State.STEP_ANIMATIONS 时，表示 RecyclerView 处于第三个阶段，也就是执行动画的阶段，也就是调用 dispatchLayoutStep3方法。当 dispatchLayoutStep3 方法执行完毕之后，mState.mLayoutStep 又变为了 State.STEP_START。 在 onMeasure 中，RV 根据 LayoutManager 的状态做了不同处理： 未设置 LayoutManager 时，调用 defaultOnMeasure() 进行测量 LayoutManager 启用了 AutoMeasure 时，先调用 LayoutManager.onMeasure() 进行测量，然后调用 dispatchLayoutStep1() 和 dispatchLayoutStep2() 完成布局流程的前两步 LayoutManager 未启用 AutoMeasure 时， dispatchLayoutStep1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126The first step of a layout where we; - process adapter updates - decide which animation should run - save information about current views - If necessary, run predictive layout and save its informationprivate void dispatchLayoutStep1() &#123; mState.assertLayoutStep(State.STEP_START); fillRemainingScrollValues(mState); mState.mIsMeasuring = false; startInterceptRequestLayout(); mViewInfoStore.clear(); onEnterLayoutOrScroll(); // 处理 adapter 更新 processAdapterUpdatesAndSetAnimationFlags(); saveFocusInfo(); mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged; mItemsAddedOrRemoved = mItemsChanged = false; mState.mInPreLayout = mState.mRunPredictiveAnimations; mState.mItemCount = mAdapter.getItemCount(); findMinMaxChildLayoutPositions(mMinMaxLayoutPositions); if (mState.mRunSimpleAnimations) &#123; // Step 0: 找出所有未删除的 item 在哪里，预布局 int count = mChildHelper.getChildCount(); for (int i = 0; i &lt; count; ++i) &#123; final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123; continue; &#125; final ItemHolderInfo animationInfo = mItemAnimator .recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads()); mViewInfoStore.addToPreLayout(holder, animationInfo); if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved() &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123; long key = getChangedHolderKey(holder); // This is NOT the only place where a ViewHolder is added to old change holders // list. There is another case where: // * A VH is currently hidden but not deleted // * The hidden item is changed in the adapter // * Layout manager decides to layout the item in the pre-Layout pass (step1) // When this case is detected, RV will un-hide that view and add to the old // change holders list. mViewInfoStore.addToOldChangeHolders(key, holder); &#125; &#125; &#125; if (mState.mRunPredictiveAnimations) &#123; // Step 1: 进行预布局: This will use the old positions of items. The layout manager // is expected to layout everything, even removed items (though not to add removed // items back to the container). This gives the pre-layout position of APPEARING views // which come into existence as part of the real layout. // Save old positions so that LayoutManager can run its mapping logic. saveOldPositions(); final boolean didStructureChange = mState.mStructureChanged; mState.mStructureChanged = false; // temporarily disable flag because we are asking for previous layout mLayout.onLayoutChildren(mRecycler, mState); mState.mStructureChanged = didStructureChange; for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) &#123; final View child = mChildHelper.getChildAt(i); final ViewHolder viewHolder = getChildViewHolderInt(child); if (viewHolder.shouldIgnore()) &#123; continue; &#125; if (!mViewInfoStore.isInPreLayout(viewHolder)) &#123; int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder); boolean wasHidden = viewHolder .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); if (!wasHidden) &#123; flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT; &#125; final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation( mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads()); if (wasHidden) &#123; recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo); &#125; else &#123; mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo); &#125; &#125; &#125; // we don&#x27;t process disappearing list because they may re-appear in post layout pass. clearOldPositions(); &#125; else &#123; clearOldPositions(); &#125; onExitLayoutOrScroll(); stopInterceptRequestLayout(false); mState.mLayoutStep = State.STEP_LAYOUT;&#125;private void processAdapterUpdatesAndSetAnimationFlags() &#123; if (mDataSetHasChangedAfterLayout) &#123; // Processing these items have no value since data set changed unexpectedly. // Instead, we just reset it. mAdapterHelper.reset(); if (mDispatchItemsChangedEvent) &#123; mLayout.onItemsChanged(this); &#125; &#125; // simple animations are a subset of advanced animations (which will cause a // pre-layout step) // If layout supports predictive animations, pre-process to decide if we want to run them if (predictiveItemAnimationsEnabled()) &#123; mAdapterHelper.preProcess(); &#125; else &#123; mAdapterHelper.consumeUpdatesInOnePass(); &#125; boolean animationTypeSupported = mItemsAddedOrRemoved || mItemsChanged; mState.mRunSimpleAnimations = mFirstLayoutComplete &amp;&amp; mItemAnimator != null &amp;&amp; (mDataSetHasChangedAfterLayout || animationTypeSupported || mLayout.mRequestedSimpleAnimations) &amp;&amp; (!mDataSetHasChangedAfterLayout || mAdapter.hasStableIds()); mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations &amp;&amp; animationTypeSupported &amp;&amp; !mDataSetHasChangedAfterLayout &amp;&amp; predictiveItemAnimationsEnabled();&#125; dispatchLayoutStep1 主要做以下几件事： 处理 adapter 更新 决定执行哪个动画 保存每个 view 的信息 有必要的话，进行预布局并保存相关信息 dispatchLayoutStep2123456789101112131415161718192021222324252627The second layout step where we do the actual layout of the views for the final state. This step might be run multiple times if necessary (e.g. measure).private void dispatchLayoutStep2() &#123; startInterceptRequestLayout(); onEnterLayoutOrScroll(); mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); mAdapterHelper.consumeUpdatesInOnePass(); mState.mItemCount = mAdapter.getItemCount(); // mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; if (mPendingSavedState != null &amp;&amp; mAdapter.canRestoreState()) &#123; if (mPendingSavedState.mLayoutState != null) &#123; mLayout.onRestoreInstanceState(mPendingSavedState.mLayoutState); &#125; mPendingSavedState = null; &#125; // Step 2: 进行布局 mState.mInPreLayout = false; mLayout.onLayoutChildren(mRecycler, mState); mState.mStructureChanged = false; // onLayoutChildren may have caused client code to disable item animations; re-check mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null; mState.mLayoutStep = State.STEP_ANIMATIONS; onExitLayoutOrScroll(); stopInterceptRequestLayout(false);&#125; dispatchLayoutStep2 通过调用 mLayout.onLayoutChildren() 来完成布局。 mLayout.onLayoutChildren() 是如何执行的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; // layout algorithm: // 1) 通过检查 children 和其他变量，找到锚点坐标和锚点项目位置 // 2) fill towards start, stacking from bottom // 3) fill towards end, stacking from top // 4) scroll to fulfill requirements like stack from bottom. // create layout state if (mPendingSavedState != null || mPendingScrollPosition != RecyclerView.NO_POSITION) &#123; if (state.getItemCount() == 0) &#123; removeAndRecycleAllViews(recycler); return; &#125; &#125; if (mPendingSavedState != null &amp;&amp; mPendingSavedState.hasValidAnchor()) &#123; mPendingScrollPosition = mPendingSavedState.mAnchorPosition; &#125; ensureLayoutState(); mLayoutState.mRecycle = false; // resolve layout direction resolveShouldLayoutReverse(); // 寻找 子view 的锚点坐标及位置 final View focused = getFocusedChild(); if (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION || mPendingSavedState != null) &#123; mAnchorInfo.reset(); mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd; // calculate anchor position and coordinate updateAnchorInfoForLayout(recycler, state, mAnchorInfo); mAnchorInfo.mValid = true; &#125; else if (focused != null &amp;&amp; (mOrientationHelper.getDecoratedStart(focused) &gt;= mOrientationHelper.getEndAfterPadding() || mOrientationHelper.getDecoratedEnd(focused) &lt;= mOrientationHelper.getStartAfterPadding())) &#123; // This case relates to when the anchor child is the focused view and due to layout // shrinking the focused view fell outside the viewport, e.g. when soft keyboard shows // up after tapping an EditText which shrinks RV causing the focused view (The tapped // EditText which is the anchor child) to get kicked out of the screen. Will update the // anchor coordinate in order to make sure that the focused view is laid out. Otherwise, // the available space in layoutState will be calculated as negative preventing the // focused view from being laid out in fill. // Note that we won&#x27;t update the anchor position between layout passes (refer to // TestResizingRelayoutWithAutoMeasure), which happens if we were to call // updateAnchorInfoForLayout for an anchor that&#x27;s not the focused view (e.g. a reference // child which can change between layout passes). mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused)); &#125; // LLM may decide to layout items for &quot;extra&quot; pixels to account for scrolling target, // caching or predictive animations. mLayoutState.mLayoutDirection = mLayoutState.mLastScrollDelta &gt;= 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START; mReusableIntPair[0] = 0; mReusableIntPair[1] = 0; calculateExtraLayoutSpace(state, mReusableIntPair); int extraForStart = Math.max(0, mReusableIntPair[0]) + mOrientationHelper.getStartAfterPadding(); int extraForEnd = Math.max(0, mReusableIntPair[1]) + mOrientationHelper.getEndPadding(); if (state.isPreLayout() &amp;&amp; mPendingScrollPosition != RecyclerView.NO_POSITION &amp;&amp; mPendingScrollPositionOffset != INVALID_OFFSET) &#123; // if the child is visible and we are going to move it around, we should layout // extra items in the opposite direction to make sure new items animate nicely // instead of just fading in final View existing = findViewByPosition(mPendingScrollPosition); if (existing != null) &#123; final int current; final int upcomingOffset; if (mShouldReverseLayout) &#123; current = mOrientationHelper.getEndAfterPadding() - mOrientationHelper.getDecoratedEnd(existing); upcomingOffset = current - mPendingScrollPositionOffset; &#125; else &#123; current = mOrientationHelper.getDecoratedStart(existing) - mOrientationHelper.getStartAfterPadding(); upcomingOffset = mPendingScrollPositionOffset - current; &#125; if (upcomingOffset &gt; 0) &#123; extraForStart += upcomingOffset; &#125; else &#123; extraForEnd -= upcomingOffset; &#125; &#125; &#125; int startOffset; int endOffset; final int firstLayoutDirection; if (mAnchorInfo.mLayoutFromEnd) &#123; firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL : LayoutState.ITEM_DIRECTION_HEAD; &#125; else &#123; firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL; &#125; onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection); // detach 子view 并缓存到 Recycler 中 detachAndScrapAttachedViews(recycler); mLayoutState.mInfinite = resolveIsInfinite(); mLayoutState.mIsPreLayout = state.isPreLayout(); // noRecycleSpace not needed: recycling doesn&#x27;t happen in below&#x27;s fill // invocations because mScrollingOffset is set to SCROLLING_OFFSET_NaN mLayoutState.mNoRecycleSpace = 0; if (mAnchorInfo.mLayoutFromEnd) &#123; // fill towards start updateLayoutStateToFillStart(mAnchorInfo); mLayoutState.mExtraFillSpace = extraForStart; // fill fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; final int firstElement = mLayoutState.mCurrentPosition; if (mLayoutState.mAvailable &gt; 0) &#123; extraForEnd += mLayoutState.mAvailable; &#125; // fill towards end updateLayoutStateToFillEnd(mAnchorInfo); mLayoutState.mExtraFillSpace = extraForEnd; mLayoutState.mCurrentPosition += mLayoutState.mItemDirection; fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; if (mLayoutState.mAvailable &gt; 0) &#123; // end could not consume all. add more items towards start extraForStart = mLayoutState.mAvailable; updateLayoutStateToFillStart(firstElement, startOffset); mLayoutState.mExtraFillSpace = extraForStart; fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; &#125; &#125; else &#123; // fill towards end updateLayoutStateToFillEnd(mAnchorInfo); mLayoutState.mExtraFillSpace = extraForEnd; fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; final int lastElement = mLayoutState.mCurrentPosition; if (mLayoutState.mAvailable &gt; 0) &#123; extraForStart += mLayoutState.mAvailable; &#125; // fill towards start updateLayoutStateToFillStart(mAnchorInfo); mLayoutState.mExtraFillSpace = extraForStart; mLayoutState.mCurrentPosition += mLayoutState.mItemDirection; fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; if (mLayoutState.mAvailable &gt; 0) &#123; extraForEnd = mLayoutState.mAvailable; // start could not consume all it should. add more items towards end updateLayoutStateToFillEnd(lastElement, endOffset); mLayoutState.mExtraFillSpace = extraForEnd; fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; &#125; &#125; // changes may cause gaps on the UI, try to fix them. // TODO we can probably avoid this if neither stackFromEnd/reverseLayout/RTL values have // changed if (getChildCount() &gt; 0) &#123; // because layout from end may be changed by scroll to position // we re-calculate it. // find which side we should check for gaps. if (mShouldReverseLayout ^ mStackFromEnd) &#123; int fixOffset = fixLayoutEndGap(endOffset, recycler, state, true); startOffset += fixOffset; endOffset += fixOffset; fixOffset = fixLayoutStartGap(startOffset, recycler, state, false); startOffset += fixOffset; endOffset += fixOffset; &#125; else &#123; int fixOffset = fixLayoutStartGap(startOffset, recycler, state, true); startOffset += fixOffset; endOffset += fixOffset; fixOffset = fixLayoutEndGap(endOffset, recycler, state, false); startOffset += fixOffset; endOffset += fixOffset; &#125; &#125; layoutForPredictiveAnimations(recycler, state, startOffset, endOffset); if (!state.isPreLayout()) &#123; mOrientationHelper.onLayoutComplete(); &#125; else &#123; mAnchorInfo.reset(); &#125; mLastStackFromEnd = mStackFromEnd;&#125; detachAndScrapAttachedViewsdetachAndScrapAttachedViews() 的作用是：暂时 detach 并 scrap 所有当前附加的 子view。view 将被 scrap 到给定的 Recycler 中。 Recycler 可能更愿意在之前回收的其他 view 之前重用 scrap view。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123public void detachAndScrapAttachedViews(@NonNull Recycler recycler) &#123; final int childCount = getChildCount(); for (int i = childCount - 1; i &gt;= 0; i--) &#123; final View v = getChildAt(i); scrapOrRecycleView(recycler, i, v); &#125;&#125;private void scrapOrRecycleView(Recycler recycler, int index, View view) &#123; final ViewHolder viewHolder = getChildViewHolderInt(view); if (viewHolder.shouldIgnore()) &#123; return; &#125; if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved() &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) &#123; // remove 子view 并缓存 removeViewAt(index); recycler.recycleViewHolderInternal(viewHolder); &#125; else &#123; // detach 子view 并缓存 detachViewAt(index); recycler.scrapView(view); mRecyclerView.mViewInfoStore.onViewDetached(viewHolder); &#125;&#125;void recycleViewHolderInternal(ViewHolder holder) &#123; if (holder.isScrap() || holder.itemView.getParent() != null) &#123; throw new IllegalArgumentException(); &#125; if (holder.isTmpDetached()) &#123; throw new IllegalArgumentException(); &#125; if (holder.shouldIgnore()) &#123; throw new IllegalArgumentException(); &#125; final boolean transientStatePreventsRecycling = holder .doesTransientStatePreventRecycling(); @SuppressWarnings(&quot;unchecked&quot;) final boolean forceRecycle = mAdapter != null &amp;&amp; transientStatePreventsRecycling &amp;&amp; mAdapter.onFailedToRecycleView(holder); boolean cached = false; boolean recycled = false; if (DEBUG &amp;&amp; mCachedViews.contains(holder)) &#123; throw new IllegalArgumentException(); &#125; if (forceRecycle || holder.isRecyclable()) &#123; if (mViewCacheMax &gt; 0 &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123; // Retire oldest cached view int cachedViewSize = mCachedViews.size(); // 超过缓存容量，把最旧的 view 放到 RecycledViewPool 里 if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123; recycleCachedViewAt(0); cachedViewSize--; &#125; int targetCacheIndex = cachedViewSize; if (ALLOW_THREAD_GAP_WORK &amp;&amp; cachedViewSize &gt; 0 &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) &#123; // when adding the view, skip past most recently prefetched views int cacheIndex = cachedViewSize - 1; while (cacheIndex &gt;= 0) &#123; int cachedPos = mCachedViews.get(cacheIndex).mPosition; if (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) &#123; break; &#125; cacheIndex--; &#125; targetCacheIndex = cacheIndex + 1; &#125; // 缓存 子view mCachedViews.add(targetCacheIndex, holder); cached = true; &#125; if (!cached) &#123; addViewHolderToRecycledViewPool(holder, true); recycled = true; &#125; &#125; else &#123; // NOTE: A view can fail to be recycled when it is scrolled off while an animation // runs. In this case, the item is eventually recycled by // ItemAnimatorRestoreListener#onAnimationFinished. // TODO: consider cancelling an animation when an item is removed scrollBy, // to return it to the pool faster &#125; // even if the holder is not removed, we still call this method so that it is removed // from view holder lists. mViewInfoStore.removeViewHolder(holder); if (!cached &amp;&amp; !recycled &amp;&amp; transientStatePreventsRecycling) &#123; holder.mBindingAdapter = null; holder.mOwnerRecyclerView = null; &#125;&#125;void recycleCachedViewAt(int cachedViewIndex) &#123; ViewHolder viewHolder = mCachedViews.get(cachedViewIndex); addViewHolderToRecycledViewPool(viewHolder, true); mCachedViews.remove(cachedViewIndex);&#125;void scrapView(View view) &#123; final ViewHolder holder = getChildViewHolderInt(view); if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID) || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123; if (holder.isInvalid() &amp;&amp; !holder.isRemoved() &amp;&amp; !mAdapter.hasStableIds()) &#123; throw new IllegalArgumentException(); &#125; holder.setScrapContainer(this, false); mAttachedScrap.add(holder); &#125; else &#123; if (mChangedScrap == null) &#123; mChangedScrap = new ArrayList&lt;ViewHolder&gt;(); &#125; holder.setScrapContainer(this, true); mChangedScrap.add(holder); &#125;&#125; 关于 detach 和 remove ： detach：将 子view 从 父View 的 childView 数组中，子view 的 mParent 设为 null remove：不仅从 childView 数组中被移除，其他与 view树 有关的信息也会被清除，如焦点等 缓存策略： VH无效 且 VH没有被remove 且 adapter没有稳定ID 时：remove 子View 并缓存，缓存策略为： 优先缓存到 mCachedViews 中。若 mCachedViews 已满，则将 mCachedViews 中最先放入到view移除并缓存到RecycledViewPool中，然后再将view缓存到mCachedViews中 若上一步执行完后，view没有被缓存到mCachedViews中，则将其缓存到RecycledViewPool中 否则，detach 子View 并缓存，缓存策略为： 若 VH被remove或无效 或 VH未更新 或 可以重用已更新的VH，则缓存到 mAttachedScrap 中 否则，缓存到 mChangedScrap 中 fill123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) &#123; // max offset we should set is mFastScroll + available final int start = layoutState.mAvailable; if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123; // TODO ugly bug fix. should not happen if (layoutState.mAvailable &lt; 0) &#123; layoutState.mScrollingOffset += layoutState.mAvailable; &#125; recycleByLayoutState(recycler, layoutState); &#125; int remainingSpace = layoutState.mAvailable + layoutState.mExtraFillSpace; LayoutChunkResult layoutChunkResult = mLayoutChunkResult; // 只加载一个屏幕能显示的 子view while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; layoutChunkResult.resetInternal(); // 加载 子view layoutChunk(recycler, state, layoutState, layoutChunkResult); if (layoutChunkResult.mFinished) &#123; break; &#125; layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection; /** * Consume the available space if: * * layoutChunk did not request to be ignored * * OR we are laying out scrap children * * OR we are not doing pre-layout */ if (!layoutChunkResult.mIgnoreConsumed || layoutState.mScrapList != null || !state.isPreLayout()) &#123; layoutState.mAvailable -= layoutChunkResult.mConsumed; // we keep a separate remaining space because mAvailable is important for recycling remainingSpace -= layoutChunkResult.mConsumed; &#125; if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123; layoutState.mScrollingOffset += layoutChunkResult.mConsumed; if (layoutState.mAvailable &lt; 0) &#123; layoutState.mScrollingOffset += layoutState.mAvailable; &#125; // 把移出屏幕的 view 缓存到 Recycler 中 recycleByLayoutState(recycler, layoutState); &#125; if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) &#123; break; &#125; &#125; return start - layoutState.mAvailable;&#125;void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) &#123; // 从 Recycler 或 adapter 获取一个 view View view = layoutState.next(recycler); if (view == null) &#123; if (DEBUG &amp;&amp; layoutState.mScrapList == null) &#123; throw new RuntimeException(&quot;received null view when unexpected&quot;); &#125; // if we are laying out views in scrap, this may return null which means there is // no more items to layout. result.mFinished = true; return; &#125; RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) view.getLayoutParams(); // 添加 子view 到 RecyclerView 上 if (layoutState.mScrapList == null) &#123; if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addView(view); &#125; else &#123; addView(view, 0); &#125; &#125; else &#123; if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addDisappearingView(view); &#125; else &#123; addDisappearingView(view, 0); &#125; &#125; // 执行 子view 的 measure 流程 measureChildWithMargins(view, 0, 0); result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view); int left, top, right, bottom; if (mOrientation == VERTICAL) &#123; if (isLayoutRTL()) &#123; right = getWidth() - getPaddingRight(); left = right - mOrientationHelper.getDecoratedMeasurementInOther(view); &#125; else &#123; left = getPaddingLeft(); right = left + mOrientationHelper.getDecoratedMeasurementInOther(view); &#125; if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123; bottom = layoutState.mOffset; top = layoutState.mOffset - result.mConsumed; &#125; else &#123; top = layoutState.mOffset; bottom = layoutState.mOffset + result.mConsumed; &#125; &#125; else &#123; top = getPaddingTop(); bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view); if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123; right = layoutState.mOffset; left = layoutState.mOffset - result.mConsumed; &#125; else &#123; left = layoutState.mOffset; right = layoutState.mOffset + result.mConsumed; &#125; &#125; // We calculate everything with View&#x27;s bounding box (which includes decor and margins) // To calculate correct layout position, we subtract margins. layoutDecoratedWithMargins(view, left, top, right, bottom); if (DEBUG) &#123; Log.d(TAG, &quot;laid out child at position &quot; + getPosition(view) + &quot;, with l:&quot; + (left + params.leftMargin) + &quot;, t:&quot; + (top + params.topMargin) + &quot;, r:&quot; + (right - params.rightMargin) + &quot;, b:&quot; + (bottom - params.bottomMargin)); &#125; // Consume the available space if the view is not removed OR changed if (params.isItemRemoved() || params.isItemChanged()) &#123; result.mIgnoreConsumed = true; &#125; result.mFocusable = view.hasFocusable();&#125; fill 所做的是通过循环获取各个子view，然后把它们add到RecyclerView上，直到屏幕空间不够或子view不够。具体做法是，先通过 Recycler.getViewForPosition()获取子view，接着调用 addView() 来把子view添加到RecyclerView 上，然后在执行子view 的 measure 流程。 getViewForPosition 怎么执行的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160View getViewForPosition(int position, boolean dryRun) &#123; return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;&#125;ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; if (position &lt; 0 || position &gt;= mState.getItemCount()) &#123; throw new IndexOutOfBoundsException(); &#125; boolean fromScrapOrHiddenOrCache = false; ViewHolder holder = null; // 0) If there is a changed scrap, try to find from there // 如果是预布局，则从 mChangedScrap 中获取 if (mState.isPreLayout()) &#123; holder = getChangedScrapViewForPosition(position); fromScrapOrHiddenOrCache = holder != null; &#125; // 1) Find by position from scrap/hidden list/cache // 根据 position 依次从 mAttachedScrap、mHiddenViews、mCachedViews 中获取 if (holder == null) &#123; holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun); if (holder != null) &#123; if (!validateViewHolderForOffsetPosition(holder)) &#123; // recycle holder (and unscrap if relevant) since it can&#x27;t be used if (!dryRun) &#123; // we would like to recycle this but need to make sure it is not used by // animation logic etc. holder.addFlags(ViewHolder.FLAG_INVALID); if (holder.isScrap()) &#123; removeDetachedView(holder.itemView, false); holder.unScrap(); &#125; else if (holder.wasReturnedFromScrap()) &#123; holder.clearReturnedFromScrapFlag(); &#125; recycleViewHolderInternal(holder); &#125; holder = null; &#125; else &#123; fromScrapOrHiddenOrCache = true; &#125; &#125; &#125; if (holder == null) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) &#123; throw new IndexOutOfBoundsException(); &#125; final int type = mAdapter.getItemViewType(offsetPosition); // 2) Find from scrap/cache via stable ids, if exists // 如果上一步没获取到，则根据id依次从 mAttachedScrap、mCachedViews 中获取 if (mAdapter.hasStableIds()) &#123; holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); if (holder != null) &#123; // update position holder.mPosition = offsetPosition; fromScrapOrHiddenOrCache = true; &#125; &#125; if (holder == null &amp;&amp; mViewCacheExtension != null) &#123; // We are NOT sending the offsetPosition because LayoutManager does not // know it. // 如果上一步没获取到，则从 mViewCacheExtension 中获取 final View view = mViewCacheExtension .getViewForPositionAndType(this, position, type); if (view != null) &#123; holder = getChildViewHolder(view); if (holder == null) &#123; throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot; + &quot; a view which does not have a ViewHolder&quot; + exceptionLabel()); &#125; else if (holder.shouldIgnore()) &#123; throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot; + &quot; a view that is ignored. You must call stopIgnoring before&quot; + &quot; returning this view.&quot; + exceptionLabel()); &#125; &#125; &#125; if (holder == null) &#123; // fallback to pool // 如果上一步没获取到，则从 RecycledViewPool 中获取 holder = getRecycledViewPool().getRecycledView(type); if (holder != null) &#123; holder.resetInternal(); if (FORCE_INVALIDATE_DISPLAY_LIST) &#123; invalidateDisplayListInt(holder); &#125; &#125; &#125; if (holder == null) &#123; long start = getNanoTime(); if (deadlineNs != FOREVER_NS &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123; // abort - we have a deadline we can&#x27;t meet return null; &#125; // 如果还没获取到，就通过 adapter 创建一个新的 holder = mAdapter.createViewHolder(RecyclerView.this, type); if (ALLOW_THREAD_GAP_WORK) &#123; // only bother finding nested RV if prefetching RecyclerView innerView = findNestedRecyclerView(holder.itemView); if (innerView != null) &#123; holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView); &#125; &#125; long end = getNanoTime(); mRecyclerPool.factorInCreateTime(type, end - start); if (DEBUG) &#123; Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&quot;); &#125; &#125; &#125; // This is very ugly but the only place we can grab this information // before the View is rebound and returned to the LayoutManager for post layout ops. // We don&#x27;t need this in pre-layout since the VH is not updated by the LM. if (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) &#123; holder.setFlags(0, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); if (mState.mRunSimpleAnimations) &#123; int changeFlags = ItemAnimator .buildAdapterChangeFlagsForAnimations(holder); changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT; final ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState, holder, changeFlags, holder.getUnmodifiedPayloads()); recordAnimationInfoIfBouncedHiddenView(holder, info); &#125; &#125; boolean bound = false; if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123; // do not update unless we absolutely have to. // 如果是预布局且holder已绑定，则设置 position 信息即可 holder.mPreLayoutPosition = position; &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; if (DEBUG &amp;&amp; holder.isRemoved()) &#123; throw new IllegalStateException(); &#125; // 否则调用 adapter 的 bindViewHolder() 来绑定数据 final int offsetPosition = mAdapterHelper.findPositionOffset(position); bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs); &#125; final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams(); final LayoutParams rvLayoutParams; // 为 子view 设置 LP，把将 VH 绑定到 LP 上 if (lp == null) &#123; rvLayoutParams = (LayoutParams) generateDefaultLayoutParams(); holder.itemView.setLayoutParams(rvLayoutParams); &#125; else if (!checkLayoutParams(lp)) &#123; rvLayoutParams = (LayoutParams) generateLayoutParams(lp); holder.itemView.setLayoutParams(rvLayoutParams); &#125; else &#123; rvLayoutParams = (LayoutParams) lp; &#125; rvLayoutParams.mViewHolder = holder; rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound; return holder;&#125; getViewForPosition 是按照一个固定的顺序来获取子view的，即：mChangedScrap -&gt; mAttachedScrap -&gt; mCachedViews -&gt; mViewCacheExtension -&gt; RecycledViewPool，如果没有可用的缓存，则通过 adapter 加载一个新的view。 获取到子view之后，如果当前处于预布局阶段，则只设置子view 的position 信息；否则就通过adapter绑定子view到数据。然后就调用addView把子view添加到RecyclerView上。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void addView(View child, int index) &#123; addViewInt(child, index, false);&#125;private void addViewInt(View child, int index, boolean disappearing) &#123; final ViewHolder holder = getChildViewHolderInt(child); if (disappearing || holder.isRemoved()) &#123; // these views will be hidden at the end of the layout pass. mRecyclerView.mViewInfoStore.addToDisappearedInLayout(holder); &#125; else &#123; // This may look like unnecessary but may happen if layout manager supports // predictive layouts and adapter removed then re-added the same item. // In this case, added version will be visible in the post layout (because add is // deferred) but RV will still bind it to the same View. // So if a View re-appears in post layout pass, remove it from disappearing list. mRecyclerView.mViewInfoStore.removeFromDisappearedInLayout(holder); &#125; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); if (holder.wasReturnedFromScrap() || holder.isScrap()) &#123; if (holder.isScrap()) &#123; holder.unScrap(); &#125; else &#123; holder.clearReturnedFromScrapFlag(); &#125; mChildHelper.attachViewToParent(child, index, child.getLayoutParams(), false); if (DISPATCH_TEMP_DETACH) &#123; ViewCompat.dispatchFinishTemporaryDetach(child); &#125; &#125; else if (child.getParent() == mRecyclerView) &#123; // it was not a scrap but a valid child // ensure in correct position int currentIndex = mChildHelper.indexOfChild(child); if (index == -1) &#123; index = mChildHelper.getChildCount(); &#125; if (currentIndex == -1) &#123; throw new IllegalStateException(); &#125; if (currentIndex != index) &#123; mRecyclerView.mLayout.moveView(currentIndex, index); &#125; &#125; else &#123; mChildHelper.addView(child, index, false); lp.mInsetsDirty = true; if (mSmoothScroller != null &amp;&amp; mSmoothScroller.isRunning()) &#123; mSmoothScroller.onChildAttachedToWindow(child); &#125; &#125; if (lp.mPendingInvalidate) &#123; holder.itemView.invalidate(); lp.mPendingInvalidate = false; &#125;&#125; LayoutManagerLayoutManager 负责测量和定位 RecyclerView 中的 item view，以及确定何时回收用户不再可见的 item view的策略。 如果 LayoutManager 指定了默认构造函数或带有签名 (Context, AttributeSet, int, int) 的构造函数，RecyclerView 将在 inflate 时实例化并设置 LayoutManager。然后可以从 getProperties(Context, AttributeSet, int, int) 获得最常用的属性。 如果 LayoutManager 指定了两个构造函数，则非默认构造函数将优先。 Adapter提供从数据集到显示在 RecyclerView 中的 View 的绑定 关键方法 onCreateViewHolder()：当 RecyclerView 需要给定类型的新 RecyclerView.ViewHolder 来表示 item 时调用。 createViewHolder()：调用 onCreateViewHolder() 创建一个新的 ViewHolder 并初始化一些私有字段以供 RecyclerView 使用。在 Recycler.tryGetViewHolderForPositionByDeadline() 中被调用。 onBindViewHolder()：被 RecyclerView 调用，显示指定 position 的数据。 此方法应更新 ViewHolder.itemView 的内容以反映给定 position 的 item。 bindViewHolder()：此方法在内部调用 onBindViewHolder() 以使用给定 position 的 item 更新 ViewHolder 内容，并设置一些供 RecyclerView 使用的私有字段。在 Recycler.tryBindViewHolderByDeadline() 中被调用。 ViewHolderViewHolder 描述 item view 和关于它在 RecyclerView 中位置的元数据。 重要方法 addFlags() isBound() isInvalid() isRecyclable() isRemoved() isScrap() isUpdated() getLayoutPosition()：根据最新的布局传递返回 ViewHolder 的 position getBindingAdapterPosition()：返回此 ViewHolder 表示的 item 相对于绑定它的 Adapter 的 Adapter position。 getAbsoluteAdapterPosition()： 相关常量： FLAG_BOUND：ViewHolder 已经绑定到一个 position；mPosition、mItemId 和 mItemViewType 均有效。 FLAG_UPDATE：ViewHolder 的 view 反映的数据是陈旧的，需要由 adapter 重新绑定。 mPosition 和 mItemId 是一致的。 FLAG_INVALID：ViewHolder 的数据无效。 mPosition 和 mItemId 隐含的标识不可信，可能不再匹配 item view 类型。 这个 ViewHolder 必须完全重新绑定到不同的数据。 FLAG_REMOVED：ViewHolder 指向代表先前从数据集中删除的item的数据。 它的view可能仍用于诸如传出动画之类的事情。 FLAG_NOT_RECYCLABLE：ViewHolder 不应该被回收。 这个标志是通过 setIsRecyclable() 设置的，目的是在动画期间保持view。 RecyclerRecycler 管理 scrapped 或 detached 的 item view 以供重用。 “scrapped” view 是仍附加到其父 RecyclerView 但已标记为 removal 或 reuse 的 view。 RecyclerView.LayoutManager 对 Recycler 的典型使用是为 adapter 的数据集获取表示给定 position 或 item ID 处数据的 view。 如果要重用的 view 被认为是“dirty”，adapter 将被要求重新绑定它。 如果不是，view 可以被 LayoutManager 快速重用，无需进一步的工作。 没有请求布局的干净 view 可以由 LayoutManager 重新定位而无需重新测量。 关键方法 tryBindViewHolderByDeadline()：尝试绑定 view，并说明相关的时间信息。 如果deadlineNs !&#x3D; FOREVER_NS，该方法可能绑定失败，返回false。 tryGetViewHolderForPositionByDeadline()：尝试从 Recycler scrap、cache、RecycledViewPool 或直接创建它来获取给定 position 的 ViewHolder。 bindViewToPosition() getViewForPosition()：获取为给定 position 初始化的 view。 LayoutManager 实现应该使用此方法来获取 view 以表示来自 Adapter 的数据。如果一个 view 可用于正确的 view 类型，则 Recycler 可以重用共享池中的 scrap or detached view。 如果 adapter 未指示给定 position 的数据已更改，则 Recycler 将尝试交回先前为该数据初始化的 scrap view 而不重新绑定。在 LayoutState.next() 中被调用。 State包含有关当前 RecyclerView 状态的有用信息，例如目标滚动 position 或 view 焦点。 State 对象还可以保存任意数据，由资源 ID 标识。 很多时候，RecyclerView 组件需要在彼此之间传递信息。 为了在组件之间提供定义良好的数据总线，RecyclerView 将相同的 State 对象传递给组件回调，这些组件可以使用它来交换数据。 如果实现自定义组件，则可以使用 State 的 put&#x2F;get&#x2F;remove 方法在组件之间传递数据，而无需管理它们的生命周期。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - 自定义View","slug":"Android-自定义View","date":"2023-02-09T06:00:32.000Z","updated":"2023-07-18T04:22:50.338Z","comments":true,"path":"2023/02/09/Android-自定义View/","link":"","permalink":"https://azxkenzo.github.io/2023/02/09/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View/","excerpt":"","text":"自定义 attribute定义自定义 attribute： 在 &lt;declare-styleable&gt; 资源元素中为 View 定义自定义 attribute。 为 XML 布局中的属性指定值。 在运行时检索属性值。 将检索到的属性值应用于 View。 要定义自定义属性，将 &lt;declare-styleable&gt; 资源添加到项目中。 通常将这些资源放入 res/values/attrs.xml 文件中。 以下是 attrs.xml 文件的示例： 123456789&lt;resources&gt; &lt;declare-styleable name=&quot;PieChart&quot;&gt; &lt;attr name=&quot;showText&quot; format=&quot;boolean&quot; /&gt; &lt;attr name=&quot;labelPosition&quot; format=&quot;enum&quot;&gt; &lt;enum name=&quot;left&quot; value=&quot;0&quot;/&gt; &lt;enum name=&quot;right&quot; value=&quot;1&quot;/&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 此代码声明了两个自定义 attribute，showText 和 labelPosition，它们属于名为 PieChart 的 styleable 的实体。按照惯例，styleable 的实体的名称与定义自定义视图的类的名称相同。 尽管不必遵循此约定，但许多流行的代码编辑器都依赖此命名约定来提供语句完成功能。 一旦定义了自定义的 attribute，就可以像使用内置 attribute 一样在布局 XML 文件中使用它们。唯一的区别是自定义 attribute 属于不同的命名空间。 它们不属于 http://schemas.android.com/apk/res/android 命名空间，而是属于 http://schemas.android.com/apk/res/[你的包名] 例如，下面是如何使用为 PieChart 定义的属性： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:custom=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;com.example.customviews.charting.PieChart custom:showText=&quot;true&quot; custom:labelPosition=&quot;left&quot; /&gt;&lt;/LinearLayout&gt; 为避免必须重复长名称空间 URI，示例使用了 xmlns 指令。 该指令将别名 custom 分配给命名空间 http://schemas.android.com/apk/res/com.example.customviews 可以为命名空间选择任何您想要的别名。 应用自定义 attribute当从 XML 布局创建 View 时，XML 标记中的所有属性都从资源包中读取并作为 AttributeSet 传递到 View 的构造函数中。虽然可以直接从 AttributeSet 中读取值，但这样做有一些缺点： 属性值中的资源引用未解析 Style 未应用 相反，将 AttributeSet 传递给 obtainStyledAttributes()。 此方法传回一个 TypedArray 数组，其中包含已取消引用和样式化的值。 Android 资源编译器做了很多工作，使调用 obtainStyledAttributes() 更容易。 对于 res/ 目录中的每个 &lt;declare-styleable&gt; 资源，生成的 R.java 定义了一个属性 ID 数组和一组常量，这些常量定义了数组中每个属性的索引。使用预定义常量从 TypedArray 中读取属性。 以下是 PieChart 类读取其属性的方式 请注意，TypedArray 对象是共享资源，使用后必须回收。 常用方法 onDraw() onMeasure() invalidate() requestLayout() onLayout() onSizeChanged() 自定义绘制onDraw() 的参数是一个 Canvas 对象，View 可以使用它来绘制自己。 Canvas 类定义了绘制文本、线条、位图和许多其他图形基元的方法。 可以在 onDraw() 中使用这些方法来创建自定义用户界面 (UI)。 创建绘图对象android.graphics 框架将绘图分为两个区域： 画什么，由 Canvas 处理 如何绘制，由 Paint 处理。 例如，Canvas 提供了一种绘制线条的方法，而 Paint 提供了定义线条颜色的方法。 Canvas 有一个绘制矩形的方法，而 Paint 定义了是用颜色填充该矩形还是将其留空。 简单来说，Canvas 定义了你可以在屏幕上绘制的形状，而 Paint 定义了你绘制的每个形状的颜色、样式、字体等。 提前创建对象是一个重要的优化。 View 重绘非常频繁，许多绘图对象需要昂贵的初始化。 在 onDraw() 方法中创建绘图对象会显着降低性能并使 UI 显得迟缓。 处理布局事件为了正确绘制自定义 View，需要知道它的大小。 复杂的自定义 View 通常需要根据屏幕上区域的大小和形状执行多个布局计算。 永远不应该对屏幕上视图的大小做出假设。 即使只有一个应用程序使用您的 View，该应用程序也需要在纵向和横向模式下处理不同的屏幕尺寸、多种屏幕密度和各种纵横比。 尽管 View 有许多处理测量的方法，但其中大部分不需要重写。 如果 View 不需要对其大小进行特殊控制，则只需重写一个方法：onSizeChanged()。 onSizeChanged() 会在 View 首次分配大小时调用，如果 View 大小因任何原因发生更改，则会再次调用。 在 onSizeChanged() 中计算与 View 大小相关的位置、尺寸和任何其他值，而不是每次绘制时都重新计算它们。 在 PieChart 示例中，onSizeChanged() 是 PieChart 视图计算饼图边界矩形以及文本标签和其他可视元素的相对位置的地方。 当 View 分配了一个大小时，布局管理器假定该大小包括 View 的所有填充。 计算 View 大小时必须处理填充值。 下面是 PieChart.onSizeChanged() 的一个片段，展示了如何做到这一点： 123456789101112// Account for paddingvar xpad = (paddingLeft + paddingRight).toFloat()val ypad = (paddingTop + paddingBottom).toFloat()// Account for the labelif (showText) xpad += textWidthval ww = w.toFloat() - xpadval hh = h.toFloat() - ypad// Figure out how big we can make the pie.val diameter = Math.min(ww, hh) 如果需要更好地控制 View 的布局参数，实现 onMeasure()。 此方法的参数是 View.MeasureSpec 值，它告诉你 View 的父级希望 View 有多大，以及该大小是硬性最大值还是只是一个建议。 作为一种优化，这些值存储为压缩整数，并且使用 View.MeasureSpec 的静态方法来解压缩存储在每个整数中的信息。 需要注意三点： 计算考虑了 View 的填充。 辅助方法 resolveSizeAndState() 用于创建最终的宽度和高度值。 此帮助器通过将 View 的所需大小与传递到 onMeasure() 的规范进行比较来返回适当的 View.MeasureSpec 值。 onMeasure() 没有返回值。 相反，该方法通过调用 setMeasuredDimension() 来传达其结果。 调用此方法是强制性的。 如果省略此调用，View 类将抛出运行时异常。 绘制一旦定义了对象创建和测量代码，就可以实现 onDraw()。 每个 View 都以不同的方式实现 onDraw()，但是大多数 View 都共享一些通用操作： 使用 drawText() 绘制文本。 通过调用 setTypeface() 指定字体，通过调用 setColor() 指定文本颜色。 使用 drawRect()、drawOval() 和 drawArc() 绘制原始形状。 通过调用 setStyle() 更改形状是填充的、轮廓的还是两者。 使用 Path 类绘制更复杂的形状。 通过向 Path 对象添加直线和曲线来定义形状，然后使用 drawPath() 绘制形状。 与原始形状一样，路径可以是轮廓线、填充线或两者，具体取决于 setStyle()。 通过创建 LinearGradient 对象来定义渐变填充。 调用 setShader() 以在填充形状上使用 LinearGradient。 使用 drawBitmap() 绘制位图。 应用 graphics effectsAndroid 12（API 级别 31）添加了 RenderEffect 类，该类将常见的图形效果（例如模糊、滤色器、Android 着色器效果等）应用于 View 对象和渲染层次结构。 效果可以组合为连锁效果（由内部和外部效果组成）或混合效果。 由于处理能力有限，不同的 Android 设备可能支持也可能不支持该功能。 Canvascanvas 可以看作是是一张无限大的画布，其绘制的中心点是默认为 View 的左上角。Canvas 上绘制的内容，只有在 View 限制范围内的才会显示在屏幕上。 裁切：一系列 clip...() 方法 绘制：一系列 draw...() 方法 变换： translate() scale() rotate() 其他： getWidth() : 返回当前绘制层的宽度 getHeight() : 返回当前绘制层的高度","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Jetpack Compose - State","slug":"Jetpack-Compose-State","date":"2022-12-07T08:42:09.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/12/07/Jetpack-Compose-State/","link":"","permalink":"https://azxkenzo.github.io/2022/12/07/Jetpack-Compose-State/","excerpt":"","text":"应用程序中的 state 是可以随时间变化的任何值。 这是一个非常宽泛的定义，涵盖了从 Room 数据库到类变量的所有内容。 State and composition**Compose 是声明式的，因此更新它的唯一方法是使用新参数调用相同的 composable**。 这些参数是 UI state 的表示。_任何时候更新 state 都会发生 recomposition_。 因此，像 TextField 这样的东西不会像在基于 XML 的命令式视图中那样自动更新。必须明确告知 composable 新 state，以便它进行相应更新。 关键术语：Composition：对 Jetpack Compose 在执行 composable 时构建的 UI 的描述。 Initial composition：通过第一次运行 composable 来创建 Composition。 Recomposition：重新运行 composable 以在数据更改时更新 Composition。 State in composableComposable 函数可以使用 remember API 将对象存储在内存中。 remember 计算出的值在 initial composition 期间存储在 Composition 中，并在 recomposition 期间返回存储的值。 remember 可用于存储可变和不可变对象。 注意：remember 将对象存储在 Composition 中，并在调用 remember 的 composable 从 Composition 中移除时忘记该对象。 mutableStateOf 创建一个可观察的 MutableState&lt;T&gt;，它是与 compose runtime 集成的可观察类型。 123interface MutableState&lt;T&gt; : State&lt;T&gt; &#123; override var value: T&#125; _对 value 的任何更改都会安排任何读取 value 的 composable 函数的 recomposition_。在 ExpandingCard 的情况下，每当 expanded 发生变化时，都会导致 ExpandingCard 重新组合。 可通过三种方式在 composable 中声明 MutableState 对象： val mutableState = remember &#123; mutableStateOf(default) &#125; var value by remember &#123; mutableStateOf(default) &#125; val (value, setValue) = remember &#123; mutableStateOf(default) &#125; 可以将 remembered value 用作其他 composable 的参数，甚至可以用作语句中的逻辑来更改显示哪些 composable。 虽然 remember 可以帮助在 recomposition 中保留状态，但在配置更改时不会保留状态。 为此，必须使用 rememberSaveable。rememberSaveable 自动保存任何可以保存在 Bundle 中的值。 对于其他值，可以传入自定义 saver 对象。 Other supported types of stateCompose 不要求使用 MutableState&lt;T&gt; 来保存状态。Compose 支持其他可观察类型。 在读取 Compose 中的另一个可观察类型之前，必须将其转换为 State&lt;T&gt; 以便 Compose 可以在状态更改时自动 recompose。 Compose 附带了从 Android 应用程序中使用的常见可观察类型创建 State&lt;T&gt; 的函数： LiveData Flow RxJava2 如果应用使用自定义可观察类，可以为 Compose 构建扩展函数以读取其他可观察类型。 有关如何执行此操作的示例，请参阅内置函数的实现。任何允许 Compose 订阅每个更改的对象都可以转换为 State&lt;T&gt; 并由 composable 对象读取。 Stateful versus stateless使用 remember 存储对象的 composable 会创建内部状态，从而使可组合项成为 stateful 的。 stateless composable 是不持有任何状态的 composable。 实现 stateless 的一种简单方法是使用 state hoisting。 在开发可重用的 composable 时，通常希望公开同一 composable 的 stateful 和 stateless 版本。 有状态版本对于不关心状态的调用者来说很方便，而无状态版本对于需要控制或提升状态的调用者来说是必需的。 State hoistingCompose 中的 State hoisting 是一种将状态移动到 composable 的调用方以使 composable 无状态的模式。Compose 中 State hoisting 的一般模式是用两个参数替换状态变量： value: T: the current value to display onValueChange: (T) -&gt; Unit: an event that requests the value to change, where T is the proposed new value 但是，不仅限于 onValueChange。 如果更具体的事件适用于 composable，应该使用 lambda 来定义它们，就像 ExpandingCard 对 onExpand 和 onCollapse 所做的那样。 以这种方式提升的状态有一些重要的属性： 单一信任源：通过移动状态而不是复制状态，确保只有一个真实来源。 这有助于避免错误。 封装：只有有状态的 composable 才能修改它们的状态。 它完全是内部的。 可共享：提升的状态可以与多个 composable 共享。 可拦截：无状态 composable 的调用者可以决定在更改状态之前忽略或修改事件。 解耦：无状态 ExpandingCard 的状态可以存储在任何地方。 例如，现在可以将 name 移动到 ViewModel 中。","categories":[],"tags":[{"name":"Compose","slug":"Compose","permalink":"https://azxkenzo.github.io/tags/Compose/"}]},{"title":"Jetpack Compose - list 和 grid","slug":"Jetpack-Compose-list-和-grid","date":"2022-12-07T06:51:57.000Z","updated":"2023-07-18T04:22:50.374Z","comments":true,"path":"2022/12/07/Jetpack-Compose-list-和-grid/","link":"","permalink":"https://azxkenzo.github.io/2022/12/07/Jetpack-Compose-list-%E5%92%8C-grid/","excerpt":"","text":"Lazy list如果需要显示大量 item（或未知长度的列表），使用 Column 等布局可能会导致性能问题，因为所有 item 都将被组合和布局，无论它们是否可见。 Compose 提供了一组组件，这些组件仅组合和布局组件视口中可见的 item。 这些组件包括 LazyColumn 和 LazyRow。 Lazy 组件与 Compose 中的大多数布局不同。 Lazy 组件提供了一个 LazyListScope.() 块，而不是接受 @Composable 内容块参数，允许应用程序直接发出 composable。这个 LazyListScope 块提供了一个 DSL，它允许应用程序描述 item 内容。 Lazy 组件然后负责根据布局和滚动位置的需要添加每个 item 的内容。 LazyListScope DSLLazyListScope 的 DSL 提供了许多用于描述布局中 item 的函数。 在最基本的情况下，item() 添加单个 item，而 items(Int) 添加多个 item： 还有许多扩展函数允许您添加 item 集合，例如 List。 还有一个名为 itemsIndexed() 的 items() 扩展函数的变体，它提供索引。 Lazy gridsLazyVerticalGrid 和 LazyHorizontalGrid composable 支持在网格中显示 item。 Lazy vertical grid 将在垂直滚动的容器中显示其项目，跨越多列，而 Lazy horizontal grid 将在水平轴上具有相同的行为。 Grid 具有与 list 相同的强大 API 功能，并且它们还使用非常相似的 DSL - LazyGridScope.() 来描述内容。 LazyVerticalGrid 中的 columns 参数和 LazyHorizontalGrid 中的 rows 参数控制单元格如何形成列或行。 以下示例显示网格中的项目，使用 GridCells.Adaptive 将每列设置为至少 128.dp 宽： LazyVerticalGrid 允许为 item 指定宽度，然后网格将适合尽可能多的列。 计算出列数后，剩余的宽度将平均分配给各列。 如果知道要使用的确切列数，则可以改为提供包含所需列数的 GridCells.Fixed 实例。 如果设计只需要某些 item 具有非标准尺寸，可以使用 grid 支持为 item 提供自定义列跨度。 使用 LazyGridScope DSL item 和 items 方法的 span 参数指定列跨度。 maxLineSpan 是跨度范围的值之一，在使用自适应调整大小时特别有用，因为列数不固定。 Content padding有时需要在内容的边缘周围添加 padding。 lazy 组件允许将一些 PaddingValues 传递给 contentPadding 参数以支持此操作： Content spacing要在 item 之间添加间距，可以使用 Arrangement.spacedBy()。 下面的示例在每个 item 之间添加了 4.dp 的空间： 网格接受垂直和水平排列： Item keys默认情况下，每个 item 的状态都根据 item 在 list 或 grid 中的位置设置键控。 但是，如果数据集发生变化，这可能会导致问题，因为改变位置的 item 实际上会丢失任何 remembered state。如果想象 LazyRow 在 LazyColumn 中的场景，如果行更改 item 位置，则用户将失去他们在 row 中的滚动位置。 为了解决这个问题，可以为每个 item 提供一个稳定且唯一的 key，为 key 参数提供一个块。 提供稳定的 key 可以使项状态在数据集更改之间保持一致： 通过提供 key，可以帮助 Compose 正确处理重新排序。 例如，如果 item 包含 remembered state，则设置 key 将允许 Compose 在其位置发生变化时将此状态与 item 一起移动。 但是，对于可以用作 item key 的类型有一个限制。 key 的类型必须得到 Bundle 的支持。 Bundle 支持原始类型、枚举或 Parceables 等类型。 Item animations如果使用过 RecyclerView 组件，就会知道它会自动为 item 更改设置动画。 lazy 布局为 item 重新排序提供了相同的功能。 API 很简单 —— 只需将 animateItemPlacement modifier 设置为 item 内容： 1234567LazyColumn &#123; items(books, key = &#123; it.id &#125;) &#123; Row(Modifier.animateItemPlacement()) &#123; // ... &#125; &#125;&#125; 如果需要，也可以提供自定义动画规范： 123456789LazyColumn &#123; items(books, key = &#123; it.id &#125;) &#123; Row(Modifier.animateItemPlacement( tween(durationMillis = 250) )) &#123; // ... &#125; &#125;&#125; 确保为 item 提供 key，以便可以找到移动元素的新位置。 除了重新排序之外，用于添加和删除的 item 动画目前正在开发中。 Sticky headers (experimental)“Sticky header”模式在显示分组数据列表时很有用。 要使用 LazyColumn 实现 Sticky header，可以使用实验性的 stickyHeader() 函数，提供标头内容： 12345678910111213@OptIn(ExperimentalFoundationApi::class)@Composablefun ListWithHeader(items: List&lt;Item&gt;) &#123; LazyColumn &#123; stickyHeader &#123; Header() &#125; items(items) &#123; item -&gt; ItemRow(item) &#125; &#125;&#125; 要实现具有多个标题的列表，可以这样做： 123456789101112131415161718// TODO: This ideally would be done in the ViewModelval grouped = contacts.groupBy &#123; it.firstName[0] &#125;@OptIn(ExperimentalFoundationApi::class)@Composablefun ContactsList(grouped: Map&lt;Char, List&lt;Contact&gt;&gt;) &#123; LazyColumn &#123; grouped.forEach &#123; (initial, contactsForInitial) -&gt; stickyHeader &#123; CharacterHeader(initial) &#125; items(contactsForInitial) &#123; contact -&gt; ContactListItem(contact) &#125; &#125; &#125;&#125; Reacting to scroll position许多应用程序需要做出反应并监听滚动位置和 item 布局的变化。 Lazy 组件通过提升 LazyListState 来支持此用例： 12345678910@Composablefun MessageList(messages: List&lt;Message&gt;) &#123; // Remember our own LazyListState val listState = rememberLazyListState() // Provide it to LazyColumn LazyColumn(state = listState) &#123; // ... &#125;&#125; 对于简单的用例，应用程序通常只需要知道第一个可见 item 的信息。 为此 LazyListState 提供了 firstVisibleItemIndex 和 firstVisibleItemScrollOffset 属性。 如果使用基于用户是否滚动过第一项来显示和隐藏按钮的示例： 123456789101112131415161718192021222324@OptIn(ExperimentalAnimationApi::class) // AnimatedVisibility@Composablefun MessageList(messages: List&lt;Message&gt;) &#123; Box &#123; val listState = rememberLazyListState() LazyColumn(state = listState) &#123; // ... &#125; // Show the button if the first visible item is past // the first item. We use a remembered derived state to // minimize unnecessary compositions val showButton by remember &#123; derivedStateOf &#123; listState.firstVisibleItemIndex &gt; 0 &#125; &#125; AnimatedVisibility(visible = showButton) &#123; ScrollToTopButton() &#125; &#125;&#125; 当需要更新其他 UI composable 时，直接在 composition 中读取状态很有用，但也存在不需要在同一组合中处理事件的情况。一个常见的例子是在用户滚动到某个点后发送一个分析事件。 为了有效地处理这个问题，可以使用 snapshotFlow()： 123456789101112131415val listState = rememberLazyListState()LazyColumn(state = listState) &#123; // ...&#125;LaunchedEffect(listState) &#123; snapshotFlow &#123; listState.firstVisibleItemIndex &#125; .map &#123; index -&gt; index &gt; 0 &#125; .distinctUntilChanged() .filter &#123; it == true &#125; .collect &#123; MyAnalyticsService.sendScrolledPastFirstItemEvent() &#125;&#125; LazyListState 还通过 layoutInfo 属性提供有关当前显示的所有 item 及其在屏幕上的边界的信息。 Controlling the scroll position除了对滚动位置做出反应外，应用程序还可以控制滚动位置。 LazyListState 通过 scrollToItem() 函数和 animateScrollToItem() 来支持这一点，scrollToItem() “立即”捕捉滚动位置，animateScrollToItem() 使用动画滚动（也称为平滑滚动） 注意： scrollToItem() 和 animateScrollToItem() 都是挂起函数，这意味着需要在协程中调用它们。 12345678910111213141516171819@Composablefun MessageList(messages: List&lt;Message&gt;) &#123; val listState = rememberLazyListState() // Remember a CoroutineScope to be able to launch val coroutineScope = rememberCoroutineScope() LazyColumn(state = listState) &#123; // ... &#125; ScrollToTopButton( onClick = &#123; coroutineScope.launch &#123; // Animate scroll to the first item listState.animateScrollToItem(index = 0) &#125; &#125; )&#125; Tips on using Lazy layoutsAvoid using 0-pixel sized items这可能发生在以下场景中，例如，希望异步检索某些数据（如图像）以在稍后阶段填充列表的 item。 这将导致 Lazy 布局在第一次测量中组合其所有 item，因为它们的高度为 0 像素并且它可以将它们全部放入视口中。一旦 item 加载完毕并且它们的高度扩大，lazy 布局就会丢弃所有其他第一次不必要地组合的 item，因为它们实际上无法适应视口。为避免这种情况，应该为 item 设置默认大小，以便 lazy 布局可以正确计算实际上有多少 item 可以适合视口： 当在异步加载数据后知道 item 的大致大小时，一个好的做法是确保 item 的大小在加载前后保持不变，例如，通过添加一些占位符。 这将有助于保持正确的滚动位置。 Avoid nesting components scrollable in the same direction这仅适用于将没有预定义大小的可滚动子项嵌套在另一个相同方向的可滚动父项中的情况。例如，尝试将一个没有固定高度的子 LazyColumn 嵌套在一个垂直滚动的 Column 父级中： 相反，可以通过将所有 composable 包装在一个父 LazyColumn 中并使用其 DSL 传递不同类型的内容来实现相同的结果。 这可以在一个地方发出单个 item 以及多个列表 item： Beware of putting multiple elements in one item在此示例中，第二项 lambda 在一个块中发出 2 个项目： 1234567891011LazyVerticalGrid( // ...) &#123; item &#123; Item(0) &#125; item &#123; Item(1) Item(2) &#125; item &#123; Item(3) &#125; // ...&#125; lazy 布局将按预期处理这一问题 —— 它们将一个接一个地布置元素，就好像它们是不同的 item 一样。 但是，这样做有几个问题。 当多个元素作为一个 item 的一部分发出时，它们将作为一个实体处理，这意味着它们不能再单独组合。 如果一个元素在屏幕上可见，则必须组合和测量与该 item 对应的所有元素。如果过度使用，这会损害性能。 在将所有元素放在一个 item 中的极端情况下，它完全违背了使用 Lazy 布局的目的。 除了潜在的性能问题外，在一项中放置更多元素也会干扰 scrollToItem() 和 animateScrollToItem()。 但是，将多个元素放在一个项目中有一些有效的用例，例如在列表中使用分隔线。 不希望分隔符更改滚动索引，因为它们不应被视为独立元素。 此外，性能不会因为分频器很小而受到影响。 当前面的项目可见时，分隔线可能需要可见，因此它们可以是前一个项目的一部分： Consider using custom arrangements通常 lazy 列表有很多 item，它们占用的空间超过滚动容器的大小。 但是，当列表中填充的 item 很少时，该设计可能会对这些 item 在视口中的定位方式有更具体的要求。 为此，可以使用自定义垂直 Arrangement 并将其传递给 LazyColumn。 在下面的例子中，TopWithFooter 对象只需要实现 arrange 方法即可。 首先，它将一个接一个地定位 item。 其次，如果总使用高度低于视口高度，它会将页脚定位在底部： 12345678910111213141516171819object TopWithFooter : Arrangement.Vertical &#123; override fun Density.arrange( totalSize: Int, sizes: IntArray, outPositions: IntArray ) &#123; var y = 0 sizes.forEachIndexed &#123; index, size -&gt; outPositions[index] = y y += size &#125; if (y &lt; totalSize) &#123; val lastIndex = outPositions.lastIndex outPositions[lastIndex] = totalSize - sizes.last() &#125; &#125;&#125; Consider adding contentType从 Compose 1.2 开始，为了最大限度地提高 Lazy 布局的性能，请考虑将 contentType 添加到列表或网格中。 这允许为布局的每个 item 指定内容类型，在正在编写由多个不同类型的项目组成的列表或网格的情况下： 当提供 contentType 时，Compose 只能在相同类型的 item 之间重用 composition。 当组合结构相似的 item 时，重用效率更高，提供内容类型可确保 Compose 不会尝试在类型 B 的完全不同的 item 之上组合类型 A 的 item。这有助于最大限度地发挥 composition 重用的好处和 lazy 布局性能。","categories":[],"tags":[{"name":"Compose","slug":"Compose","permalink":"https://azxkenzo.github.io/tags/Compose/"}]},{"title":"Kotlin - 委托","slug":"Kotlin-委托","date":"2022-12-05T08:32:25.000Z","updated":"2023-07-18T04:22:50.354Z","comments":true,"path":"2022/12/05/Kotlin-委托/","link":"","permalink":"https://azxkenzo.github.io/2022/12/05/Kotlin-%E5%A7%94%E6%89%98/","excerpt":"","text":"委托委托模式已被证明是实现继承的一个很好的替代方案，并且 Kotlin 本身就支持它，需要零样板代码。 Derived 类可以通过将其所有公共成员委托给指定对象来实现接口 Base： 1234567891011121314interface Base &#123; fun print()&#125;class BaseImpl(val x: Int) : Base &#123; override fun print() &#123; print(x) &#125;&#125;class Derived(b: Base) : Base by bfun main() &#123; val b = BaseImpl(10) Derived(b).print()&#125; Derived 的超类型列表中的 by 子句表示 b 将在内部存储在 Derived 的对象中，并且编译器将生成 Base 的所有方法转发给 b。 覆盖委托实现的接口成员但是请注意，以这种方式覆盖的成员不会从委托对象的成员中调用，委托对象只能访问其自己的接口成员实现： 123456789101112131415161718192021interface Base &#123; val message: String fun print()&#125;class BaseImpl(val x: Int) : Base &#123; override val message = &quot;BaseImpl: x = $x&quot; override fun print() &#123; println(message) &#125;&#125;class Derived(b: Base) : Base by b &#123; // This property is not accessed from b&#x27;s implementation of `print` override val message = &quot;Message of Derived&quot;&#125;fun main() &#123; val b = BaseImpl(10) val derived = Derived(b) derived.print() println(derived.message)&#125; 委托属性对于一些常见的属性，即使可以在每次需要它们时手动实现它们，但最好实现一次，将它们添加到库中，然后再使用它们。 例如： Lazy 属性：该值仅在首次访问时计算。 Observable 属性：通知侦听器有关此属性的更改。 将属性存储在 Map 中，而不是每个属性的单独字段。 为了涵盖这些（和其他）情况，Kotlin 支持委托属性： 123class Example &#123; var p: String by Delegate()&#125; 语法为：val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;。 by 后面的表达式是一个委托，因为属性对应的 get()（和 set()）会被委托给它的 getValue() 和 setValue() 方法。属性委托不必实现接口，但它们必须提供 getValue() 函数（以及用于 vars 的 setValue()）。 1234567891011import kotlin.reflect.KPropertyclass Delegate &#123; operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return &quot;$thisRef, thank you for delegating &#x27;$&#123;property.name&#125;&#x27; to me!&quot; &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; println(&quot;$value has been assigned to &#x27;$&#123;property.name&#125;&#x27; in $thisRef.&quot;) &#125;&#125; 当从 p 读取时，它委托给 Delegate 的一个实例，来自 Delegate 的 getValue() 函数被调用。 它的第一个参数是从中读取 p 的对象，第二个参数包含对 p 本身的描述（例如，可以取其名称）。 同样，当复赋值给 p 时，将调用 setValue() 函数。 前两个参数是相同的，第三个保存被赋值的值： 标准委托Kotlin 标准库为几种有用的委托提供工厂方法。 Lazy propertieslazy() 是一个接受 lambda 并返回 Lazy&lt;T&gt; 实例的函数，该实例可以用作实现惰性属性的委托。第一次调用 get() 执行传递给 lazy() 的 lambda 并记住结果。 对 get() 的后续调用仅返回记住的结果。 默认情况下，惰性属性的评估是同步的：该值仅在一个线程中计算，但所有线程将看到相同的值。如果初始化委托的同步不需要允许多个线程同时执行，请将 LazyThreadSafetyMode.PUBLICATION 作为参数传递给lazy()。 如果确定初始化将始终发生在与您使用该属性的线程相同的线程中，可以使用 LazyThreadSafetyMode.NONE。 它不会产生任何线程安全保证和相关开销。 Observable propertiesDelegates.observable() 接受两个参数：初始值和修改 handler。 每次赋值给属性时都会调用 handler（在执行分配之后）。 它具有三个参数：分配给的属性、旧值和新值： 如果想拦截分配并否决它们，请使用 vetoable() 而不是 observable()。 传递给 vetoable 的 handler 将在分配新属性值之前被调用。 委托给其他属性一个属性可以将它的 getter 和 setter 委托给另一个属性。 这种委派可用于顶层和类属性（成员和扩展）。 委托属性可以是： 要将一个属性委托给另一个属性，请在委托名称中使用 :: 限定符，例如 this::delegate 或 MyClass::delegate。 12345678910var topLevelInt: Int = 0class ClassWithDelegate(val anotherClassInt: Int)class MyClass(var memberInt: Int, val anotherClassInstance: ClassWithDelegate) &#123; var delegatedToMember: Int by this::memberInt var delegatedToTopLevel: Int by ::topLevelInt val delegatedToAnotherClass: Int by anotherClassInstance::anotherClassInt&#125;var MyClass.extDelegated: Int by ::topLevelInt 这可能很有用，例如，当想以向后兼容的方式重命名属性时：引入新属性，使用 @Deprecated 注释对旧属性进行注释，然后委托其实现。 123456789101112class MyClass &#123; var newName: Int = 0 @Deprecated(&quot;Use &#x27;newName&#x27; instead&quot;, ReplaceWith(&quot;newName&quot;)) var oldName: Int by this::newName&#125;fun main() &#123; val myClass = MyClass() // Notification: &#x27;oldName: Int&#x27; is deprecated. // Use &#x27;newName&#x27; instead myClass.oldName = 42 println(myClass.newName) // 42&#125; 把属性存储在 map 中一个常见的用例是将属性值存储在 map 中。 这经常出现在诸如解析 JSON 或执行其他动态任务之类的应用程序中。在这种情况下，可以将 map 实例本身用作委托属性的委托。 1234class User(val map: Map&lt;String, Any?&gt;) &#123; val name: String by map val age: Int by map&#125; 委托属性通过与属性名称相关联的字符串键从该映射中获取值。 局部委托属性可以把局部属性声明为委托属性 属性委托要求对于只读属性 (val)，委托应提供具有以下参数的运算符函数 getValue()： thisRef 必须与属性所有者的类型相同或超类型（对于扩展属性，它应该是被扩展的类型）。 property 必须是 KProperty&lt;*&gt; 类型或其超类型。 getValue() 必须返回与属性（或其子类型）相同的类型。 对于可变属性 (var)，委托必须另外提供一个操作函数 setValue()，并带有以下参数： thisRef 必须与属性所有者的类型相同或超类型（对于扩展属性，它应该是被扩展的类型）。 property 必须是 KProperty&lt;*&gt; 类型或其超类型。 value 必须与属性（或其超类型）具有相同的类型。 getValue() 和&#x2F;或 setValue() 函数可以作为委托类的成员函数或扩展函数提供。 当需要将属性委托给最初不提供这些功能的对象时，后者很方便。这两个函数都需要用 operator 关键字标记。 可以使用 Kotlin 标准库中的接口 ReadOnlyProperty 和 ReadWriteProperty 将委托创建为匿名对象，而无需创建新类。它们提供了所需的方法： getValue() 在 ReadOnlyProperty 中声明； ReadWriteProperty 对其进行了扩展并添加了 setValue()。这意味着可以在需要 ReadOnlyProperty 时传递 ReadWriteProperty。 委托属性的翻译规则在底层，Kotlin 编译器为某些类型的委托属性生成辅助属性，然后委托给它们。 例如，对于属性 prop，它会生成隐藏属性 prop$delegate，而访问器的代码只是简单地委托给这个附加属性： 1234567891011class C &#123; var prop: Type by MyDelegate()&#125;// this code is generated by the compiler instead:class C &#123; private val prop$delegate = MyDelegate() var prop: Type get() = prop$delegate.getValue(this, this::prop) set(value: Type) = prop$delegate.setValue(this, this::prop, value)&#125; Kotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用外部类 C 的一个实例，而 this::prop 是描述 prop 本身的 KProperty 类型的反射对象。","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://azxkenzo.github.io/tags/Kotlin/"}]},{"title":"Material 3 - Component","slug":"Material-3-Component","date":"2022-12-05T02:43:42.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/12/05/Material-3-Component/","link":"","permalink":"https://azxkenzo.github.io/2022/12/05/Material-3-Component/","excerpt":"","text":"Theming API 描述 Material Theming MaterialTheme M3 theme Color scheme ColorScheme M3 color scheme lightColorScheme M3 light color scheme darkColorScheme M3 dark color scheme Dynamic color dynamicLightColorScheme M3 dynamic light color scheme dynamicDarkColorScheme M3 dynamic dark color scheme Typography Typography M3 typography Shape Shapes M3 shape Surfaces and layout API 描述 Surfaces Surface M3 surface Scaffold Scaffold M3 layout Icons and text API 描述 Icon Icon M3 icon Text Text M3 text Components API 描述 Top app bar TopAppBar M3 small top app bar CenterAlignedTopAppBar M3 center-aligned top app bar MediumTopAppBar M3 medium top app bar LargeTopAppBar M3 large top app bar Tabs Tab M3 tab LeadingIconTab TabRow ScrollableTabRow Bottom app bar BottomAppBar Buttons Button M3 filled button ElevatedButton FilledTonalButton OutlinedButton TextButton Cards Card M3 filled card ElevatedCard OutlinedCard Text fields TextField OutlinedTextField Lists ListItem Dialogs AlertDialog Menus DropdownMenu DropdownMenuItem ExposedDropdownMenuBox Surface每个 surface 都存在于给定的高度，这会影响该 surface 与其他 surface 的视觉关联方式以及该 surface 如何通过色调变化进行修改。 Surface 负责： 裁剪：Surface 将其子项裁剪为由 shape 指定的形状 边框：如果 shape 有边框，那么它也会被绘制。 背景：Surface 用 color 填充 shape 指定的形状。 如果 color 是 ColorScheme.surface，将应用颜色叠加。 叠加层的颜色取决于此 Surface 的 tonalElevation 以及任何父 surface 设置的 LocalAbsoluteTonalElevation。 通过将所有先前 Surfaces 的高度相加，这确保了 Surfaces 永远不会出现比其祖先更低的高度覆盖。 内容颜色：Surface 使用 contentColor 为该 surface 的内容指定首选颜色 - 这被 Text 和 Icon 组件用作默认颜色。 如果未设置 contentColor，此 surface 将尝试将其背景颜色与主题 ColorScheme 中定义的颜色相匹配，并返回相应的内容颜色。 例如，如果此 surface 的 color 为 ColorScheme.surface，则 contentColor 将设置为 ColorScheme.onSurface。 如果 color 不是主题调色板的一部分，则 contentColor 将保持在此 Surface 上方设置的相同值。 ScaffoldScaffold 实现了基本的材料设计视觉布局结构。 此组件提供 API 以将多个材料组件组合在一起以构建您的屏幕，通过确保它们的正确布局策略并收集必要的数据以使这些组件正确地协同工作。","categories":[],"tags":[{"name":"Material3","slug":"Material3","permalink":"https://azxkenzo.github.io/tags/Material3/"}]},{"title":"Jetpack Compose - 架构分层","slug":"Jetpack-Compose-架构分层","date":"2022-12-05T02:13:27.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/12/05/Jetpack-Compose-架构分层/","link":"","permalink":"https://azxkenzo.github.io/2022/12/05/Jetpack-Compose-%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82/","excerpt":"","text":"层次 每一层都建立在较低的层次之上，结合功能来创建更高层次的组件。 每一层都建立在较低层的公共 API 之上，以验证模块边界并使您能够在需要时替换任何层。 让我们从下往上检查这些层。 Runtime该模块提供了 Compose 运行时的基础知识，例如 remember、mutableStateOf、@Composable 注解和 SideEffect。如果只需要 Compose 的树管理功能，而不需要它的 UI，可以考虑直接在这一层上构建。 UIUI层由多个模块（ui-text、ui-graphics、ui-tooling等）组成。 这些模块实现了 UI 工具包的基础，例如 LayoutNode、Modifier、输入处理程序、自定义布局和绘图。 如果只需要 UI 工具包的基本概念，可以考虑在此层上进行构建。 Foundation该模块为 Compose UI 提供与设计系统无关的构建块，例如 Row 和 Column、LazyColumn、特定手势的识别等。可以考虑在 Foundation 层上构建以创建自己的设计系统。 Material该模块为 Compose UI 提供了 Material Design 系统的实现，提供了主题系统、样式组件、波纹指示和图标。 在应用程序中使用 Material Design 时，构建在这一层之上。 设计原则Jetpack Compose 的指导原则是提供可以组装（或 composed）在一起的小而集中的功能片段，而不是提供几个单一的组件。 这种方法有许多优点。 Control更高级别的组件往往会为您做更多的事情，但会限制您拥有的直接控制量。 如果您需要更多控制，您可以“下拉”以使用较低级别的组件。 Customization从较小的构建块组装更高级别的组件可以更轻松地根据需要自定义组件。 例如，考虑 Material 层提供的 Button 的实现： 一个 Button 由 4 个组件组装而成： 提供背景、形状、点击处理等的 material Surface。 CompositionLocalProvider，它在启用或禁用按钮时更改内容的 alpha ProvideTextStyle 设置要使用的默认文本样式 Row 为按钮内容提供默认布局策略 像 Button 这样的组件对它们公开的参数有自己的看法，在启用常见自定义与可能使组件更难使用的参数爆炸之间取得平衡。 例如，Material 组件提供 Material Design 系统中指定的自定义功能，使遵循 Material Design 原则变得容易。 但是，如果您希望在组件参数之外进行自定义，那么您可以“下拉”一个级别并分叉一个组件。 例如，Material Design 指定按钮应具有纯色背景。 如果您需要渐变背景，则 Button 参数不支持此选项。 在这种情况下，您可以使用 Material Button 实现作为参考并构建您自己的组件： Jetpack Compose 为最高级别的组件保留了最简单的名称。 例如，androidx.compose.material.Text 是基于 androidx.compose.foundation.text.BasicText 构建的。 如果您希望替换更高级别，这可以为您自己的实现提供最容易发现的名称。 Picking the right abstractionCompose 构建分层、可重用组件的理念意味着您不应总是使用较低级别的构建块。 许多更高级别的组件不仅提供更多功能，而且经常实施最佳实践，例如支持可访问性。 例如，如果您想为您的自定义组件添加手势支持，您可以使用 Modifier.pointerInput 从头开始构建它，但还有其他构建在此之上的更高级别的组件可能提供更好的起点，例如 Modifier。 可拖动、Modifier.scrollable 或 Modifier.swipeable。 通常，更喜欢在提供所需功能的最高级别组件上构建，以便从它们包含的最佳实践中获益。","categories":[],"tags":[{"name":"Compose","slug":"Compose","permalink":"https://azxkenzo.github.io/tags/Compose/"}]},{"title":"Material 3 - Style","slug":"Material-3-Style","date":"2022-12-04T08:02:46.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/12/04/Material-3-Style/","link":"","permalink":"https://azxkenzo.github.io/2022/12/04/Material-3-Style/","excerpt":"","text":"样式是 UI 的视觉方面，赋予它独特的外观和感觉。 可以通过更改您的 Material 主题来自定义它们。 Color颜色用于表达风格和传达意义。 通过动态色彩，Material 将个人色彩偏好和个性化需求置于系统色彩应用的最前沿。 动态颜色描述了颜色系统根据不同来源和条件应用颜色的能力，例如用户的颜色设置和偏好，或从应用程序内容中派生的颜色。 M3 颜色系统和自定义方案是在应用程序中启用动态颜色的基础。 Material 提供颜色和类型的默认值作为自定义的起点。 产品可以指定其他有意义的自定义颜色（用于语义值、可访问性等）。识别自定义颜色允许团队包含和保留必要的颜色应用程序。自定义颜色会略微调整以适应用户输入的颜色，而不是完全改变。 动态颜色适用于 Material 组件和自定义组件。 在 UI 中，应用程序可以从基线方案中获取颜色；来自从用户壁纸派生方案的动态方案；或从给定范围的应用内内容的颜色派生的动态方案。 Color systemKey color &amp; tones颜色系统处理随着用户输入的变化而出现的动态变化的配色方案的可变性。 色调关系的逻辑以及色调和色度的变化为灵活的色彩应用提供了基础。 配色方案可以被认为是一组内聚的相对色调，而不是一组固定的常量值。","categories":[],"tags":[{"name":"Material3","slug":"Material3","permalink":"https://azxkenzo.github.io/tags/Material3/"}]},{"title":"Material 3 - Foundation","slug":"Material-3-Foundation","date":"2022-12-04T07:22:34.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/12/04/Material-3-Foundation/","link":"","permalink":"https://azxkenzo.github.io/2022/12/04/Material-3-Foundation/","excerpt":"","text":"Accessibility 辅助功能无障碍设计使具有不同能力的用户能够浏览、理解和享受 UI。 Overview默认情况下，Accessibility 是 Material 的基本设计值。 了解和预测广泛的人类经验和残疾可以建立产品基础，从而防止代价高昂的重新设计、减少技术和设计债务并预先节约资源。 Material 组件中内置的 Accessibility 标准旨在为包容性产品设计提供基础。 了解您的产品的 Accessibility 可以提高所有用户的可用性，包括那些有低视力、失明、听力障碍、认知障碍、运动障碍或情境障碍（例如手臂骨折）的用户。 Get started跨组件页面和指南记录了 Accessibility 要求和目标。 在组件指南中，Accessibility 标准既是隐式的（内置于设计和代码中），也是显式的（在需要判断的地方讨论注意事项。） 使用此页面作为了解材料指南中应用的 Accessibility 标准的起点，以及在整个设计和开发阶段继续检查的参考。 Accessibility 设计原则以下 Accessibility 设计原则是有助于预测、包含和响应个人需求的方法。 它们是设计、开发、协作和共同创造的考虑因素，鼓励包容和公平的结果。 Honor individuals通用的默认体验很少能满足每个人的需求。 在默认体验中引入可定制的功能为个人适应留出了空间。 尊重任何人不断变化的需求可能意味着给予更多自由来为自己选择事物 因为一个人在一天、一年或一生中的经历会不断变化，它有助于支持不同的偏好和选择，使个人能够解决他们不断变化的条件、个人知识和不同需求的满足方式。 Learn before, not after在定义解决方案之前，花时间了解具有各种能力和生活经验的用户的需求。 正式和非正式的研究可以开辟新的思维方式，减少偏见，并鼓励创造性的方式来提供访问权限，尤其是对那些不符合现行规范的人。 Accessible 设计流程尽可能多地预先预测潜在的产品或体验结果。 当设计问题出现时，对结果的探索可以作为深思熟虑地学习和恢复的研究基础。 Requirements as a starting pointWCAG 制定的最低要求支持特定的人类需求。 使用 Accessibility 标准进行设计是一个创造性的机会，可以扩展和改进改善人与技术关系的要求的应用。 历史表明，源自对特定访问需求（暗模式、文本到语音、语音到文本）的响应的功能是在指定约束内创造性地解决问题的结果。 将需求视为机遇而非约束，已被证明可以带来最终为许多人服务的解决方案。 Accessibility 基础Assistive technology 辅助技术辅助技术有助于增加、维持或改善残障人士的功能能力。 通过键盘、屏幕阅读器和盲文显示器等设备以及跟踪输入、放大镜和语音输入等技术，人们可以更独立地生活。 Layout and typographyMaterial Design 目标指南可以帮助无法看到屏幕或难以触摸小目标的用户点击应用中的元素。 Adaptive design自适应布局对来自用户、设备和屏幕元素的输入做出反应。 材料指南描述了如何针对从手机和平板电脑到台式机等各种屏幕尺寸进行设计。 定制 Material动态色彩让个人设备更具个性M3 为品牌颜色和个人颜色偏好开辟了新的可能性，以融合一种独一无二的体验。 颜色系统满足了对颜色的需求，以反映应用程序的设计敏感性，同时也尊重个人为自己选择的设置。 通过启用动态颜色，应用程序可以保留定义和区分产品的颜色，同时还可以让用户更好地控制对他们最重要的样式。 应用品牌色彩系统借助动态颜色和 M3 配色方案，您的应用程序的颜色会自动适应并与用户设置集成。 M3 支持自定义参数的系统应用，以帮助定义和维护传达您品牌的风格。 颜色系统自动处理关键调整，提供可访问的颜色对比度、易读性、交互状态和组件结构。 动态颜色也适用于自定义（非材料）组件。 Get started要利用个性化功能，您需要使用 M3 颜色系统构建自定义配色方案。 为了让您的应用尊重用户的设备和应用级设置，您将实现一个自定义主题，用户生成的配色方案可以映射到该主题。 此外，使用自定义主题可确保您的应用程序具有可供未启用动态颜色的用户使用的后备配色方案。 设置和教程动态颜色既是用户设置，也是开发人员的选择。 您可以有选择地应用动态颜色以与您的品牌配色方案一起使用。 例如，您应用中的个人资料或帐户屏幕可以反映用户的配色方案设置，从而为应用中的个人空间增添个性。 定制颜色方案Material Theme Builder 有助于创建自定义颜色体验，无论您是使用已建立的品牌参数还是尚未定义应用程序的颜色。 在 Material Theme Builder 中，您可以识别并输入一种或多种颜色来定义您的配色方案。 添加第二种或第三种颜色是可选的，并且会影响最终的配色方案。 将您的应用程序颜色映射到自定义方案的源颜色，使 M3 中动态颜色的角色和逻辑保持一致。 品牌颜色可以作为一次性颜色添加到工具中，也可以作为具有一系列色调的完整品牌调色板添加到该工具中，从而在您的应用程序中提供一致、全面的颜色表达。 如果您的应用程序使用单一品牌颜色或有限的品牌调色板，您可以输入主要品牌颜色作为自定义配色方案的源颜色。 输入颜色将用于生成一个方案，为您提供互补色调以完善方案。 Color roles根据 UI 中的用途，关键颜色被分配映射到组件中元素的角色。 具有角色分配的五个基本颜色组是： Primary Secondary Tertiary Neutral Neutral Variant 输入颜色会生成一个色调调色板，用于填充所需的颜色角色范围，例如 primary, on-primary, and primary 容器。 Design tokenstoken 存储颜色和字体等样式值，因此可以在设计、代码、工具和平台中使用相同的值。 使用设计令牌而不是硬编码值可以简化使用设计系统构建、维护和扩展产品的工作。 2021 年秋季：Material Design 现在包括颜色和排版值的系统和参考 token。 用于组件、高程和尺寸测量的其他标记正在开发中。 令牌是一种与平台无关的格式，但它们可以用于特定于平台的代码。 共有三种令牌：reference, system, and component。 Material Design 目前使用reference和system令牌； component令牌正在开发中。 令牌有助于在设计系统中保持对齐和一致性。 Interaction states状态是用于传达组件或交互元素状态的视觉指示器。 State layers状态层是元素上的半透明覆盖层，指示其状态。 状态层提供了一种通过使用不透明度来可视化状态的系统方法。 一个层可以应用到整个元素或以圆形形状应用，并且在给定时间只能应用一个状态层。 要从启用样式转换为有状态样式，需要添加状态层。 状态层是一个叠加层，每个状态具有固定的不透明度，并使用与内容相同的颜色。 例如，如果启用的样式对容器使用辅助容器颜色，对内容使用辅助容器颜色，则状态层将是使用辅助容器颜色的叠加层。 如果启用的样式对容器使用表面角色，对内容使用原色角色，则状态层将是使用原色的叠加层。 “On” colors默认情况下，组件的状态层颜色源自其内容，如果没有图标，则可以是图标的颜色或标签文本的颜色。 on color 是内容使用的颜色角色。 每个容器颜色都有自己对应的颜色。 例如，如果容器颜色是辅助容器，则内容将使用辅助容器颜色角色。 State layer tokens &amp; values状态层对每个状态使用固定百分比的不透明度。 状态层使用内容使用的颜色（通常是颜色）及其各自状态的不透明度百分比。 Selected and activated states与使用状态层的悬停、焦点、按下和拖动状态不同，使用激活或选定状态的组件会直接更改容器和内容颜色。 Disabled states当组件或元素不可交互且不应在 UI 中强调时，禁用状态会进行通信。 禁用状态在其内容和容器上使用 38%（内容）和 12%（容器）不透明度。","categories":[],"tags":[{"name":"Material3","slug":"Material3","permalink":"https://azxkenzo.github.io/tags/Material3/"}]},{"title":"Kotlin - 反射","slug":"Kotlin-反射","date":"2022-12-03T06:12:26.000Z","updated":"2023-07-18T04:22:50.378Z","comments":true,"path":"2022/12/03/Kotlin-反射/","link":"","permalink":"https://azxkenzo.github.io/2022/12/03/Kotlin-%E5%8F%8D%E5%B0%84/","excerpt":"","text":"类引用最基本的反射功能是获取对 Kotlin 类的运行时引用。 要获取对静态已知的 Kotlin 类的引用，可以使用类字面量语法： 1val c = MyClass::class 该引用是 KClass 类型值。 Kotlin 类引用与 Java 类引用不同。 要获取 Java 类引用，请在 KClass 实例上使用 .java 属性。 绑定类引用可以通过将对象用作接收者来获取对具有相同 ::class 语法的特定对象的类的引用。 Callable 引用对函数、属性和构造函数的引用也可以作为函数类型的实例来调用或使用。 所有Callable引用的公共超类型是 KCallable&lt;out R&gt;，其中 R 是返回值类型。 它是属性的属性类型，以及构造器的构造类型。 函数引用可以将函数用作函数类型值，即将它传递给另一个函数。 为此，请使用 :: 运算符： 12val numbers = listOf(1, 2, 3)println(numbers.filter(::isOdd)) 这里的 ::isOdd 是函数类型 (Int) -&gt; Boolean 的值。 函数引用属于 KFunction&lt;out R&gt; 子类型之一，具体取决于参数计数。 例如，KFunction3&lt;T1, T2, T3, R&gt;。 当从上下文中知道预期类型时，:: 可以与重载函数一起使用。 如果需要使用类的成员或者扩展函数，需要限定：String::toCharArray。 即使使用对扩展函数的引用来初始化变量，推断的函数类型也不会有接收者，但它会有一个额外的参数来接受接收者对象。 要改为使用带有接收者的函数类型，请显式指定类型. 属性引用要在 Kotlin 中将属性作为一流对象访问，请使用 :: 运算符 表达式 ::x 的计算结果为 KProperty&lt;Int&gt; 类型的属性对象。 可以使用 get() 读取其值或使用 name 属性检索属性名称。 对于可变属性，例如 var y = 1，::y 返回一个具有 KMutableProperty&lt;Int&gt; 类型的值，该类型具有 set() 方法： 可以在需要具有单个泛型参数的函数的地方使用属性引用 与 Java 反射的互操作性标准库包含反射类的扩展，这些扩展提供了与 Java 反射对象之间的映射（请参阅包 kotlin.reflect.jvm）。 例如，查找用作 Kotlin 属性的 getter 的支持字段或 Java 方法 构造器引用构造函数可以像方法和属性一样被引用。 可以在程序需要函数类型对象的任何地方使用它们，该对象采用与构造函数相同的参数并返回适当类型的对象。通过使用 :: 运算符并添加类名来引用构造函数。 考虑以下函数，它需要一个没有参数且返回类型为 Foo 的函数参数 根据参数计数，对构造函数的可调用引用被类型化为 KFunction&lt;out R&gt; 子类型之一。","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://azxkenzo.github.io/tags/Kotlin/"}]},{"title":"Kotlin - 函数","slug":"Kotlin-函数","date":"2022-11-23T09:00:55.000Z","updated":"2023-07-18T04:22:50.350Z","comments":true,"path":"2022/11/23/Kotlin-函数/","link":"","permalink":"https://azxkenzo.github.io/2022/11/23/Kotlin-%E5%87%BD%E6%95%B0/","excerpt":"","text":"参数重写方法总是使用基本方法的默认参数值。 重写具有默认参数值的方法时，必须从签名中省略默认参数值。 如果有默认值的参数在没有默认值的参数之前，则只能通过使用命名参数调用函数来使用默认值： 123456fun foo( bar: Int = 0, baz: Int,) &#123; /*...*/ &#125;foo(baz = 1) // The default value bar = 0 is used 如果默认参数之后的最后一个参数是 lambda，则可以将其作为命名参数或在括号外传递： 123456789fun foo( bar: Int = 0, baz: Int = 1, qux: () -&gt; Unit,) &#123; /*...*/ &#125;foo(1) &#123; println(&quot;hello&quot;) &#125; // Uses the default value baz = 1foo(qux = &#123; println(&quot;hello&quot;) &#125;) // Uses both default values bar = 0 and baz = 1foo &#123; println(&quot;hello&quot;) &#125; // Uses both default values bar = 0 and baz = 1 命名参数可以在调用函数时命名一个或多个函数的参数。 当在函数调用中使用命名参数时，可以自由更改它们列出的顺序。如果想使用它们的默认值，可以将这些参数完全省略。 可以使用默认值跳过特定参数，而不是全部省略。 但是，在第一个跳过的参数之后，必须命名所有后续参数。 可以使用扩展运算符传递带有名称的可变数量的参数 (vararg)： 123fun foo(vararg strings: String) &#123; /*...*/ &#125;foo(strings = *arrayOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) 在 JVM 上调用 Java 函数时，不能使用命名参数语法，因为 Java 字节码并不总是保留函数参数的名称。 返回 Unit 的函数如果一个函数没有返回有用的值，它的返回类型是 Unit。 Unit 是一种只有一个值的类型——Unit。 不必显式返回此值。 单表达式函数当函数返回单个表达式时，大括号可以省略，主体在 &#x3D; 符号之后指定。 显式返回类型具有块主体的函数必须始终明确指定返回类型，除非它们打算返回 Unit，在这种情况下指定返回类型是可选的。 Kotlin 不会为具有块主体的函数推断返回类型。 可变数量参数使用 vararg 修饰符标记函数的参数（通常是最后一个）。 只有一个参数可以标记为可变参数。 如果可变参数不是列表中的最后一个参数，则可以使用命名参数语法传递后续参数的值，或者，如果参数具有函数类型，则通过在括号外传递 lambda。 调用可变参数函数时，可以单独传递参数，例如 asList(1, 2, 3)。 如果已经有一个数组并想将其内容传递给函数，请使用展开运算符（在数组前加上 *）： 12val a = arrayOf(1, 2, 3)val list = asList(-1, 0, *a, 4) 如果要将原始类型数组传递给可变参数，则需要使用 toTypedArray() 函数将其转换为常规（类型化）数组： 12val a = intArrayOf(1, 2, 3) // IntArray is a primitive type arrayval list = asList(-1, 0, *a.toTypedArray(), 4) 中缀符号用 infix 关键字标记的函数也可以使用中缀表示法调用（省略调用的点和括号）。 中缀函数必须满足以下要求： 它们必须是成员函数或扩展函数。 它们必须有一个参数。 该参数不得接受可变数量的参数，并且必须没有默认值。 1234567infix fun Int.shl(x: Int): Int &#123; ... &#125;// calling the function using the infix notation1 shl 2// is the same as1.shl(2) 中缀函数调用的优先级低于算术运算符、类型转换和 rangeTo 运算符。 以下表达式是等效的： 1 shl 2 + 3 is equivalent to 1 shl (2 + 3) 0 until n * 2 is equivalent to 0 until (n * 2) xs union ys as Set&lt;*&gt; is equivalent to xs union (ys as Set&lt;*&gt;) 另一方面，中缀函数调用的优先级高于布尔运算符 &amp;&amp; 和 ||、is- 和 in-checks 以及其他一些运算符。 这些表达式也是等价的： a &amp;&amp; b xor c is equivalent to a &amp;&amp; (b xor c) a xor b in c is equivalent to (a xor b) in c 函数范围Kotlin 函数可以在文件的顶层声明，这意味着不需要创建一个类来保存函数。除了顶级函数，Kotlin 函数还可以在本地声明为成员函数和扩展函数。 局部函数局部函数可以访问外部函数（闭包）的局部变量。 尾递归函数Kotlin 支持一种称为尾递归的函数式编程风格。 对于一些通常会使用循环的算法，可以使用递归函数来代替，而不会出现堆栈溢出的风险。当一个函数被标记为 tailrec 修饰符并满足所需的形式条件时，编译器会优化递归，留下一个快速高效的基于循环的版本： 1234val eps = 1E-10 // &quot;good enough&quot;, could be 10^-15tailrec fun findFixPoint(x: Double = 1.0): Double = if (Math.abs(x - Math.cos(x)) &lt; eps) x else findFixPoint(Math.cos(x)) 此代码计算余弦的定点，余弦是一个数学常数。 它只是从 1.0 开始重复调用 Math.cos，直到结果不再改变，针对指定的 eps 精度产生 0.7390851332151611 的结果。 生成的代码等同于这种更传统的风格： 12345678910val eps = 1E-10 // &quot;good enough&quot;, could be 10^-15private fun findFixPoint(): Double &#123; var x = 1.0 while (true) &#123; val y = Math.cos(x) if (Math.abs(x - y) &lt; eps) return x x = Math.cos(x) &#125;&#125; 要符合 tailrec 修饰符的条件，函数必须在执行的最后一个操作时调用自身。 当在递归调用之后、在 try&#x2F;catch&#x2F;finally 块内或在打开的函数上有更多代码时，不能使用尾递归。 高阶函数和 lambda函数类型Kotlin 使用函数类型，例如 (Int) -&gt; String，用于处理函数的声明：val onClick: () -&gt; Unit = .... 。 这些类型有一个特殊的符号，对应于函数的签名——它们的参数和返回值： 所有函数类型都有一个带括号的参数类型列表和一个返回类型：(A, B) -&gt; C 表示一种类型，该类型表示接受两个类型 A 和 B 的参数并返回类型 C 的值的函数。参数列表 types 可以为空，如 () -&gt; A。Unit 返回类型不能省略。 函数类型可以选择有一个额外的接收者类型，它在符号中的点之前指定：类型 A.(B) -&gt; C 表示可以在接收者对象 A 上调用带有参数 B 并返回值 C 的函数 . 带有接收者的函数字面量通常与这些类型一起使用。 挂起函数属于一种特殊的函数类型，在其符号中带有挂起修饰符，例如suspend () -&gt; Unit 或suspend A.(B) -&gt; C。 函数类型符号可以选择性地包含函数参数的名称：(x: Int, y: Int) -&gt; Point。 这些名称可用于记录参数的含义。 要指定函数类型可为空，请使用括号，如下所示：((Int, Int) -&gt; Int)? 。 也可以使用括号组合函数类型：(Int) -&gt; ((Int) -&gt; Unit)。 箭头符号是右结合的，(Int) -&gt; (Int) -&gt; Unit 等同于前面的示例，但不是 ((Int) -&gt; (Int)) -&gt; Unit。 还可以使用类型别名为函数类型指定一个替代名称：typealias ClickHandler = (Button, ClickEvent) -&gt; Unit 实例化函数类型有几种方法可以获取函数类型的实例： 在函数字面量中使用代码块，采用以下形式之一： lambda 表达式：&#123; a, b -&gt; a + b &#125; 匿名函数：fun(s: String): Int &#123; return s.toIntOrNull() ?: 0 &#125; 使用对现有声明的 callable 引用： 顶层、局部、成员或扩展函数: ::isOdd, String::toInt, 顶层、成员或扩展属性: List&lt;Int&gt;::size, 构造器: ::Regex 使用实现函数类型的自定义类的实例作为接口：12345class IntTransformer: (Int) -&gt; Int &#123; override operator fun invoke(x: Int): Int = TODO()&#125;val intFunction: (Int) -&gt; Int = IntTransformer() 带接收者和不带接收者的函数类型的非字面量值是可以互换的，因此接收者可以代表第一个参数，反之亦然。 例如，类型为 (A, B) -&gt; C 的值可以传递或分配给类型为 A.(B) -&gt; C 的值，反之亦然. 调用函数类型实例可以使用其 invoke(...) 运算符调用函数类型的值：f.invoke(x) 或仅 f(x)。 如果该值具有接收者类型，则接收者对象应作为第一个参数传递。 另一种调用带有接收者的函数类型的值的方法是在它前面加上接收者对象，就好像该值是一个扩展函数：1.foo(2)。 lambda 表达式和匿名函数Lambda 表达式和匿名函数是函数字面量。 函数字面量是未声明但作为表达式立即传递的函数。 lambda 表达式语法 lambda 表达式总是被大括号括起来。 完整句法形式的参数声明放在大括号内，并具有可选的类型注释。 主体在 -&gt; 之后。 如果 lambda 的推断返回类型不是 Unit，则 lambda 主体内的最后一个（或可能是单个）表达式将被视为返回值。 传递尾随 lambda根据 Kotlin 约定，如果函数的最后一个参数是一个函数，那么作为相应参数传递的 lambda 表达式可以放在括号外 如果 lambda 是该调用中的唯一参数，则可以完全省略括号 内联函数使用高阶函数会带来一定的运行时惩罚：每个函数都是一个对象，并且它捕获一个闭包。 闭包是可以在函数体中访问的变量范围。内存分配（包括函数对象和类）和虚拟调用会引入运行时开销。 inline 修饰符影响函数本身和传递给它的 lambda：所有这些都将内联到调用站点。 非内联如果不希望所有传递给内联函数的 lambda 都被内联，使用 noinline 修饰符标记那些函数参数。 可内联 lambda 只能在内联函数内部调用或作为可内联参数传递。 然而，noinline lambda 可以按照任何方式进行操作，包括存储在字段中或传递。 非局部返回在 Kotlin 中，只能使用普通的、无限定的 return 来退出命名函数或匿名函数。 要退出 lambda，请使用标签。 在 lambda 中禁止直接 return，因为 lambda 不能使封闭函数返回。 但是如果 lambda 传递给的函数是内联的，那么返回值也可以是内联的。 此类return（位于 lambda 中，但退出封闭函数）称为非局部返回。 这种结构通常发生在循环中，内联函数通常包含在循环中 请注意，一些内联函数可能会调用作为参数传递给它们的 lambda 表达式，而不是直接从函数体中调用，而是从另一个执行上下文调用，例如局部对象或嵌套函数。在这种情况下，lambda 中也不允许使用非本地控制流。 要指示内联函数的 lambda 参数不能使用非本地返回，请使用 crossinline 修饰符标记 lambda 参数. 123456inline fun f(crossinline body: () -&gt; Unit) &#123; val f = object: Runnable &#123; override fun run() = body() &#125; // ...&#125;","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://azxkenzo.github.io/tags/Kotlin/"}]},{"title":"Kotlin - 控制流","slug":"Kotlin-控制流","date":"2022-11-17T04:26:18.000Z","updated":"2023-07-18T04:22:50.358Z","comments":true,"path":"2022/11/17/Kotlin-控制流/","link":"","permalink":"https://azxkenzo.github.io/2022/11/17/Kotlin-%E6%8E%A7%E5%88%B6%E6%B5%81/","excerpt":"","text":"条件和循环if 表达式在 Kotlin 中，if 是一个表达式：它返回一个值。 因此，没有三元运算符（条件？那么：else），因为普通的 if 在这个角色中可以正常工作。 if 表达式的分支可以是块。 在这种情况下，最后一个表达式是块的值。 如果使用 if 作为表达式，例如，返回其值或将其分配给变量，则 else 分支是强制性的。 when 表达式when 定义具有多个分支的条件表达式。 它类似于类 C 语言中的 switch 语句。 when 按顺序将其参数与所有分支匹配，直到满足某个分支条件。 when 既可以用作表达式，也可以用作语句。 如果用作表达式，则第一个匹配分支的值成为整个表达式的值。 如果将其用作语句，则忽略各个分支的值。 就像 if 一样，每个分支都可以是一个块，它的值是块中最后一个表达式的值。 如果 when 用作表达式，则 else 分支是强制性的，除非编译器可以证明所有可能的情况都被分支条件覆盖，例如，枚举类条目和密封类子类型）。 在 when 语句中，else 分支在以下情况下是强制性的： when 有一个布尔型、枚举型或密封类型的主题，或其可为空的对应物。 when 的分支并未涵盖该主题的所有可能情况。 要为多种情况定义共同行为，请将它们的条件用逗号组合在一行中。 可以使用任意表达式（不仅是常量）作为分支条件。 还可以检查一个值是否在一个范围或一个集合中或！。 另一种选择是检查一个值是或！是特定类型。 请注意，由于智能转换，可以访问类型的方法和属性而无需任何额外检查。 when 也可以用作 if-else if 链的替代品。 如果没有提供参数，则分支条件只是布尔表达式，当条件为真时执行分支。 可以使用以下语法在变量中捕获主题： 12345fun Request.getBody() = when (val response = executeRequest()) &#123; is Success -&gt; response.body is HttpError -&gt; throw HttpException(response.status) &#125; for 循环for 循环遍历任何提供迭代器的东西。 1for (item in collection) print(item) for 遍历任何提供迭代器的东西。 这意味着它： 有一个返回 Iterator&lt;&gt; 的成员或扩展函数 iterator(): 有一个成员或扩展函数 next() 有一个返回布尔值的成员或扩展函数 hasNext() 所有这三个函数都需要标记为 operator。 range 或数组上的 for 循环被编译为不创建迭代器对象的基于索引的循环。 如果想遍历一个带有索引的数组或列表，可以这样做： 123for (i in array.indices) &#123; println(array[i])&#125; 或者，可以使用 withIndex 库函数： 123for ((index, value) in array.withIndex()) &#123; println(&quot;the element at $index is $value&quot;)&#125; while 循环while 和 do-while 循环在满足条件时连续执行它们的主体。 return 和 跳转Kotlin 有三种结构跳转表达式： return 默认情况下从最近的封闭函数或匿名函数返回。 break 终止最近的封闭循环。 continue 进入最近的封闭循环的下一步。 所有这些表达式都可以用作更大表达式的一部分： 1val s = person.name ?: return 这些表达式的类型是 Nothing 类型。 Break 和 continue 到 labelsKotlin 中的任何表达式都可以用标签进行标记。 标签的形式为标识符后跟 @ 符号，例如 abc@ 或 fooBar@。 要标记表达式，只需在其前面添加一个标签。 12345loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (...) break@loop &#125;&#125; Return to label在 Kotlin 中，可以使用函数字面量、局部函数和对象表达式来嵌套函数。 合格的 return 允许从外部函数返回。 最重要的用例是从 lambda 表达式返回。 1234567fun foo() &#123; listOf(1, 2, 3, 4, 5).forEach &#123; if (it == 3) return // non-local return directly to the caller of foo() print(it) &#125; println(&quot;this point is unreachable&quot;)&#125; 注意，只有传递给内联函数的 lambda 表达式才支持此类非本地返回。 要从 lambda 表达式返回，请将其标记并限定返回： 1234567fun foo() &#123; listOf(1, 2, 3, 4, 5).forEach lit@&#123; if (it == 3) return@lit // local return to the caller of the lambda - the forEach loop print(it) &#125; print(&quot; done with explicit label&quot;)&#125; 通常使用隐式标签更方便，因为这样的标签与传递 lambda 的函数具有相同的名称。 1234567fun foo() &#123; listOf(1, 2, 3, 4, 5).forEach &#123; if (it == 3) return@forEach // local return to the caller of the lambda - the forEach loop print(it) &#125; print(&quot; done with implicit label&quot;)&#125; 或者，可以将 lambda 表达式替换为匿名函数。 匿名函数中的 return 语句将从匿名函数本身返回。 请注意，在前面三个示例中使用本地返回类似于在常规循环中使用 continue。 break 没有直接的等价物，但可以通过添加另一个嵌套 lambda 并从其非本地返回来模拟它： 123456789fun foo() &#123; run loop@&#123; listOf(1, 2, 3, 4, 5).forEach &#123; if (it == 3) return@loop // non-local return from the lambda passed to run print(it) &#125; &#125; print(&quot; done with nested loop&quot;)&#125; 当返回值时，解析器优先考虑合格的返回： 1return@a 1 这意味着“在标签 @a 处返回 1”，而不是“返回标签表达式 (@a 1)”。 异常Kotlin 中的所有异常类都继承了 Throwable 类。 每个异常都有一条消息、一个堆栈跟踪和一个可选的原因。 使用 throw 表达式抛出一个异常对象。使用 try catch 捕获异常。 try 是一个表达式try 是一个表达式，这意味着它可以有一个返回值try 表达式的返回值要么是 try 块中的最后一个表达式，要么是 catch 块中的最后一个表达式。 finally 块的内容不影响表达式的结果。 Checked exceptionKotlin does not have checked exceptions. 如果想在从 Java、Swift 或 Objective-C 调用 Kotlin 代码时提醒调用者可能出现的异常，可以使用 @Throws 注释。 Nothing 类型throw 是 Kotlin 中的一个表达式，因此可以使用它，例如，作为 Elvis 表达式的一部分： 1val s = person.name ?: throw IllegalArgumentException(&quot;Name required&quot;) throw 表达式的类型为 Nothing。 此类型没有值，用于标记永远无法到达的代码位置。 在自己的代码中，可以使用 Nothing 来标记永远不会返回的函数。 当调用这个函数时，编译器会知道在调用之后执行不会继续。 12val s = person.name ?: fail(&quot;Name required&quot;)println(s) // &#x27;s&#x27; is known to be initialized at this point 在处理类型推断时，也可能会遇到这种类型。 这种类型的可空变体 Nothing? 恰好有一个可能的值，即 null。如果使用 null 来初始化推断类型的值，并且没有其他信息可用于确定更具体的类型，编译器将推断 Nothing? 类型： 12val x = null // &#x27;x&#x27; has type `Nothing?`val l = listOf(null) // &#x27;l&#x27; has type `List&lt;Nothing?&gt;","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://azxkenzo.github.io/tags/Kotlin/"}]},{"title":"Kotlin - 类型","slug":"Kotlin-类型","date":"2022-11-17T03:01:29.000Z","updated":"2023-07-18T04:22:50.338Z","comments":true,"path":"2022/11/17/Kotlin-类型/","link":"","permalink":"https://azxkenzo.github.io/2022/11/17/Kotlin-%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"数字Kotlin 提供了一组内建类型来表示数字。 整型类型对于整型数字，有四种类型，它们有不同的大小和取值范围： Byte 8bits -128～127 Short 16bits -32768～32767 Int 32bits Long 64bits 当初始化一个没有明确制定类型的变量时，编译器会自动推断具有足以表示该值的最小范围的类型。如果不超过 Int 的范围，则类型为 Int。如果超过，则类型为 Long。要明确指定 Long 值，需要将后缀 L 附加到该值。显式指定类型会触发编译器检查值不超过指定类型的范围。 浮点型类型对于实数，Kotlin 提供符合 IEEE 754 标准的浮点类型 Float 和 Double。 类型 大小 有效位 指数位 Float 32 24 8 Double 64 53 11 使用具有小数部分的数字初始化 Double 和 Float 变量。对于用小数初始化的变量，编译器会推断出 Double 类型。 要显式指定值的 Float 类型，需要添加后缀 f 或 F。如果此类值包含超过 6-7 个十进制数字，则将对其进行四舍五入。 与其他一些语言不同，Kotlin 中没有隐式的数字扩展转换。 例如，具有 Double 参数的函数只能在 Double 值上调用，而不能在 Float、Int 或其他数值上调用。 数字的字面量常量整数值有以下几种字面量常量： 十进制：123 &#x2F; 123L 十六进制：0x0F 二进制：0b00001011 Kotlin 不支持八进制字面量。 Kotlin 还支持浮点数的传统表示法： Double：123.5, 123.5e10 Float：123.5f &#x2F; 123.5F 可以使用下划线使数字常量更具可读性： 12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 JVM 上的数字表示在 JVM 平台上，数字存储为原始类型：int、double 等。 例外情况是创建可为空的数字引用（例如 Int? 或使用泛型。 在这些情况下，数字被装在 Java 类 Integer、Double 等中。 12345678910val a: Int = 100val boxedA: Int? = aval anotherBoxedA: Int? = aval b: Int = 10000val boxedB: Int? = bval anotherBoxedB: Int? = bprintln(boxedA === anotherBoxedA) // trueprintln(boxedB === anotherBoxedB) // false 由于 JVM 对 -128 到 127 之间的整数进行了内存优化，所有对 a 的可空引用实际上都是同一个对象。它不适用于 b 引用，因此它们是不同的对象。 显式数字转换由于表示方式不同，较小的类型不是较大类型的子类型。如果是这样，将遇到以下问题： 1234// Hypothetical code, does not actually compile:val a: Int? = 1 // A boxed Int (java.lang.Integer)val b: Long? = a // Implicit conversion yields a boxed Long (java.lang.Long)print(b == a) // Surprise! This prints &quot;false&quot; as Long&#x27;s equals() checks whether the other is Long as well 因此，较小的类型不会隐式转换为较大的类型。 这意味着将 Byte 类型的值分配给 Int 变量需要显式转换。 在许多情况下，不需要显式转换，因为类型是从上下文中推断出来的，并且算术运算会为适当的转换而重载，例如: 1val l = 1L + 3 // Long + Int =&gt; Long 数字运算整数除法整数之间的除法总是返回一个整数。 任何小数部分都将被丢弃。 123val x = 5 / 2//println(x == 2.5) // ERROR: Operator &#x27;==&#x27; cannot be applied to &#x27;Int&#x27; and &#x27;Double&#x27;println(x == 2) 要返回浮点类型，需要将其中一个参数显式转换为浮点类型。 位运算Kotlin 提供了一组对整数的按位运算。 它们直接使用数字表示的位在二进制级别上进行操作。 按位运算由可以以中缀形式调用的函数表示。 它们只能应用于 Int 和 Long： 1val x = (1 shl 2) and 0x000FF000 位运算的完整列表： Kotlin 含义 Java shl 有符号左移 &lt;&lt; shr 有符号右移 ‘&gt;&gt;’ ushr 无符号右移 ‘&gt;&gt;&gt;’ and 位与 &amp; or 位或 l xor 位异或 ^ inv 位反转 ~ 浮点型数字比较这里讨论的浮点数运算是： Equality checks: a &#x3D;&#x3D; b and a !&#x3D; b Comparison operators: a &lt; b, a &gt; b, a &lt;&#x3D; b, a &gt;&#x3D; b Range instantiation and range checks: a..b, x in a..b, x !in a..b 当操作数 a 和 b 静态已知为 Float 或 Double 或其可为空的对应物（类型已声明或推断或是智能转换的结果）时，对数字的操作和它们形成的范围遵循 IEEE 754 浮点算术标准。 但是，为了支持通用用例并提供总排序，当操作数不是静态类型为浮点数（例如，Any、Comparable&lt;…&gt;、类型参数）时，操作使用 equals 和 compareTo 实现 Float 和 Double 不符合标准，因此： NaN 被认为等于它自己 NaN 被认为大于任何其他元素，包括 POSITIVE_INFINITY -0.0 被认为小于 0.0 布尔型Boolean 类型表示可以有两个值的布尔对象：true 和 false。 布尔值的内置操作包括：|| &#x2F; &amp;&amp; &#x2F; ! || 和 &amp;&amp; 是懒惰执行的。 在 JVM 上：对布尔对象的可为空引用与数字类似地被装箱。 字符字符由 Char 类型表示。 字符字面量放在单引号中：’1’。 特殊字符从转义的反斜杠 \\ 开始。 支持以下转义序列： \\t – tab \\b – backspace \\n – new line (LF) \\r – carriage return (CR) &#39; – single quotation mark &quot; – double quotation mark \\ – backslash $ – dollar sign 要编码任何其他字符，请使用 Unicode 转义序列语法：’\\uFF00’。 如果字符变量的值是数字，则可以使用 digitToInt() 函数将其显式转换为 Int 数字。 在 JVM 上：与数字一样，当需要可空引用时，字符会被装箱。 装箱操作不保留身份。 字符串Kotlin 中的字符串由 String 类型表示。 通常，字符串值是双引号 (“) 中的字符序列。 字符串的元素是可以通过索引操作访问的字符：s[i]。 可以使用 for 循环遍历这些字符。 字符串是不可变的。 初始化字符串后，将无法更改其值或为其分配新值。 所有转换字符串的操作都在一个新的 String 对象中返回它们的结果，而原始字符串保持不变。 要连接字符串，使用 + 运算符。 这也适用于将字符串与其他类型的值连接，只要表达式中的第一个元素是字符串。 字符串字面量Kotlin 有两种类型的字符串字面量： 转义字符串 原始字符串 转义字符串转义字符串可以包含转义字符。 1val s = &quot;Hello, world!\\n&quot; 原始字符串原始字符串可以包含换行符和任意文本。 它由三引号 (“””) 分隔，不包含转义，并且可以包含换行符和任何其他字符： 1234val text = &quot;&quot;&quot; for (c in &quot;foo&quot;) print(c)&quot;&quot;&quot; 要从原始字符串中删除前导空格，使用 trimMargin() 函数。 默认情况下，管道符号 | 用作边距前缀，但可以选择另一个字符并将其作为参数传递，例如 trimMargin(“&gt;”)。 字符串模版字符串文字可能包含模板表达式——被评估的代码片段，其结果被连接到字符串中。 模板表达式以美元符号 ($) 开头，由以下任一名称组成。 可以在原始字符串和转义字符串中使用模板。 要在允许作为标识符开头的任何符号之前在原始字符串（不支持反斜杠转义）中插入美元符号 $，请使用以下语法： 123val price = &quot;&quot;&quot;$&#123;&#x27;$&#x27;&#125;_9.99&quot;&quot;&quot; 数组Kotlin 中的数组由 Array 类表示。 它具有 get() 和 set() 函数，这些函数通过运算符重载约定变成 [] 和 size 属性，以及其他有用的成员函数： 12345678class Array&lt;T&gt; private constructor() &#123; val size: Int operator fun get(index: Int): T operator fun set(index: Int, value: T): Unit operator fun iterator(): Iterator&lt;T&gt; // ...&#125; 要创建一个数组，请使用函数 arrayOf() 并将项目值传递给它，以便 arrayOf(1, 2, 3) 创建一个数组 [1, 2, 3]。 或者，arrayOfNulls() 函数可用于创建一个给定大小的数组，其中填充了空元素。 另一种选择是使用 Array 构造函数，该构造函数采用数组大小和返回给定索引的数组元素值的函数。 Kotlin 中的数组是不变的。 这意味着 Kotlin 不允许将 Array 分配给 Array，这可以防止可能的运行时故障（但可以使用 Array）。 原始类型数组Kotlin 还具有表示基本类型数组而无需装箱开销的类：ByteArray、ShortArray、IntArray 等。 这些类与 Array 类没有继承关系，但它们具有相同的方法和属性集。 它们中的每一个也都有对应的工厂函数。 无符号整型类型除了整数类型，Kotlin 还为无符号整数提供了以下类型： UByte: an unsigned 8-bit integer, ranges from 0 to 255 UShort: an unsigned 16-bit integer, ranges from 0 to 65535 UInt: an unsigned 32-bit integer, ranges from 0 to 2^32 - 1 ULong: an unsigned 64-bit integer, ranges from 0 to 2^64 - 1 无符号类型支持其有符号对应对象的大部分操作。 无符号数字被实现为内联类，具有相同宽度的相应有符号对应类型的单个存储属性。 然而，将类型从无符号类型更改为有符号对应（反之亦然）是二进制不兼容的更改。 无符号数组和区间无符号数组和对它们的操作处于测试阶段。 它们可以随时进行不兼容的更改。 需要选择加入。 与原始类型相同，每个无符号类型都有对应的类型，表示该类型的数组： UByteArray: an array of unsigned bytes UShortArray: an array of unsigned shorts UIntArray: an array of unsigned ints ULongArray: an array of unsigned longs UIntRange、UIntProgression、ULongRange 和 ULongProgression 类支持 UInt 和 ULong 的 range 和级数。 与无符号整数类型一起，这些类是稳定的。 无符号整型字面量为了使无符号整数更易于使用，Kotlin 提供了使用表示特定无符号类型的后缀标记整数文字的功能（类似于 Float 或 Long）： u 和 U 标记用于无符号文字。 确切的类型是根据预期的类型确定的。 如果没有提供预期的类型，编译器将根据文字的大小使用 UInt 或 ULong： uL 和 UL 将文字显式标记为 unsigned long： 使用案例无符号数的主要用例是利用整数的整个位范围来表示正值。例如，要表示不适合有符号类型的十六进制常量，例如 32 位 AARRGGBB 格式的颜色： 123data class Color(val representation: UInt)val yellow = Color(0xFFCC00CCu) 可以使用无符号数来初始化字节数组，而无需显式 toByte() 字面量转换： 1val byteOrderMarkUtf8 = ubyteArrayOf(0xEFu, 0xBBu, 0xBFu) 另一个用例是与native API 的互操作性。 Kotlin 允许表示在签名中包含无符号类型的 native 声明。 映射不会用有符号整数替换无符号整数，保持语义不变。 类型检查和转换is 和 !is 操作符使用 is 运算符或其否定形式 !is 执行运行时检查，以识别对象是否符合给定类型。 智能转换在大多数情况下，不需要在 Kotlin 中使用显式转换运算符，因为编译器会跟踪不可变值的 is 检查和显式转换，并在必要时自动插入（安全）转换。 编译器足够聪明，知道如果否定检查导致返回，则强制转换是安全的： 123if (x !is String) returnprint(x.length) // x is automatically cast to String 或者如果它在 &amp;&amp; 或 || 的右侧 正确的检查（常规或否定）在左侧。 智能转换也适用于 when 表达式和 while 循环。 需要注意的是，只有当编译器可以保证变量在检查和使用之间不会改变时，智能转换才起作用。 更具体地说，智能转换可以在以下条件下使用： val local variables - always, with the exception of local delegated properties. val properties - 如果属性是 private 或 internal，或者检查是在声明属性的同一模块中执行的。 智能转换不能用于 open 属性或具有自定义 getter 的属性。 var local variables - if the variable is not modified between the check and the usage, is not captured in a lambda that modifies it, and is not a local delegated property. var properties - never, because the variable can be modified at any time by other code. 不安全的转换操作符通常，如果无法进行强制转换，则强制转换运算符会引发异常。 因此，它被称为不安全。 Kotlin 中的不安全强制转换由中缀运算符 as 完成。 注意，不能将 null 强制转换为 String，因为此类型不可为 null。 如果 y 为 null，则上面的代码将引发异常。 要使这样的代码对空值正确，请使用强制转换右侧的可为空类型。 安全(可空)的转换操作符为避免异常，请使用安全转换运算符 as?，它在失败时返回 null。","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://azxkenzo.github.io/tags/Kotlin/"}]},{"title":"计算机系统","slug":"计算机系统","date":"2022-11-13T09:52:09.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/11/13/计算机系统/","link":"","permalink":"https://azxkenzo.github.io/2022/11/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"为了在系统上运行 C 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打包好，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。 在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的。编译器驱动程序读取源程序文件，并把它翻译成一个可执行目标文件。这个翻译过程可分为四个阶段。执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统。 预处理阶段。预处理器根据以字符 # 开头的命令，修改原始的 C 程序。比如 #include &lt;studio.h&gt; 命令告诉预处理器读取系统头文件 studio.h 的内容，并把它直接插入到程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。 编译阶段。编译器将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。该程序包含函数 main 的定义，定义中的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言为不同高级语言的不同编译器提供了通用的输出语言。 汇编阶段。汇编器将 hello.s 翻译成机器语言指令，并把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它包含的字节是函数main的指令编码。 链接阶段。hello 程序调用了 printf 函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到hello.o 程序中。链接器就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件（简称为可执行文件），可以被加载到内存中，由系统执行。 有一些重要的原因促使我们必须知道编译系统是如何工作的： 优化程序性能。现代编译器都是成熟的工具，通常可以生成很好的代码。但是，为了在 C 程序中做出好的编码选择，需要了解一些机器代码以及编译器将不同 C 语句转化为机器代码的方式。比如，一个 switch 语句是否总是比一系列的 if-else 语句高效得多？一个函数调用的开销有多大？while 循环比 for 循环更有效吗？指针引用比数组索引更有效吗？为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多？ 理解链接时出现的错误。一些最令人困扰的程序错误往往都与链接器操作有关。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？ 避免安全漏洞。缓冲区溢出错误是造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有人能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。 Unix 中的 shell 是一个命令行解释器，它输出一个字符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。 了解一个典型的系统的硬件组织： 总线贯穿整个系统的是一组电子管道，称为总线。，它携带信息字节并负责在各个部件间传递。通常总线被设计为传送定长的字节块，也就是字（word）。字中字节数（即字长）是一个基本的系统参数。现在大多数机器字长要么是4个字节，要么是8个字节。 I&#x2F;O 设备I&#x2F;O（输入&#x2F;输出）设备是系统与外部世界的联系通道。每个 I&#x2F;O 设备都通过一个控制器或适配器与 I&#x2F;O 总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是 I&#x2F;O 设备本身或者系统的主印制电路板（主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。它们的功能都是在 I&#x2F;O 总线和 I&#x2F;O 设备之间传递信息。 主存主存是一个临时存储设备。在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。 处理器处理器是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令。这样的简单操作并不多，它们围绕着主存、寄存器文件和算术&#x2F;逻辑单元（ALU）进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU 计算新的数据和地址值。CPU 在指令的要求下可能会执行这些操作： 加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容 存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置原来的内容 操作：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容 跳转：从指令本身中抽取一个字，并将这个字复制到 PC 中，以覆盖 PC 中原来的值 指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。 运行hello程序时发生了什么： 在键盘上输入”.&#x2F;hello”后，shell 程序将字符逐一读入寄存器，再把它存放到内存中。 敲回车键后，shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。 一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的main程序中的机器语言指令。这些指令将”hello，world”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备。 这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。这些复制就是开销，减慢了程序真正的工作。因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。 操作系统有两个基本功能： 防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。 操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对 I&#x2F;O 设备的抽象表示，虚拟内存是对主存和磁盘 I&#x2F;O 设备的抽象表示，进程则是对处理器、主存和 I&#x2F;O 设备的抽象表示。 20世纪80年代中期，Unix 厂商试图通过加入新的、往往不兼容的特性来使他们的程序与众不同，麻烦也就随之而来。为了阻止这种趋势，IEEE 开始努力标准化 Unix 开发，后来由 Richard 命名为”Posix”。结果就得到来一系列的标准，称作 Posix 标准。这套标准涵盖了很多方面，比如 Unix 系统调用的 C 语言接口、shell 程序和工具、线程及网络编程。最近，一个被称为”标准Unix规范”的独立标准化工作已经与 Posix 一起创建了统一的 Unix 系统标准。 进程程序在现代系统上运行时，操作系统会提供一个假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和 I&#x2F;O 设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的。 进程是操作系统对一个正在运行的程序的一种抽象。并发运行，是说一个进程的指令和另一个进程的指令是交错运行的。一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。 操作系统保持跟踪进程运行所需要的所有状态信息。这种状态，也就是上下文，包括比如 PC 和寄存器文件的当前值，以及主存的内容。当操作系统决定把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程。 从一个进程到另一个进程的转换是由操作系统内核管理的，内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回给应用程序。内核不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合。 虚拟内存虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。在 Linux 中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样的。地址空间的底部区域存放用户进程定义的代码和数据。 每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。从最低的地址开始，逐步向上介绍： 程序代码和数据。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。 堆。代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。 共享库。用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。 栈。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。 内核虚拟内存。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。 文件文件就是字节序列，仅此而已。每个 I&#x2F;O 设备，包括磁盘、键盘、显示器、甚至网络，都可以看成是文件。系统中所有输入输出都是通过使用一小组称为 Unix I&#x2F;O 的系统函数调用读写文件来实现的。 Amdahl 定律该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。Amdahl 定律主要观点–要想显著加速整个系统，必须提升全系统中相当大的部分的速度 并发和并行并发（concurrency）是一个通用的概念，指一个同时具有多个活动的系统；而并行（parallelism）指的是用并发来使一个系统运行得更快。 线程级并发传统意义上，这种并发执行知识模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的。 超线程，有时称为同时多线程，是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU 某些硬件有多个备份，比如程序计数器和寄存器文件。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。 指令级并行现代处理器可以同时执行多条指令的属性称为指令级并行。早期的微处理器，需要多个（通常是3-10个）时钟周期来执行一条指令。最近的处理器可以保持每个时钟周期2-4条指令的执行速率。其实每条指令从开始到结束需要长得多的事件，大约20个或者更多周期，但是处理器使用了技巧来同时处理多达100条指令。 单指令、多数据并行许多处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。 抽象在处理器里，指令级架构提供了对实际处理器硬件的抽象。 虚拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序。","categories":[],"tags":[]},{"title":"网站","slug":"网站","date":"2022-11-10T05:40:00.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/11/10/网站/","link":"","permalink":"https://azxkenzo.github.io/2022/11/10/%E7%BD%91%E7%AB%99/","excerpt":"","text":"脚本 - asp php jsphtml - css js htmlHTTP协议CMSMD5 NGINXnginx(engine x) 是 HTTP 和反向代理服务器、邮件代理服务器和通用 TCP&#x2F;UDP 代理服务器，最初由 Igor Sysoev 编写。 很长一段时间以来，它一直在许多负载重的俄罗斯网站上运行，包括 Yandex、Mail.Ru、VK 和 Rambler。 根据 Netcraft 的数据，2022 年 9 月，nginx 服务或代理了 21.48% 最繁忙的网站。以下是一些成功案例：Dropbox、Netflix、Wordpress.com、FastMail.FM。 基础 HTTP 服务器功能 提供静态和索引文件，自动索引； 打开文件描述符缓存； 带缓存的加速反向代理； 负载均衡和容错； 加速支持 FastCGI、uwsgi、SCGI 和 memcached 服务器的缓存； 负载均衡和容错； 模块化架构。 过滤器包括 gzipping、字节范围、分块响应、XSLT、SSI 和图像转换过滤器。 如果它们由代理或 FastCGI&#x2F;uwsgi&#x2F;SCGI 服务器处理，则可以并行处理单个页面中的多个 SSI 包含； SSL 和 TLS SNI 支持； 支持具有加权和基于依赖的优先级的 HTTP&#x2F;2。 其他 HTTP 服务器功能 基于名称和基于 IP 的虚拟服务器； 保持活动和管道连接支持； 访问日志格式、缓冲日志写入、快速日志轮换和 syslog 日志记录； 3xx-5xx 错误代码重定向； 重写模块：使用正则表达式改变URI； 根据客户端地址执行不同的功能； 基于客户端IP地址、密码（HTTP基本认证）和子请求结果的访问控制； HTTP 引用者的验证； PUT、DELETE、MKCOL、COPY 和 MOVE 方法； FLV 和 MP4 流媒体； 响应速度限制； 限制来自一个地址的同时连接或请求的数量； 基于IP的地理定位； A&#x2F;B 测试； 请求镜像； 嵌入式 Perl； njs 脚本语言。 邮件代理服务器功能 使用外部 HTTP 身份验证服务器将用户重定向到 IMAP 或 POP3 服务器； 使用外部 HTTP 身份验证服务器进行用户身份验证并将连接重定向到内部 SMTP 服务器； 认证方式： POP3: USER&#x2F;PASS, APOP, AUTH LOGIN&#x2F;PLAIN&#x2F;CRAM-MD5; IMAP：登录、授权登录&#x2F;PLAIN&#x2F;CRAM-MD5； SMTP: AUTH LOGIN&#x2F;PLAIN&#x2F;CRAM-MD5; SSL 支持； STARTTLS 和 STLS 支持。 TCP&#x2F;UDP 代理服务器功能 TCP 和 UDP 的通用代理； 对 TCP 的 SSL 和 TLS SNI 支持； 负载均衡和容错； 基于客户端地址的访问控制； 根据客户端地址执行不同的功能； 限制来自一个地址的同时连接数； 访问日志格式、缓冲日志写入、快速日志轮换和 syslog 日志记录； 基于IP的地理定位； A&#x2F;B 测试； njs 脚本语言。 架构和可扩展性 一个master和几个worker进程；工作进程在非特权用户下运行； 灵活配置； 在不中断客户端服务的情况下重新配置和升级可执行文件； 支持 kqueue (FreeBSD 4.1+)、epoll (Linux 2.6+)、&#x2F;dev&#x2F;poll (Solaris 7 11&#x2F;99+)、事件端口 (Solaris 10)、select 和 poll； 支持各种 kqueue 功能，包括 EV_CLEAR、EV_DISABLE（临时禁用事件）、NOTE_LOWAT、EV_EOF、可用数据数量、错误代码； 支持EPOLLRDHUP（Linux 2.6.17+，glibc 2.8+）和EPOLLEXCLUSIVE（Linux 4.5+，glibc 2.24+）等多种epoll特性； sendfile（FreeBSD 3.1+、Linux 2.2+、macOS 10.5+）、sendfile64（Linux 2.4.21+）和 sendfilev（Solaris 8 7&#x2F;01+）支持； 文件 AIO（FreeBSD 4.3+，Linux 2.6.22+）； DIRECTIO（FreeBSD 4.4+、Linux 2.4+、Solaris 2.6+、macOS）； 接受过滤器（FreeBSD 4.1+、NetBSD 5.0+）和 TCP_DEFER_ACCEPT（Linux 2.4+）支持； 10,000 个不活动的 HTTP keep-alive 连接占用大约 2.5M 内存； 数据复制操作保持在最低限度。 经过测试的操作系统和平台 FreeBSD 3 — 12 &#x2F; i386; FreeBSD 5 — 12 &#x2F; amd64; FreeBSD 11 &#x2F; ppc; FreeBSD 12 &#x2F; ppc64; Linux 2.2 — 4 &#x2F; i386; Linux 2.6 — 5 &#x2F; amd64; Linux 3 — 4 &#x2F; armv6l, armv7l, aarch64, ppc64le; Linux 4 — 5 &#x2F; s390x; Solaris 9 &#x2F; i386, sun4u; Solaris 10 &#x2F; i386, amd64, sun4v; Solaris 11 &#x2F; x86; AIX 7.1 &#x2F; powerpc; HP-UX 11.31 &#x2F; ia64; macOS &#x2F; ppc, i386, x86_64; Windows XP, Windows Server 2003, Windows 7, Windows 10. 下载NGINX 包含 mainline 和 stable 两个版本。 配置及安装配置命令 configure常用参数： –prefix&#x3D;path：定义将保存服务器文件的目录。这个相同的目录也将用于由 configure 设置的所有相对路径（库源的路径除外）和 nginx.conf 配置文件中。 默认设置为 &#x2F;usr&#x2F;local&#x2F;nginx 目录。 –sbin-path&#x3D;path：设置 nginx 可执行文件的名称。此名称仅在安装期间使用。 默认情况下，该文件名为 prefix&#x2F;sbin&#x2F;nginx。 –modules-path&#x3D;path：定义将安装 nginx 动态模块的目录。 默认情况下使用 prefix&#x2F;modules 目录。 –conf-path&#x3D;path：设置 nginx.conf 配置文件的名称。 如果需要，nginx 总是可以使用不同的配置文件启动，方法是在命令行参数 -c 文件中指定它。 默认情况下，该文件名为 prefix&#x2F;conf&#x2F;nginx.conf。 –user&#x3D;name：设置工作进程将使用其凭据的非特权用户的名称。 安装后，始终可以使用 user 指令在 nginx.conf 配置文件中更改名称。 默认用户名是nobody。 –with-http_ssl_module：允许构建一个将 HTTPS 协议支持添加到 HTTP 服务器的模块。 默认情况下不构建此模块。 构建和运行此模块需要 OpenSSL 库。 –with-http_v2_module：允许构建一个为 HTTP&#x2F;2 提供支持的模块。 默认情况下不构建此模块。 –with-openssl&#x3D;path: sets the path to the OpenSSL library sources. –with-pcre&#x3D;path：设置 PCRE 库源的路径。 库分发需要从 PCRE 站点下载并提取。 其余的由 nginx 的 .&#x2F;configure 和 make 完成。 location 指令中的正则表达式支持和 ngx_http_rewrite_module 模块需要该库。 –with-zlib&#x3D;path：设置 zlib 库源的路径。 库分发（版本 1.1.3 — 1.2.11）需要从 zlib 站点下载并解压缩。 其余的由 nginx 的 .&#x2F;configure 和 make 完成。 ngx_http_gzip_module 模块需要该库。 Starting, Stopping, and Reloading ConfigurationTo start nginx, run the executable file. Once nginx is started, it can be controlled by invoking the executable with the -s parameter. Use the following syntax: 1nginx -s signal Where signal may be one of the following: stop — fast shutdown quit — graceful shutdown reload — reloading the configuration file reopen — reopening the log files 提供静态内容123location / &#123; root /data/www;&#125; 此 location 块指定与来自请求的 URI 相比的“&#x2F;”前缀。 对于匹配请求，URI 将被添加到 root 指令中指定的路径，即 &#x2F;data&#x2F;www， 以形成本地文件系统上请求文件的路径。如果有多个匹配的位置块，nginx 会选择具有最长前缀的位置块。 上面的位置块提供了最短的前缀，长度为 1，因此只有当所有其他位置块都未能提供匹配时，才会使用该块。 动态脚本语言对于Nginx而言，PHP是一个外部程序而不是Nginx内部模块。Nginx需要通过CGI接口程序来实现与PHP程序的交互，进而将php响应的文件交给用户浏览器。这样就实现了动态网站的基本流程。FastCGI就是这样一种接口，通过php-fpm来管理，换句话说php-fpm就是FastCGI的进程管理器。","categories":[],"tags":[]},{"title":"Kotlin - 面向对象","slug":"Kotlin-面向对象","date":"2022-11-02T03:24:18.000Z","updated":"2023-07-18T04:22:50.334Z","comments":true,"path":"2022/11/02/Kotlin-面向对象/","link":"","permalink":"https://azxkenzo.github.io/2022/11/02/Kotlin-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"在 Java 中，子类的构造方法实现中必须调用父类的构造方法。有以下规则： 如果父类有无参构造方法，则子类构造方法会隐式调用父类的无参构造方法 如果父类没有无参构造方法，则子类构造方法必须显式调用父类构造方法或子类其他构造方法（来间接调用父类构造方法） 对其他构造方法的调用必须放在方法体的第一行 在 Kotlin 中，如果一个类存在主构造器，则每个次构造器都要直接或间接委托给主构造器。 如果子类有主构造器，则必须调用父类的主构造器或次构造器进行初始化 如果子类没有主构造器，则子类的次构造器必须直接或间接委托给父类的主或次构造器进行初始化 类类声明由类名、类头（指定其泛型、主构造器和其他一些内容）和用花括号括起来的类主体组成。 类头和类主体都是可选的； 如果类没有主体，则可以省略花括号。 构造器Kotlin 中的类可以有一个主构造器和一个或多个次构造器。 主构造器是类头的一部分，位于类名和可选泛型之后。 如果主构造器没有任何注解或可见性修饰符，则 constructor 关键字可以省略。 主构造器不能包含任何代码。 初始化代码可以放在以 init 关键字为前缀的 initializer 块中。 在实例初始化期间，initializer 块按照它们在类主体中出现的顺序执行，并与属性 initializer 交错。 主构造器参数可以在 initializer 块中使用。 它们也可以用在类主体中声明的属性 initializer 中。 Kotlin 有一个简洁的语法来声明属性并从主构造器初始化它们。此类声明还可以包括类属性的默认值。 如果主构造器有注释或可见性修饰符，则 constructor 关键字是必需的，并且修饰符位于它之前。 主构造器的参数允许使用val或var声明，而在次构造器中，这是不允许的。 次构造器一个类也可以声明次构造器，以 constructor 为前缀。 如果类具有主构造器，则每个次构造器都需要直接或间接通过另一个次构造器委托给主构造器。 使用 this 关键字完成对同一类的另一个构造器的委托。 initializer 块中的代码有效地成为主构造器的一部分。 对主构造器的委托作为次构造器的第一条语句发生，因此所有 initializer 块和属性 initializer 中的代码都在次构造器的主体之前执行。 即使类没有主构造器，委托仍然隐式发生，initializer 块仍然执行。 如果一个非抽象类没有声明任何构造器（主要的或次要的），它将有一个生成的不带参数的主构造器。 构造器的可见性将是 public。 在 JVM 上，如果所有主构造器参数都有默认值，编译器将生成一个额外的无参数构造器，它将使用默认值。 创建类实例要创建类的实例，像调用常规函数一样调用构造函数。 类成员类可以包含： Constructors and initializer blocks Functions Properties Nested and inner classes Object declarations 抽象类一个类可以连同它的部分或全部成员一起被声明为 abstract。 抽象成员在其类中没有实现。 不需要使用 open 注释抽象类或函数。 抽象类的主构造器参数不能被声明为 abstract。 可以用 abstract 的开放成员重写非抽象的 open 成员。 1234567891011open class Polygon &#123; open fun draw() &#123; // some default polygon drawing method &#125;&#125;abstract class WildShape : Polygon() &#123; // Classes that inherit WildShape need to provide their own // draw method instead of using the default on Polygon abstract override fun draw()&#125; 继承Kotlin 中的所有类都有一个共同的超类 Any，它是没有声明超类型的类的默认超类。 Any 具有三个方法：equals()、hashCode() 和 toString()。 因此，这些方法是为所有 Kotlin 类定义的。 默认情况下，Kotlin 类是 final 的——它们不能被继承。 要使类可继承，请使用 open 关键字对其进行标记。 要声明显式超类型，请将类型放在类头中的冒号之后。 如果派生类具有主构造器，则可以（并且必须）根据其参数在该主构造器中初始化基类。 如果派生类没有主构造器，则每个次构造器都必须使用 super 关键字初始化基类，或者它必须委托给另一个构造器。请注意，在这种情况下，不同的次构造器可以调用基类型的不同构造器。 重写方法Kotlin 中，override 修饰符不能省略。 标记为 override 的成员本身是 open 的，因此它可以在子类中被重写。 如果要禁止重新重写，使用 final 修饰该成员。 重写属性重写机制对属性的工作方式与对方法的工作方式相同。 在超类上声明的属性，然后在派生类上重新声明，必须以 override 开头，并且它们必须具有兼容的类型。每个声明的属性都可以被带有初始化器的属性或带有 get 方法的属性覆盖。 可以使用 var 属性覆盖 val 属性，但反之则不行。 这是允许的，因为 val 属性本质上声明了一个 get 方法，并且将其覆盖为 var 还会在派生类中另外声明一个 set 方法。 可以在主构造器中使用 override 关键字作为属性声明的一部分。 派生类初始化顺序在派生类的新实例的构造过程中，基类初始化作为第一步完成（之前仅对基类构造函数的参数求值），这意味着它发生在派生类的初始化逻辑之前。 这意味着在执行基类构造函数时，派生类中声明或覆盖的属性尚未初始化。 在基类初始化逻辑中使用任何这些属性（直接或间接通过另一个重写的开放成员实现）可能会导致不正确的行为或运行时故障。因此，在设计基类时，应避免在构造函数、属性初始值设定项或 init 块中使用 open 成员。 调用超类实现在内部类中，访问外部类的超类是使用外部类名限定的 super 关键字完成的：super@Outer_Name。 重写规则在 Kotlin 中，实现继承受以下规则的约束：如果一个类从其直接超类继承同一成员的多个实现，它必须覆盖该成员并提供自己的实现（可能使用继承的一个）。 要表示继承实现的超类型，请使用尖括号中超类型名称限定的 super，例如 super&lt;Base&gt;。 属性getter 和 setter声明属性的完整语法如下所示： 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] initializer、getter 和 setter 是可选的。 只读属性自定义 getter 时不允许有 initializer，原因是只读属性没有后端字段。 如果需要注释访问器或更改其可见性，但不需要更改默认实现，则可以定义访问器而不定义其主体。 后端字段在 Kotlin 中，field 仅用作属性的一部分，以将其值保存在内存中。 field 不能直接声明。 然而，当一个属性需要一个后端字段时，Kotlin 会自动提供它。可以使用 field 标识符在访问器中引用此后端字段： 123456var counter = 0 // the initializer assigns the backing field directly set(value) &#123; if (value &gt;= 0) field = value // counter = value // ERROR StackOverflow: Using actual name &#x27;counter&#x27; would make setter recursive &#125; field 标识符只能在属性访问器中使用。 如果属性使用至少一个访问器的默认实现，或者自定义访问器通过 field 标识符引用它，则将为属性生成后端字段。 后端属性如果想做一些不适合这个隐式后端字段方案的事情，总是可以回退到拥有一个后端属性： 12345678private var _table: Map&lt;String, Int&gt;? = nullpublic val table: Map&lt;String, Int&gt; get() &#123; if (_table == null) &#123; _table = HashMap() // Type parameters are inferred &#125; return _table ?: throw AssertionError(&quot;Set to null by another thread&quot;) &#125; 在 JVM 上：对使用默认 getter 和 setter 的私有属性的访问进行了优化，以避免函数调用开销。 编译期常量如果只读属性的值在编译期已知，则可以使用 const 修饰符将其标记为编译期常量。这样的属性需要满足以下要求： 它必须是顶层属性或者 object 声明或伴生对象的成员 必须使用 String 类型或原始类型的值对其进行初始化 不能有自定义 getter 编译器将内联常量的用法，用它的实际值替换对常量的引用。 但是，该字段不会被移除，因此可以使用反射进行交互。 延迟初始化属性和变量通常，声明为非空类型的属性必须在构造器中被初始化。在一些情况中，无法提供非空的 initializer，但是又仍然想避免在类主体中引用该属性时进行判空，这时可以使用 lateinit 修饰符标记该属性。 此修饰符可用于在类主体内声明的 var 属性（不在主构造器中，并且仅当属性没有自定义 getter 或 setter 时），以及顶层属性和局部变量。 属性或变量的类型必须是非空的，并且不能是原始类型。 在初始化之前访问 lateinit 属性会引发一个特殊异常。 要检查是否已初始化 lateinit var，请在对该属性的引用上使用 .isInitialized。此检查仅适用于在同一类型、外部类型之一或同一文件的顶层声明时可通过词法访问的属性。 接口在 Kotlin 中，接口既可以包含抽象方法的声明，又可以包含方法实现。它们与抽象类的不同之处在于接口不能存储状态。 它们可以具有属性，但这些属性需要是抽象的或提供访问器实现。 类或者 object 可以实现一个或多个接口。 接口中的属性可以在接口中声明属性。 在接口中声明的属性可以是抽象的，也可以为访问器提供实现。 **在接口中声明的属性不能有后端字段**，因此在接口中声明的访问器不能引用它们。 解决重写冲突当在超类型列表中声明许多类型时，可能会继承多个相同方法的实现，此时派生类需要重写继承的相同方法。 函数式接口只有一个抽象方法的接口称为函数式接口或单一抽象方法 (SAM) 接口。 函数式接口可以有多个非抽象成员，但只有一个抽象成员。 在 kotlin 中，使用 fun 修饰符声明函数式接口。 函数式接口不能有抽象属性。 从 1.6.20 开始，Kotlin 支持对函数式接口构造函数的可调用引用，这增加了一种源兼容的方式来从具有构造函数的接口迁移到函数式接口。 SAM 转换对于函数式接口，可以使用 SAM 转换，通过使用 lambda 表达式使代码更加简洁和易读。 可以使用 lambda 表达式，而不是手动创建实现函数式接口的类。 通过 SAM 转换，Kotlin 可以将任何签名与接口的单个方法的签名匹配的 lambda 表达式转换为代码，从而动态实例化接口实现。 123456789// Creating an instance of a classval isEven = object : IntPredicate &#123; override fun accept(i: Int): Boolean &#123; return i % 2 == 0 &#125;&#125;// Creating an instance using lambdaval isEven = IntPredicate &#123; it % 2 == 0 &#125; 函数式接口 VS typealias1234567typealias IntPredicate = (i: Int) -&gt; Booleanval isEven: IntPredicate = &#123; it % 2 == 0 &#125;fun main() &#123; println(&quot;Is 7 even? - $&#123;isEven(7)&#125;&quot;)&#125; 函数式接口和类型别名有不同的用途。 类型别名只是现有类型的名称——它们不会创建新类型，而函数式接口会。可以提供特定于特定函数式接口的扩展，使其不适用于普通函数或其类型别名。 类型别名只能有一个成员，而函数式接口可以有多个非抽象成员和一个抽象成员。 函数式接口也可以实现和扩展其他接口。 函数式接口比类型别名更灵活并提供更多功能，但它们在语法和运行时的成本更高，因为它们可能需要转换为特定接口。 当选择在代码中使用哪一个时，请考虑需求： 如果 API 需要接受具有某些特定参数和返回类型的函数（任何函数） - 使用简单的函数类型或定义类型别名来为相应的函数类型提供更短的名称。 如果 API 接受一个比函数更复杂的实体——例如，它有非平凡的常量和&#x2F;或不能在函数类型的签名中表达的操作——为它声明一个单独的函数接口。 可见性修饰符类、object、接口、构造器、函数，还有属性和其 setter 可以有可见性修饰符。getter 总是和其属性有相同的可见性。 kotlin 中有四种可见性修饰符：private, protected, internal, 和 public。默认可见性是 public。 Java 可见性修饰符：public、protected(包内可见、子类可见)、default(包内可见、不同包的子类中不可见)、private。 包函数, 属性, 类, object, 和 接口 在包内可以直接声明为顶层的。 public 是默认的。 如果标记为 private, 则只能在包含该声明的文件内可见。 如果标记为 internal, 则在同一模块内可见。 protected 修饰符对顶层声明不可用。 类成员 private 表明该成员只能在这个类里可见。 protected 表明该成员与 private 有相同的可见性，但是在子类中也可见。 internal 表明在这个模块中看到声明类的任何客户端都会看到它的 internal 成员。 public 表明看到声明类的任何客户端都会看到它的 public 成员。 在 Kotlin 中，外部类看不到内部类的 private 成员，但是在 Java 中能看到。 如果重写 protected 或 internal 成员并且没有明确指明可见性，则重写的成员的将有与原始相同的可见性。 局部声明局部的变量、函数和类不能有可见性修饰符。 模块internal 可见性修饰符意味着该成员在同一模块中是可见的。 更具体地说，模块是一组编译在一起的 Kotlin 文件，例如： An IntelliJ IDEA module. A Maven project. A Gradle source set (with the exception that the test source set can access the internal declarations of main). A set of files compiled with one invocation of the Ant task. 扩展Kotlin 提供了使用新功能扩展类或接口的能力，而无需从类继承或使用 Decorator 等设计模式。 这是通过称为扩展的特殊声明完成的。 扩展函数要声明扩展函数，需要在其名称前加上 receiver 类型，它指的是被扩展的类型。 12345fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // &#x27;this&#x27; corresponds to the list this[index1] = this[index2] this[index2] = tmp&#125; 扩展函数中的 this 关键字对应于 receiver 对象（在(.)之前传递的对象）。 扩展是静态解析的扩展实际上并不修改它们扩展的类。 通过定义扩展，不会将新成员插入到类中，而只是使新函数可以使用这种类型的变量的点符号调用。 扩展函数是静态分派的，这意味着它们不是按 receiver 类型虚拟的。 被调用的扩展函数由调用函数的表达式的类型决定，而不是由在运行时计算该表达式的结果类型决定。 例如： 1234567891011open class Shapeclass Rectangle: Shape()fun Shape.getName() = &quot;Shape&quot;fun Rectangle.getName() = &quot;Rectangle&quot;fun printClassName(s: Shape) &#123; println(s.getName())&#125;printClassName(Rectangle()) 这个例子打印了 Shape，因为调用的扩展函数只依赖于参数 s 的声明类型，也就是 Shape 类。 如果一个类有一个成员函数，并且定义了一个具有相同 receiver 类型、相同名称并且适用于给定参数的扩展函数，则该成员总是优先。 可空 receiver注意，可以使用可为空的 receiver 类型定义扩展。 即使对象变量的值为 null，也可以在对象变量上调用这些扩展，并且它们可以在主体内检查 this == null。 123456fun Any?.toString(): String &#123; if (this == null) return &quot;null&quot; // after the null check, &#x27;this&#x27; is autocast to a non-null type, so the toString() below // resolves to the member function of the Any class return toString()&#125; 扩展属性12val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = size - 1 由于扩展实际上并不将成员插入到类中，因此扩展属性没有有效的方法来拥有后端字段。 这就是扩展属性不允许使用 initializer 的原因。它们的行为只能通过显式提供 getter&#x2F;setter 来定义。 伴生对象扩展如果一个类定义了伴随对象，还可以为伴随对象定义扩展函数和属性。 就像伴生对象的常规成员一样，它们可以仅使用类名作为限定符来调用： 123456789class MyClass &#123; companion object &#123; &#125; // will be called &quot;Companion&quot;&#125;fun MyClass.Companion.printCompanion() &#123; println(&quot;companion&quot;) &#125;fun main() &#123; MyClass.printCompanion()&#125; 把扩展声明为成员可以在另一个类中声明一个类的扩展。 在这样的扩展中，有多个隐式 receiver - 其成员可以在没有限定符的情况下访问的对象。声明扩展的类的实例称为 dispatch receiver，扩展方法的接收器类型的实例称为 extension receiver。 如果 dispatch receiver 和 extension receiver 的成员之间发生名称冲突，则 extension receiver 优先。 要引用 dispatch receiver 的成员，可以使用限定的 this 语法。 声明为成员的扩展可以在子类中声明为 open 和重写。 这意味着此类函数的调度对于 dispatch receiver 类型是虚拟的，但对于 extension receiver 类型是静态的。 扩展使用与在同一范围内声明的常规函数相同的可见性修饰符。 例如： 在文件顶层声明的扩展可以访问同一文件中的其他私有顶层声明。 如果扩展在其接收者类型之外声明，则它不能访问接收者的 private 或 protected 成员。 Data class编译器自动从主构造器中声明的所有属性派生以下成员： equals()&#x2F;hashCode() pair toString() of the form “User(name&#x3D;John, age&#x3D;42)” componentN() functions corresponding to the properties in their order of declaration. copy() function (see below). 为了确保生成代码的一致性和有意义的行为，数据类必须满足以下要求： 主构造器至少需要一个参数。 所有主构造器参数都需要标记为 val 或 var。 数据类不能是 abstract, open, sealed, or inner。 此外，数据类成员的生成遵循以下关于成员继承的规则： 如果数据类主体中有equals()、hashCode() 或toString() 的显式实现或超类中的最终实现，则不会生成这些函数，而是使用现有的实现。 如果超类型具有 open 并返回兼容类型的 componentN() 函数，则会为数据类生成相应的函数并覆盖超类型的函数。 如果超类型的函数由于不兼容的签名或由于它们是最终的而无法覆盖，则会报告错误。 不允许为 componentN() 和 copy() 函数提供显式实现。 数据类可以扩展其他类。 声明在类主体中的参数编译器仅将主构造器中定义的属性用于自动生成的函数。 要从生成的实现中排除属性，请在类主体中声明它。 copy使用 copy() 函数复制对象，允许更改其某些属性，同时保持其余属性不变。 数据类和解构声明为数据类生成的 Component 函数可以在解构声明中使用它们： 123val jane = User(&quot;Jane&quot;, 35)val (name, age) = janeprintln(&quot;$name, $age years of age&quot;) // prints &quot;Jane, 35 years of age&quot; Sealed classes密封的类和接口表示受限制的类层次结构，可提供对继承的更多控制。 密封类的所有直接子类在编译时都是已知的。 任何其他子类都不能出现在定义了密封类的模块之外。例如，第三方客户端无法在其代码中扩展密封类。 因此，密封类的每个实例都有一个来自有限集合的类型，该类型在编译此类时是已知的。 密封接口及其实现也是如此：一旦编译了具有密封接口的模块，就不会出现新的实现。 在某种意义上，密封类类似于枚举类：枚举类型的值集也受到限制，但每个枚举常量仅作为单个实例存在，而密封类的子类可以有多个实例，每个实例都有自己的状态。 例如，考虑一个库的 API。 它可能包含错误类，让库用户处理它可能抛出的错误。 如果此类错误类的层次结构包括在公共 API 中可见的接口或抽象类，则没有什么能阻止在客户端代码中实现或扩展它们。 但是，该库不知道在其外部声明的错误，因此它不能与它自己的类一致地对待它们。 使用密封的错误类层次结构，库作者可以确保他们知道所有可能的错误类型，并且以后不会出现其他错误类型。 要声明一个密封的类或接口，将 sealed 修饰符放在其名称之前。 密封类本身是抽象的，不能直接实例化，可以有抽象成员。 密封类的构造器可以具有以下两种可见性之一：protected（默认）或 private。 直接子类的位置密封类和接口的直接子类必须在同一个包中声明。 它们可以是顶层的，也可以嵌套在任意数量的其他命名类、命名接口或命名对象中。子类可以具有任何可见性，只要它们与 Kotlin 中的正常继承规则兼容。 密封类的子类必须具有适当的限定名称。 它们不能是本地对象，也不能是匿名对象。 枚举类不能扩展密封类（以及任何其他类），但它们可以实现密封接口。 这些限制不适用于间接子类。 如果密封类的直接子类未标记为密封，则可以通过其修饰符允许的任何方式对其进行扩展： 密封类和 when 表达式当在 when 表达式中使用密封类时，使用密封类的主要好处就会发挥作用。 如果可以验证语句涵盖所有情况，则无需在语句中添加 else 子句。但是，这仅在使用 when 作为表达式（使用结果）而不是作为语句时才有效。 嵌套类和内部类类可以嵌套在其他类中。还可以使用带有嵌套的接口。 类和接口的所有组合都是可能的：可以将接口嵌套在类中，将类嵌套在接口中，将接口嵌套在接口中。 内部类标记为 inner 的嵌套类可以访问其外部类的成员。 内部类携带对外部类对象的引用。 枚举类每个枚举常量都是个对象。枚举常量通过逗号分隔。 由于每个枚举都是枚举类的一个实例，因此可以将其初始化为： 12345enum class Color(val rgb: Int) &#123; RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF)&#125; 枚举常量可以使用其相应的方法以及重写基方法来声明它们自己的匿名类。 1234567891011enum class ProtocolState &#123; WAITING &#123; override fun signal() = TALKING &#125;, TALKING &#123; override fun signal() = WAITING &#125;; abstract fun signal(): ProtocolState&#125; 如果枚举类定义了任何成员，则用分号将常量定义与成员定义分开。 在枚举类中实现接口枚举类可以实现一个接口（但它不能从一个类派生），为所有条目提供接口成员的公共实现，或者为其匿名类中的每个条目提供单独的实现。 这是通过将要实现的接口添加到枚举类声明中来完成的，如下所示： 12345678910enum class IntArithmetics : BinaryOperator&lt;Int&gt;, IntBinaryOperator &#123; PLUS &#123; override fun apply(t: Int, u: Int): Int = t + u &#125;, TIMES &#123; override fun apply(t: Int, u: Int): Int = t * u &#125;; override fun applyAsInt(t: Int, u: Int) = apply(t, u)&#125; 使用枚举常量Kotlin 中的枚举类具有用于列出定义的枚举常量并通过其名称获取枚举常量的综合方法。 这些方法的签名如下（假设枚举类的名称是EnumClass）： 12EnumClass.valueOf(value: String): EnumClassEnumClass.values(): Array&lt;EnumClass&gt; 如果指定的名称与类中定义的任何枚举常量不匹配，则 valueOf() 方法将引发 IllegalArgumentException。 可以使用 enumValues() 和 enumValueOf() 函数以泛型方式访问枚举类中的常量： 1234567enum class RGB &#123; RED, GREEN, BLUE &#125;inline fun &lt;reified T : Enum&lt;T&gt;&gt; printAllValues() &#123; print(enumValues&lt;T&gt;().joinToString &#123; it.name &#125;)&#125;printAllValues&lt;RGB&gt;() // prints RED, GREEN, BLUE 每个枚举常量都具有用于在枚举类声明中获取其名称和位置（从 0 开始）的属性： 12val name: Stringval ordinal: Int 内联类有时，业务逻辑需要围绕某种类型创建包装器。 但是，由于额外的堆分配，它会引入运行时开销。此外，如果包装类型是原始类型，则性能损失很糟糕，因为原始类型通常由运行时进行大量优化，而它们的包装器没有得到任何特殊处理。 为了解决这些问题，Kotlin 引入了一种特殊的类，称为内联类。 内联类是基于值的类的子集。 他们没有身份，只能持有值。 要声明内联类，在类名之前使用 value 修饰符： 1value class Password(private val s: String) 内联类必须具有在主构造器中初始化的单个属性。 在运行时，内联类的实例将使用这个单一属性表示 ： 123// No actual instantiation of class &#x27;Password&#x27; happens// At runtime &#x27;securePassword&#x27; contains just &#x27;String&#x27;val securePassword = Password(&quot;Don&#x27;t try this in production&quot;) 这是内联类的主要特征，它启发了内联这个名称：类的数据被内联到它的用法中（类似于内联函数的内容如何内联到调用站点）。 成员内联类支持常规类的一些功能。 特别是，它们可以声明属性和函数，并具有 init 块： 123456789101112131415161718value class Name(val s: String) &#123; init &#123; require(s.length &gt; 0) &#123; &#125; &#125; val length: Int get() = s.length fun greet() &#123; println(&quot;Hello, $s&quot;) &#125;&#125;fun main() &#123; val name = Name(&quot;Kotlin&quot;) name.greet() // method `greet` is called as a static method println(name.length) // property getter is called as a static method&#125; 内联类属性不能有后端字段。 它们只能具有简单的可计算属性（没有 lateinit&#x2F;delegated 属性）。 继承允许内联类从接口继承。 禁止内联类参与类层次结构。 这意味着内联类不能扩展其他类并且始终是 final 类。 表示在生成的代码中，Kotlin 编译器为每个内联类保留一个包装器。 内联类实例可以在运行时表示为包装器或底层类型。这类似于如何将 Int 表示为原始 int 或包装器 Integer。 Kotlin 编译器将更喜欢使用底层类型而不是包装器来生成最高性能和优化的代码。 但是，有时需要保留包装器。 根据经验，内联类在用作另一种类型时都会被装箱。 123456789101112131415161718192021222324interface I@JvmInlinevalue class Foo(val i: Int) : Ifun asInline(f: Foo) &#123;&#125;fun &lt;T&gt; asGeneric(x: T) &#123;&#125;fun asInterface(i: I) &#123;&#125;fun asNullable(i: Foo?) &#123;&#125;fun &lt;T&gt; id(x: T): T = xfun main() &#123; val f = Foo(42) asInline(f) // unboxed: used as Foo itself asGeneric(f) // boxed: used as generic type T asInterface(f) // boxed: used as type I asNullable(f) // boxed: used as Foo?, which is different from Foo // below, &#x27;f&#x27; first is boxed (while being passed to &#x27;id&#x27;) and then unboxed (when returned from &#x27;id&#x27;) // In the end, &#x27;c&#x27; contains unboxed representation (just &#x27;42&#x27;), as &#x27;f&#x27; val c = id(f)&#125; 因为内联类既可以表示为基础值，也可以表示为包装器，因此引用相等对它们没有意义，因此被禁止。 内联类也可以有一个泛型类型参数作为基础类型。 在这种情况下，编译器将其映射到 Any? 或者，通常是类型参数的上限。 1234@JvmInlinevalue class UserId&lt;T&gt;(val value: T)fun compute(s: UserId&lt;String&gt;) &#123;&#125; // compiler generates fun compute-&lt;hashcode&gt;(s: Any?) 重整由于内联类被编译为它们的底层类型，它可能会导致各种模糊的错误，例如意外的平台签名冲突： 12345678@JvmInlinevalue class UInt(val x: Int)// Represented as &#x27;public final void compute(int x)&#x27; on the JVMfun compute(x: Int) &#123; &#125;// Also represented as &#x27;public final void compute(int x)&#x27; on the JVM!fun compute(x: UInt) &#123; &#125; 为了缓解此类问题，使用内联类的函数会通过在函数名称中添加一些稳定的哈希码来破坏。 因此，fun compute(x: UInt) 将表示为 public final void compute-(int x)，从而解决了冲突问题。 Kotlin 1.4.30 中更改了修改方案。 使用 -Xuse-14-inline-classes-mangling-scheme 编译器标志强制编译器使用旧的 1.4.0 修改方案并保持二进制兼容性。 object 表达式和声明有时需要创建一个对某个类稍作修改的对象，而无需为它显式声明一个新的子类。 Kotlin 可以使用 object 表达式和 object 声明来处理这个问题。 object 表达式object 表达式创建匿名类的对象，即未使用类声明显式声明的类。 这样的类对于一次性使用很有用。可以从头开始定义它们、从现有类继承或实现接口。 匿名类的实例也称为匿名对象，因为它们是由表达式而不是名称定义的。 对象表达式以 object 关键字开头。 如果只需要一个没有任何重要超类型的对象，请将其成员写在对象后面的花括号中： 123456val helloWorld = object &#123; val hello = &quot;Hello&quot; val world = &quot;World&quot; // object expressions extend Any, so `override` is required on `toString()` override fun toString() = &quot;$hello $world&quot;&#125; 要创建从某个（或多个类型）继承的匿名类的对象，在对象和冒号 (:) 之后指定此类型。 然后实现或覆盖这个类的成员。 如果超类型具有构造器，则将适当的构造器参数传递给它。 多个超类型可以指定为冒号后的逗号分隔列表。 当匿名对象用作本地或私有类型但不是内联声明（函数或属性）时，它的所有成员都可以通过此函数或属性访问： 123456789class C &#123; private fun getObject() = object &#123; val x: String = &quot;x&quot; &#125; fun printX() &#123; println(getObject().x) &#125;&#125; 如果此函数或属性是公有或私有内联，则其实际类型为： Any 如果匿名对象没有声明的超类型 匿名对象的声明超类型，如果只有一种这样的类型 如果有多个声明的超类型，则显式声明的类型 在所有这些情况下，添加到匿名对象中的成员都是不可访问的。 如果在函数或属性的实际类型中声明了被覆盖的成员，则它们是可访问的： 1234567891011121314151617181920212223interface A &#123; fun funFromA() &#123;&#125;&#125;interface Bclass C &#123; // The return type is Any. x is not accessible fun getObject() = object &#123; val x: String = &quot;x&quot; &#125; // The return type is A; x is not accessible fun getObjectA() = object: A &#123; override fun funFromA() &#123;&#125; val x: String = &quot;x&quot; &#125; // The return type is B; funFromA() and x are not accessible fun getObjectB(): B = object: A, B &#123; // explicit return type is required override fun funFromA() &#123;&#125; val x: String = &quot;x&quot; &#125;&#125; object 表达式中的代码可以从封闭范围访问变量： 123456789101112131415fun countClicks(window: JComponent) &#123; var clickCount = 0 var enterCount = 0 window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; clickCount++ &#125; override fun mouseEntered(e: MouseEvent) &#123; enterCount++ &#125; &#125;) // ...&#125; object 声明单例模式在多种情况下很有用，而 Kotlin 使声明单例变得容易： 12345678object DataProviderManager &#123; fun registerDataProvider(provider: DataProvider) &#123; // ... &#125; val allDataProviders: Collection&lt;DataProvider&gt; get() = // ...&#125; 这称为 object 声明，它总是在对象关键字后面有一个名称。 就像变量声明一样，object 声明不是表达式，它不能用在赋值语句的右侧。 对象声明的初始化是线程安全的，并在首次访问时完成。 这样的 object 可以有超类： 12345object DefaultListener : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; ... &#125; override fun mouseEntered(e: MouseEvent) &#123; ... &#125;&#125; object 声明不能是局部的（也就是说，它们不能直接嵌套在函数内部），但它们可以嵌套到其他 object 声明或非内部类中。 Companion object类中的 object 声明可以用 companion 关键字标记。 可以通过使用类名作为限定符简单地调用伴生对象的成员。 伴随对象的名称可以省略，在这种情况下将使用名称 Companion： 12345class MyClass &#123; companion object &#123; &#125;&#125;val x = MyClass.Companion 类成员可以访问相应伴随对象的私有成员。 自己使用的类的名称（不是作为另一个名称的限定符）充当对类的伴随对象的引用（无论是否命名）： 需要注意的是，即使伴随对象的成员在其他语言中看起来像静态成员，在运行时它们仍然是真实对象的实例成员，并且可以例如实现接口： 1234567891011interface Factory&lt;T&gt; &#123; fun create(): T&#125;class MyClass &#123; companion object : Factory&lt;MyClass&gt; &#123; override fun create(): MyClass = MyClass() &#125;&#125;val f: Factory&lt;MyClass&gt; = MyClass 但是，在 JVM 上，如果使用 @JvmStatic 注释，可以将伴随对象的成员生成为真正的静态方法和字段。","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://azxkenzo.github.io/tags/Kotlin/"}]},{"title":"Android - 一个好的App","slug":"Android-一个好的App","date":"2022-10-28T00:22:15.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/10/28/Android-一个好的App/","link":"","permalink":"https://azxkenzo.github.io/2022/10/28/Android-%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84App/","excerpt":"","text":"一个好的App具备哪些特征： UI 动画 不卡顿 界面美观 交互逻辑 内存占用小 空间占用小","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - 架构模式","slug":"Android-架构模式","date":"2022-10-24T04:07:06.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/10/24/Android-架构模式/","link":"","permalink":"https://azxkenzo.github.io/2022/10/24/Android-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"背景设计模式（Design pattern）：是一套被反复使用、多数人知道的、经过分类编目的、代码设计经验的总结。从定义上看，它涉及到了代码级别，侧重于解决实际的、现实的问题。比如，应该如何如何为不同的商品设计折扣方式，采用策略模式。 框架（Framework）：是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法；另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。 架构模式：描述软件系统里的基本结构组织或纲要。架构模式提供一些定义好的子系统，指定它们的责任，并给出把它们组织在一起的法则和指南。 软件架构：是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计。软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。 架构模式随着移动端的飞速发展，产生了一些问题： 移动端App中业务逻辑越来越复杂，用户渴望更好的体验及更新颖的功能 不断地迭代让项目结构复杂化，维护成本越来越高 所以，需要一个良好的架构模式，拆分视图和数据，解除模块之间的耦合，提高模块内部的聚合度。 MVCMVC 对应 Model、View、Controller。 Model（数据层）：负责管理业务逻辑和处理网络或数据库API。数据访问（数据库、文件、网络）、缓存（图片、文件等）、配置文件等 View（视图层）：让数据层的数据可视化。数据展示与管理、用户交互、UI组件的绘制、列表Adapter等 Controller（逻辑层）：获得用户行为的通知，并根据需要更新 Model。初始化配置（定义全局变量等）、数据加工（加工成UI层需要的数据）、数据变化的通知机制等 MVC 的 Model 不只是代表一个实体模型，还应该包含大量的业务逻辑处理。 MVC 的优势Model 类没有对 Android 类的任何引用，因此可以直接进行单元测试。Controller 不会扩展或实现任何 Android 类，并且应该引用 View 的接口类。通过这种方式，也可以对控制器进行单元测试。MVC 模式高度支持职责分离，这个优势不仅增加了代码的可测试性，而且使其更容易扩展，从而可以相当容易地实现功能。 MVC 容易产生的问题代码相对冗余。MVC 中 View 对 Model 是有着强依赖的。当 View 非常复杂时，为了最小化 View 中的逻辑，Model 应该能够为要显示的每个视图提供可测试的方法–这将增加大量的类和方法灵活性较低。由于 View 依赖于 Controller 和 Model，UI 逻辑中的一个更改可能导致需要修改很多类，这降低了灵活性，并且导致UI难以测试。可维护性低。Android 的视图组件中，有非常明显的生命周期。对于 MVC 模式，有时不得不将处理视图逻辑的代码都写在这些组件中，造成臃肿。 所以，Android 中的 MVC 架构模式问题显而易见：过于臃肿的 Controller 层大大降低了工程的可维护性及可测试性。 MVPMVP 分别对应 Model、View、Presenter。 Model（数据层）：负责管理业务逻辑和处理网络或数据库API。 View（视图层）：显示数据并将用户操作的信息通知给 Presenter。 Presenter（逻辑层）：从 Model 中检索数据，应用UI逻辑并管理 View 的状态，决定显示什么，以及对 View 的事件做出响应。 相对于 MVC，MVP 模式设计思路的核心是提出了 Presenter 层，它是 View 层与 Model 层沟通的桥梁，对业务逻辑进行处理。 MVP 容易产生的问题接口粒度难以掌控。MVP 模式将模块职责进行了良好的分离。但在开发小规模App或原型时，这似乎增加了开销。Presenter 逻辑容易过重。当将UI的逻辑移动到 Presenter 中时，Presenter 变成了有数千行代码的类，或许会难以维护。Presenter 和 View 相互引用。在 Presenter 和 View 中都会保持一份对方的引用，所以需要用 subscribe 和 unsubscribe 来绑定和解除绑定。 MVVM维基百科：MVVM 有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或GUI代码实现的。MVVM 的视图模型是一个值转换器，这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。视图模型可以实现中介者模式，组织对视图所支持对用例集的后端逻辑的访问。 Model（数据模型）：与 ViewModel 配合，可以获取和保存数据。 View（视图）：将用户的动作通知给 ViewModel。 ViewModel（视图模型）：暴露公共属性与 View 相关的数据流，通常为 Model 和 View 的绑定关系。 如果 MVP 模式意味着 Presenter 直接告诉 View 要显示的内容，那么在 MVVM 中，ViewModel 会公开 Views 可以绑定的事件流。这样，ViewModel 不再需要保持对 View 的引用，但发挥了 Presenter 一样的作用。View 还会通知 ViewModel 进行不同的操作。因此，MVVM 模式支持 View 和 ViewModel 之间的双向数据绑定，并且 View 和 ViewModel 之间存在多对一关系。View 具有对 ViewModel 的引用，但 ViewModel 没有关于 View 的信息。 MVVM 容易产生的问题需要更多精力定位Bug。由于双向绑定，视图中的异常排查起来会比较麻烦。通用的 View 需要更好的设计。当一个 View 要变成通用组件时，该 View 对应的 Model 通常不能复用。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - ANR","slug":"Android-ANR","date":"2022-09-06T06:58:34.000Z","updated":"2023-07-14T04:40:17.261Z","comments":true,"path":"2022/09/06/Android-ANR/","link":"","permalink":"https://azxkenzo.github.io/2022/09/06/Android-ANR/","excerpt":"","text":"ANR 是什么ANR 全称 Application No Response；Android 设计 ANR 的用意，是系统通过与之交互的组件(Activity，Service，Receiver，Provider)以及用户交互(InputEvent)进行超时监控，以判断应用进程(主线程)是否存在卡死或响应过慢的问题。 组件超时系统在通过 Binder 通信向应用进程发送组件消息过 input 事件时，在 AMS 或 input 服务端同时设置一个异步超时监控。 类型 Timeout(s) 是否弹窗提示 备注 Activity 10 提示 Activity切换时会设置 Timeout Broadcast Receiver 10,60 无感知场景不会提示 Service 20 无感知场景不会提示 创建 Service 时会设置 Timeout ContentProvider 10 无感知场景不会提示 创建 provider 时会设置 Timeout Input Event 5 提示 厂商或平台商会调整此阈值，如8s Finalizer 10 Crash Broadcast 超时原理广播分为无序广播和有序广播，同时又有前台广播和后台广播之分。系统只针对有序广播设置超时监控机制，并根据前台广播和后台广播的类型决定了超时时长。后台广播超时时长为60s，前台广播超时时长为10s。 无序广播对于无序广播，系统在收集所有接收者之后一次性全部发送完毕。无序广播没有设置超时监听机制，一次性发送给所有接收者，对于应用侧何时接收和响应完全不关心。 有序广播在系统 AMS 服务中，BroadcastQueue 获取当前正在发送的广播消息，并取出下一个广播接收者，更新发送时间戳，以此时间计算并设置超时时间(系统在此进行了一些优化处理，以避免每次广播正常接收后，都需要取消超时监控然后又重新设置，而是采用一种对齐的方式进行复用)。最后将该广播发送给接收者，接收到客户端的完成通知后，再发送下一个。在客户端进程中，Binder 线程接收到 AMS 服务发送过来的广播消息之后，会将此消息封装成一个 Message，然后将 Message 发送到主线程消息队列(插入到消息队列当前时间节点的位置，也正是基于此设计导致较多消息调度及时性的问题)。正常情况下，很多广播请求都会在客户端及时响应，然后通知到系统 AMS 服务取消本次超时监控。但是在部分业务场景或系统场景异常到情况下，发送到广播未及时调度，没有及时通知到系统服务，便会在系统服务侧触发超时，判定应用进程响应超时。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - 事件分发机制","slug":"Android-事件分发机制","date":"2022-09-05T03:07:53.000Z","updated":"2023-07-18T04:22:50.366Z","comments":true,"path":"2022/09/05/Android-事件分发机制/","link":"","permalink":"https://azxkenzo.github.io/2022/09/05/Android-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/","excerpt":"","text":"基础知识MotionEventMotionEvent 是用于报告移动（鼠标、笔、手指、轨迹球）事件的对象。Motion Event 可能包含绝对或相对运动和其他数据，具体取决于设备的类型。 Motion Event 根据 action code 和一组 axis values 描述运动。action code 指定发生的状态变化，例如指针向下或向上。 axis values 描述位置和其他运动属性。 例如，当用户第一次触摸屏幕时，系统会使用 action code ACTION_DOWN 和一组 axis values（包括触摸的 X 和 Y 坐标以及有关接触区域的压力、大小和方向的信息）向适当的 View 传递 touch event。 一些设备可以同时报告多个移动轨迹。 多点触摸屏为每个手指发出一个移动轨迹。 生成运动轨迹的单个手指或其他对象称为 pointer。 Motion event 包含有关当前活动的所有 pointer 的信息，即使自上次事件传递以来其中一些 pointer 没有移动。 pointer 的数量只会随着单个 pointer 的上下移动而改变一个，除非手势被取消。 每个 pointer 都有一个唯一的 id，在它第一次下降时分配（由 ACTION_DOWN 或 ACTION_POINTER_DOWN 指示）。 pointer id 保持有效，直到 pointer 最终上升（由 ACTION_UP 或 ACTION_POINTER_UP 指示）或手势被取消（由 ACTION_CANCEL 指示）。 MotionEvent 类提供了许多方法来查询 pointer 的位置和其他属性，例如 getX(int)、getY(int)、getAxisValue、getPointerId(int)、getToolType(int) 等。 大多数这些方法接受 pointer 索引作为参数而不是 pointer id。 事件中每个 pointer 的 pointer 索引范围从 0 到比 getPointerCount() 返回的值小一。 单个 pointer 在运动事件中出现的顺序未定义。 因此，pointer 的 pointer 索引可以从一个事件更改为下一个事件，但只要 pointer 保持活动状态，pointer 的 pointer id 就保证保持不变。 使用 getPointerId(int) 方法获取 pointer 的 pointer ID，以在手势中的所有后续运动事件中跟踪它。 然后对于连续的运动事件，使用 findPointerIndex(int) 方法获取该运动事件中给定pointer id 的 pointer索引。 主要方法 Activity.dispatchTouchEvent()：调用以处理触摸屏事件。 可以重写它以在将所有触摸屏事件发送到 Window 之前拦截它们。 请务必为应该正常处理的触摸屏事件调用此实现。如果此事件被消费，则返回 true。 Activity.onTouchEvent()：当触摸屏事件未被其下的任何 View 处理时调用。 这对于处理发生在 window 边界之外的触摸事件最有用，因为那里没有 view 可以接收它。如果消费了该事件，则返回 true，否则返回 false。 默认实现始终返回 false。 View.dispatchTouchEvent()：将触摸屏运动事件向下传递给目标View，如果它是目标View，则传递给该View。如果事件被view处理了则为 true，否则为 false。 OnTouchListener.onTouch()：在触摸事件被分发给 view 时调用。 这使 listener 有机会在目标view之前做出响应。 View.onTouchEvent()：实现此方法来处理触摸屏运动事件。如果使用此方法检测 click 动作，建议通过实现并调用 performClick() 来执行动作。 这将确保一致的系统行为 ViewGroup.dispatchTouchEvent()：ViewGroup 将触摸事件分发给合适的子view来处理 ViewGroup.onInterceptTouchEvent()：实现这个方法来拦截所有的触摸屏运动事件。 这使可以在事件发送给children时查看事件，并随时掌握当前手势。使用此函数需要小心，因为它与 View.onTouchEvent(MotionEvent) 的交互相当复杂，并且使用它需要以正确的方式实现该方法和这个方法。 事件将按以下顺序接收： 将在这里收到 down 事件 down 事件将由该ViewGroup的子view处理，或者交给自己的 onTouchEvent() 方法来处理； 这意味着应该实现 onTouchEvent() 以返回 true，这样将继续看到手势的其余部分（而不是寻找父view来处理它）。 此外，通过从 onTouchEvent() 返回 true，将不会在 onInterceptTouchEvent() 中收到任何后续事件，并且所有触摸处理必须像往常一样在 onTouchEvent() 中进行。 只要从此函数返回 false，每个后续事件（直到并包括最后一个 up）将首先传递到此处，然后传递到目标的 onTouchEvent()。 如果从这里返回 true，将不会收到任何以下事件：目标view将收到相同的事件，但带有动作 MotionEvent.ACTION_CANCEL，并且所有其他事件将被传递到 onTouchEvent() 方法并且不再出现在这里。 事件传递顺序对于一个 MotionEvent，首先会分发给 Activity，接着再将其分发给 DecorView，通过 DecorView 再将事件向下逐级分发。如果向下分发到最后一个view后事件还没被消费，则再交给Activity的onTouchEvent处理 分发过程分析事件分发首先从 Activity.dispatchTouchEvent() 开始 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 这里，Activity 先调用 Window 的 superDispatchTouchEvent() 来处理事件 123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; Window 把事件交给 DecorView 去处理 123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);&#125; DecorView 调用父类也就是ViewGroup的 dispatchTouchEvent() 来处理事件。 ViewGroup 的事件分发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; // 过滤触摸事件以应用安全策略。如果应分派事件，则为 True；如果应删除事件，则为 false。 final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // 处理初始 down 事件. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // 开始新的触摸手势时丢弃所有先前的状态。 由于应用程序切换、ANR 或其他一些状态更改，框架可能已丢弃先前手势的up or cancel事件。 cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; // 子View可以通过调用父view的 requestDisallowInterceptTouchEvent 来请求禁止拦截事件 if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // 没有触摸目标，并且此操作不是初始 down，因此此ViewGroup会继续拦截触摸。 intercepted = true; &#125; // 如果被拦截，则开始正常的事件分发。 此外，如果已经有一个正在处理手势的view，请执行正常的事件调度。 if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // 如果需要，更新 pointer down 的触摸目标列表。 final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE; final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0 &amp;&amp; !isMouseEvent; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123; View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // down 事件的 actionIndex 总为 0 final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // 清除此 pointer ID 的早期触摸目标，以防它们变得不同步。 removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (childrenCount != 0) &#123; final float x = isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex); final float y = isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex); // 找到一个可以接收事件的child。 从前到后扫描children。 final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; // 如果子view (可见 或 当前相关联的Animation不为null) 且 事件坐标在子view区域内，则继续执行 // 获取指定子view的触摸目标。 如果找不到则返回 null。 newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child 已经正在其范围内接收touch。 除了它正在处理的pointer之外，还给它一个新的pointer。 newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); // dispatchTransformedTouchEvent 将 motion event 转换为特定子view的坐标空间，过滤掉不相关的pointer ID，并在必要时覆盖其action。 // 如果 child 为 null，则假定 MotionEvent 将改为发送到此 ViewGroup。 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); // addTouchTarget 中对 mFirstTouchTarget 进行了赋值 alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&#x27;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled;&#125; View 的事件分发12345678910111213141516171819202122232425262728293031323334353637public boolean dispatchTouchEvent(MotionEvent event) &#123; boolean result = false; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn&#x27;t want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result;&#125; 如果设置了 OnTouchListener，就先调用 OnTouchListener.onTouch()，再判断是否需要调用 onTouchEvent() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; if ((viewFlags &amp; ENABLED_MASK) == DISABLED &amp;&amp; (mPrivateFlags4 &amp; PFLAG4_ALLOW_CLICK_WHEN_DISABLED) == 0) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // clickable 的 disabled view 仍然会消费 touch event, 但是它不会做任何处理 return clickable; &#125; // 如果设置了 mTouchDelegate 就把事件交给它来处理，然后直接返回 true if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; // 事件为手指抬起时 case MotionEvent.ACTION_UP: mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; handleTooltipUp(); &#125; if (!clickable) &#123; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; &#125; boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don&#x27;t have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClickInternal(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123; mPrivateFlags3 |= PFLAG3_FINGER_DOWN; &#125; mHasPerformedLongPress = false; if (!clickable) &#123; checkForLongClick( ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS); break; &#125; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we&#x27;re inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick( ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS); &#125; break; case MotionEvent.ACTION_CANCEL: if (clickable) &#123; setPressed(false); &#125; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) &#123; drawableHotspotChanged(x, y); &#125; final int motionClassification = event.getClassification(); final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE; int touchSlop = mTouchSlop; if (ambiguousGesture &amp;&amp; hasPendingLongPressCallback()) &#123; if (!pointInView(x, y, touchSlop)) &#123; // The default action here is to cancel long press. But instead, we // just extend the timeout here, in case the classification // stays ambiguous. removeLongPressCallback(); long delay = (long) (ViewConfiguration.getLongPressTimeout() * mAmbiguousGestureMultiplier); // Subtract the time already spent delay -= event.getEventTime() - event.getDownTime(); checkForLongClick( delay, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS); &#125; touchSlop *= mAmbiguousGestureMultiplier; &#125; // Be lenient about moving outside of buttons if (!pointInView(x, y, touchSlop)) &#123; // Outside button // Remove any future long press/tap checks removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; &#125; final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS; if (deepPress &amp;&amp; hasPendingLongPressCallback()) &#123; // process the long click action immediately removeLongPressCallback(); checkForLongClick( 0 /* send immediately */, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS); &#125; break; &#125; return true; &#125; return false;&#125; 处理逻辑： 事件为 ACTION_UP 时：如果带有 PFLAG_PRESSED 或 PFLAG_PREPRESSED 标志，则调用 performClickInternal 处理点击事件 事件为 ACTION_DOWN 时：处理长按事件 事件为 ACTION_MOVE 主要方法 Activity.dispatchTouchEvent() Activity.onTouchEvent() Window.superDispatchTouchEvent() ViewGroup.dispatchTouchEvent() ViewGroup.onInterceptTouchEvent() View.dispatchTouchEvent() View.onTouchListener.onTouch() View.onTouchEvent() TouchDelegate.onTouchEvent() View.performClickInternal() View.performClick() View.OnClickListener.onClick() View.performLongClickInternal() View.onLongClickListener.onLongClick()","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - Broadcast","slug":"Android-Broadcast","date":"2022-09-04T03:50:49.000Z","updated":"2023-07-14T04:40:17.261Z","comments":true,"path":"2022/09/04/Android-Broadcast/","link":"","permalink":"https://azxkenzo.github.io/2022/09/04/Android-Broadcast/","excerpt":"","text":"应用可以发送或接收来自系统和其他应用的广播消息。当感兴趣的事件发生时发送这些广播。例如，系统会在各种系统事件发生时发送广播，例如系统启动时或设备开始充电时。应用程序还可以发送自定义广播，例如，通知其他应用程序他们可能感兴趣的内容（例如，一些新数据已下载）。 应用程序可以注册以接收特定广播。发送广播时，系统会自动将广播路由到已订阅接收该特定类型广播的应用程序。 一般来说，广播可以用作跨应用程序和正常用户流之外的消息传递系统。但是，必须小心不要滥用响应广播和在后台运行job的机会，这可能会导致系统性能下降。 关于系统广播当各种系统事件发生时，系统会自动发送广播，例如当系统切换到飞行模式时。系统广播被发送到所有订阅接收事件的应用程序。 广播消息本身包装在一个 Intent 对象中，该对象的 action 字符串标识发生的事件（例如 android.intent.action.AIRPLANE_MODE）。intent还可能包括捆绑到其 extra 字段中的附加信息。例如，飞行模式intent包括一个布尔 extra，指示飞行模式是否打开。 有关系统广播操作的完整列表，请参阅 Android SDK 中的 BROADCAST_ACTIONS.TXT 文件。每个广播动作都有一个与之关联的常量字段。例如，常量 ACTION_AIRPLANE_MODE_CHANGED 的值为 android.intent.action.AIRPLANE_MODE。每个广播动作的文档都在其关联的常量字段中可用。 系统广播的变化Android 9从 Android 9（API 级别 28）开始，NETWORK_STATE_CHANGED_ACTION 广播不会接收有关用户位置或个人身份数据的信息。 此外，如果您的应用安装在运行 Android 9 或更高版本的设备上，则来自 Wi-Fi 的系统广播不包含 SSID、BSSID、连接信息或扫描结果。 要获取此信息，请改为调用 getConnectionInfo()。 Android 8.0从 Android 8.0（API 级别 26）开始，系统对清单声明的接收器施加了额外的限制。 如果应用面向 Android 8.0 或更高版本，则不能使用清单为大多数隐式广播（不专门针对您的应用的广播）声明接收器。 当用户积极使用您的应用程序时，您仍然可以使用上下文注册的接收器。 接收广播应用程序可以通过两种方式接收广播：通过清单声明的接收器和上下文注册的接收器。 Manifest-declared receivers如果在清单中声明broadcast receiver，则系统会在发送广播时启动应用程序（如果应用程序尚未运行）。注意：如果应用以 API 级别 26 或更高级别为目标，则不能使用清单为隐式广播（不专门针对您的应用的广播）声明 receiver，但一些不受该限制的隐式广播除外。在大多数情况下，可以改用 scheduled jobs。 要在清单中声明broadcast receiver，执行以下步骤： 在应用的清单中指定 &lt;receiver&gt; 元素。 123456&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt; &lt;action android:name=&quot;android.intent.action.INPUT_METHOD_CHANGED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; intent filters 指定receiver订阅的广播action。 继承 BroadcastReceiver 并实现 onReceive(Context, Intent)。 系统package manager在安装应用程序时注册receiver。 然后receiver成为应用程序的单独入口点，这意味着如果应用程序当前未运行，系统可以启动应用程序并传送广播。 系统创建一个新的 BroadcastReceiver 组件对象来处理它接收到的每个广播。 此对象仅在调用 onReceive(Context, Intent) 期间有效。一旦代码从此方法返回，系统就会认为该组件不再处于活动状态。 Context-registered receivers 创建 BroadcastReceiver 对象 创建一个 IntentFilter 并通过调用 registerReceiver(BroadcastReceiver, IntentFilter) 注册receiver 注意：要注册本地广播，请改为调用 LocalBroadcastManager.registerReceiver(BroadcastReceiver, IntentFilter)。 只要注册上下文有效，上下文注册的receiver就会接收广播。 例如，如果在 Activity 上下文中注册，只要该 Activity 未被销毁，就会收到广播。如果在应用程序上下文中注册，只要应用程序正在运行，就会收到广播。 要停止接收广播，请调用 unregisterReceiver(android.content.BroadcastReceiver)。 当不再需要receiver或上下文不再有效时，请务必取消注册receiver。请注意注册和取消注册接收器的地方，例如，如果使用activity的上下文在 onCreate(Bundle) 中注册接收器，则应在 onDestroy() 中取消注册它以防止将receiver泄漏到activity上下文之外。如果你在 onResume() 中注册了一个接收器，你应该在 onPause() 中取消注册它以防止它被多次注册（如果不想在暂停时接收广播，这可以减少不必要的系统开销）。不要在 onSaveInstanceState(Bundle) 中取消注册，因为如果用户移回历史堆栈，则不会调用它。 对进程状态的影响BroadcastReceiver 的状态（无论它是否正在运行）会影响其包含进程的状态，这反过来又会影响其被系统杀死的可能性。例如，当一个进程执行一个receiver（即当前正在运行其 onReceive() 方法中的代码）时，它被认为是一个前台进程。系统保持进程运行，除非在内存压力很大的情况下。 但是，一旦您的代码从 onReceive() 返回，BroadcastReceiver 就不再处于活动状态。receiver的宿主进程变得与运行在其中的其他应用程序组件一样重要。如果该进程仅托管一个清单声明的receiver（用户从未或最近未与之交互的应用程序的常见情况），则在从 onReceive() 返回时，系统将其进程视为低优先级进程，并且可能杀死它以使资源可用于其他更重要的进程。 因此，不应从广播receiver启动长时间运行的后台线程。在 onReceive() 之后，系统可以随时终止进程以回收内存，并在此过程中终止进程中运行的衍生线程。为避免这种情况，应该调用 goAsync()（如果想要更多时间在后台线程中处理广播）或使用 JobScheduler 从receiver调度 JobService，以便系统知道该进程继续执行活动工作。 以下代码片段显示了一个 BroadcastReceiver，它使用 goAsync() 来标记它在 onReceive() 完成后需要更多时间来完成。如果您要在 onReceive() 中完成的工作足够长以导致 UI 线程错过一帧（&gt;16 毫秒），这将特别有用，使其更适合后台线程。 1234567891011121314151617181920212223242526class MyBroadcastReceiver : BroadcastReceiver() &#123; private val scope = CoroutineScope(SupervisorJob()) override fun onReceive(context: Context, intent: Intent) &#123; val pendingResult: PendingResult = goAsync() scope.launch(Dispatchers.Default) &#123; try &#123; // Do some background work buildString &#123; append(&quot;Action: &quot;).append(intent.action).append(&quot;\\n&quot;) append(&quot;URI: &quot;).append(intent.toUri(Intent.URI_INTENT_SCHEME)).append(&quot;\\n&quot;) &#125;.also &#123; log -&gt; Log.d(TAG, log) &#125; &#125; finally &#123; // Must call finish() so the BroadcastReceiver can be recycled pendingResult.finish() &#125; &#125; &#125; companion object &#123; private const val TAG = &quot;MyBroadcastReceiver&quot; &#125;&#125; 发送广播Android 提供了三种应用发送广播的方式： sendOrderedBroadcast(Intent, String) 方法一次向一个receiver发送广播。当每个receiver依次执行时，它可以将结果传播给下一个receiver，或者它可以完全中止广播， 这样它就不会被传递给其他receiver。运行的order receiver可以通过匹配intent-filter的android:priority属性来控制；具有相同优先级的接收器将以任意顺序运行。 sendBroadcast(Intent) 方法以未定义的顺序向所有接收者发送广播。这称为正常广播。这更有效，但意味着receiver无法从其他receiver读取结果、传播从广播接收到的数据或中止广播。 LocalBroadcastManager.sendBroadcast 方法将广播发送到与发送者在同一应用程序中的receiver。如果不需要跨应用发送广播，请使用本地广播。该实现更加高效（不需要进程间通信），无需担心与其他应用程序能够接收或发送您的广播相关的任何安全问题。 12345Intent().also &#123; intent -&gt; intent.setAction(&quot;com.example.broadcast.MY_NOTIFICATION&quot;) intent.putExtra(&quot;data&quot;, &quot;Nothing to see here, move along.&quot;) sendBroadcast(intent)&#125; 广播消息被包装在一个 Intent 对象中。 intent的action字符串必须提供应用程序的 Java 包名称语法并唯一标识广播事件。可以使用 putExtra(String, Bundle) 将附加信息附加到intent。 还可以通过在 Intent 上调用 setPackage(String) 将广播限制为同一组织中的一组应用程序。 使用权限限制广播权限允许将广播限制为拥有某些权限的应用程序集。 可以对广播的发送者或接收者实施限制。 Sending with permissions在调用 sendBroadcast(Intent, String) 或 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle) 时，可以指定权限参数。只有在清单中使用标签请求许可的接收者（如果有危险，随后被授予许可）才能接收广播。 例如，以下代码发送广播： 1sendBroadcast(Intent(&quot;com.example.NOTIFY&quot;), Manifest.permission.SEND_SMS) 要接收广播，接收应用程序必须请求权限，如下所示： 1&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt; 可以指定现有的系统权限（如 SEND_SMS）或使用 &lt;permission&gt; 元素定义自定义权限。 注意：自定义权限是在安装应用程序时注册的。 定义自定义权限的应用程序必须在使用它的应用程序之前安装。 Receiving with permissions如果在注册广播receiver时指定权限参数（使用 registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) 或在清单中的 &lt;receiver&gt; 标记中），则只有使用 &lt;uses-permission&gt; 请求权限的广播者 清单中的标签（如果危险，随后被授予许可）可以向receiver发送 Intent。 12345678910&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:permission=&quot;android.permission.SEND_SMS&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.AIRPLANE_MODE&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;var filter = IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED)registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, null ) 安全注意事项和最佳实践 如果您不需要向应用程序外部的组件发送广播，请使用支持库中提供的 LocalBroadcastManager 发送和接收本地广播。 LocalBroadcastManager 效率更高（不需要进程间通信），并且允许您避免考虑与其他应用程序能够接收或发送您的广播相关的任何安全问题。 本地广播可以用作您的应用程序中的通用发布&#x2F;订阅事件总线，而无需任何系统范围广播的开销。 如果许多应用程序在其清单中注册接收相同的广播，则可能导致系统启动大量应用程序，从而对设备性能和用户体验造成重大影响。 为了避免这种情况，最好使用上下文注册而不是清单声明。 有时，Android 系统本身会强制使用上下文注册的接收器。 例如，CONNECTIVITY_ACTION 广播仅传递给上下文注册的接收器。 不要使用隐含的意图广播敏感信息。 任何注册接收广播的应用程序都可以读取该信息。有三种方法可以控制谁可以接收您的广播： 在发送广播时指定权限。 在 Android 4.0 及更高版本中，您可以在发送广播时使用 setPackage(String) 指定一个包。 系统将广播限制为与包匹配的应用程序集。 使用 LocalBroadcastManager 发送本地广播。 当注册接收器时，任何应用都可以向您应用的接收器发送潜在的恶意广播。 有三种方法可以限制您的应用接收的广播： 在注册广播接收器时指定权限。 对于清单声明的接收者，在清单中将 android:exported 属性设置为“false”。 接收方不接收来自应用程序外部来源的广播。 使用 LocalBroadcastManager 将自己限制为仅本地广播。 广播action的命名空间是全局的。 确保动作名称和其他字符串写在您拥有的命名空间中，否则您可能会无意中与其他应用程序发生冲突。 因为接收者的 onReceive(Context, Intent) 方法在主线程上运行，所以它应该快速执行并返回。 如果您需要执行长时间运行的工作，请注意生成线程或启动后台服务，因为系统可以在 onReceive() 返回后终止整个进程。 不要从广播接收器开始activity，因为用户体验不和谐； 特别是如果有不止一个接收器。 相反，请考虑显示通知。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - Process 和 Thread","slug":"Android-Process-和-Thread","date":"2022-09-04T03:24:55.000Z","updated":"2023-07-14T04:40:17.261Z","comments":true,"path":"2022/09/04/Android-Process-和-Thread/","link":"","permalink":"https://azxkenzo.github.io/2022/09/04/Android-Process-%E5%92%8C-Thread/","excerpt":"","text":"当一个应用程序组件启动并且该应用程序没有任何其他组件在运行时，Android 系统会为该应用程序启动一个新的 Linux 进程，并使用单线程执行。默认情况下，同一个应用程序的所有组件都运行在同一个进程和线程中（称为“main”线程）。 如果应用程序组件启动并且已经存在该应用程序的进程（因为该应用程序的另一个组件存在），则该组件在该进程内启动并使用相同的执行线程。但是，可以安排应用程序中的不同组件在单独的进程中运行，并且可以为任何进程创建额外的线程。 Process默认情况下，同一应用程序的所有组件都在同一进程中运行，大多数应用程序不应更改这一点。 但是，如果发现需要控制某个组件属于哪个进程，则可以在清单文件中进行。 每种类型的组件元素 &lt;activity&gt;、&lt;service&gt;、&lt;receiver&gt; 和 &lt;provider&gt; 的清单条目都支持 android:process 属性，该属性可以指定该组件应在其中运行的进程。可以设置此属性，以便每个组件在其自己的进程中运行，或者使某些组件共享一个进程而其他组件不共享。 还可以设置 android:process 以便不同应用程序的组件在同一个进程中运行——前提是这些应用程序共享相同的 Linux 用户 ID 并使用相同的证书进行签名。 &lt;application&gt; 元素还支持 android:process 属性，以设置适用于所有组件的默认值。 当其他更直接为用户服务的进程需要资源时，Android 可能会决定关闭某个进程。 在被杀死的进程中运行的应用程序组件因此被破坏。 当这些组件再次有工作要做时，将再次为这些组件启动一个流程。 在决定要杀死哪些进程时，Android 系统会权衡它们对用户的相对重要性。 例如，与托管可见activity的进程相比，它更容易关闭托管在屏幕上不再可见的activity的进程。因此，是否终止进程的决定取决于在该进程中运行的组件的状态。 Thread当应用程序启动时，系统会为应用程序创建一个执行线程，称为“main”。 这个线程非常重要，因为它负责将事件分派给适当的用户界面小部件，包括绘图事件。它也几乎总是应用程序与来自 Android UI 工具包的组件（来自 android.widget 和 android.view 包的组件）交互的线程。 因此，主线程有时也称为 UI 线程。但是，在特殊情况下，应用程序的主线程可能不是它的 UI 线程； 有关详细信息，请参阅线程注释。 系统不会为组件的每个实例创建单独的线程。 在同一进程中运行的所有组件都在 UI 线程中实例化，并且从该线程分派对每个组件的系统调用。因此，响应系统回调的方法（例如用于报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的 UI 线程中运行。 例如，当用户触摸屏幕上的按钮时，应用程序的 UI 线程将触摸事件分派给小部件，小部件反过来设置其按下状态并将无效请求发送到事件队列。 UI 线程将请求出列并通知小部件它应该重绘自己。 当应用程序执行密集工作以响应用户交互时，除非正确实现应用程序，否则这种单线程模型可能会产生较差的性能。具体来说，如果一切都发生在 UI 线程中，那么执行网络访问或数据库查询等长时间操作将阻塞整个 UI。当线程被阻塞时，不能调度任何事件，包括绘图事件。 从用户的角度来看，应用程序似乎挂起。更糟糕的是，如果 UI 线程被阻塞超过几秒（目前大约 5 秒），用户会看到臭名昭著的“应用程序无响应”（ANR）对话框。 此外，Android UI 工具包不是线程安全的。 因此，不能从工作线程操作 UI — 必须从 UI 线程对用户界面进行所有操作。 因此，Android 的单线程模型只有两条规则： 不要阻塞 UI 线程 不要从 UI 线程外部访问 Android UI 工具包 Worker thread由于上述单线程模型，不阻塞 UI 线程对应用程序 UI 的响应能力至关重要。 如果要执行的操作不是即时的，则应确保在单独的线程（“后台”或“工作”线程）中执行它们。 但是，请注意，不能从 UI 线程或“main”线程以外的任何线程更新 UI。 为了解决这个问题，Android 提供了几种从其他线程访问 UI 线程的方法： Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) 要处理与工作线程更复杂的交互，可能会考虑在工作线程中使用 Handler 来处理从 UI 线程传递的消息。 Thread-safe methods在某些情况下，实现的方法可能会从多个线程调用，因此必须编写为线程安全的。 这主要适用于可以远程调用的方法——例如bound service中的方法。 当对 IBinder 中实现的方法的调用源自运行 IBinder 的同一进程时，该方法将在调用者的线程中执行。但是，当调用源自另一个进程时，该方法会在从系统维护的与 IBinder 相同的进程中的线程池中选择的线程中执行（它不在进程的 UI 线程中执行）。例如，服务的 onBind() 方法将从服务进程的 UI 线程调用，而在 onBind() 返回的对象（例如，实现 RPC 方法的子类）中实现的方法将从线程池调用。因为一个服务可以有多个客户端，多个池线程可以同时使用同一个 IBinder 方法。 因此，IBinder 方法必须实现为线程安全的。 类似地，content provider可以接收源自其他进程的数据请求。 尽管 ContentResolver 和 ContentProvider 类隐藏了如何管理进程间通信的细节，但响应这些请求的 ContentProvider 方法——方法 query()、insert()、delete()、update() 和 getType()——从content provider进程中的线程池调用，而不是进程的 UI 线程。因为这些方法可能同时从任意数量的线程调用，所以它们也必须实现为线程安全的。 Interprocess communicationAndroid 提供了一种使用远程过程调用 (RPC) 进行进程间通信 (IPC) 的机制，其中方法由 Activity 或其他应用程序组件调用，但远程执行（在另一个进程中）， 并将任何结果返回给调用者。这需要将方法调用及其数据分解到操作系统可以理解的水平，将其从本地进程和地址空间传输到远程进程和地址空间，然后在那里重新组装和重新制定调用。 然后返回值以相反的方向传输。Android 提供了执行这些 IPC 事务的所有代码，因此可以专注于定义和实现 RPC 编程接口。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - ContentProvider","slug":"Android-ContentProvider","date":"2022-09-03T00:58:25.000Z","updated":"2023-07-14T04:40:17.261Z","comments":true,"path":"2022/09/03/Android-ContentProvider/","link":"","permalink":"https://azxkenzo.github.io/2022/09/03/Android-ContentProvider/","excerpt":"","text":"ContentProvider 是什么ContentProvider可以帮助应用程序管理对自己存储的、由其他应用程序存储的数据的访问，并提供一种与其他应用程序共享数据的方式。它们封装数据，并提供定义数据安全性的机制。 ContentProvider是将一个进程中的数据与另一个进程中运行的代码连接起来的标准接口。 基础Content URIContent URI 是标识 provider 中数据的 URI。 Content URI 包括整个provider的符号名称（其authority）和指向表的名称（path）。当调用客户端方法来访问provider中的表时，表的Content URI 是参数之一。 ContentResolver 对象解析出 URI 的authority，并使用它通过将authority与已知provider的系统表进行比较来“解析”provider。然后 ContentResolver 可以将查询参数分派给正确的provider。 ContentProvider 使用Content URI 的path部分来选择要访问的表。 provider通常为其公开的每个表都有一个path。 字符串 content://（scheme）始终存在，并将其标识为Content URI。 注意： Uri 和 Uri.Builder 类包含用于从字符串构造格式良好的 URI 对象的便捷方法。 ContentUris 类包含用于将 id 值附加到 URI 的便捷方法。 从 provider 获取数据要从provider检索数据，请执行以下基本步骤： 请求provider的读取访问权限。 定义向provider发送查询的代码。 请求读取权限要从provider检索数据，应用程序需要provider的“读取访问权限”。不能在运行时请求此权限；相反，必须使用 &lt;uses-permission&gt; 元素和provider定义的确切权限名称在清单中指定需要此权限。当在清单中指定此元素时，实际上是在为应用程序“请求”此权限。当用户安装应用程序时，他们会隐式授予此请求。 构造查询provider客户端查询类似于 SQL 查询，它包含一组要返回的列、一组选择条件和一个排序顺序。 查询应返回的列集称为 projection。 指定要检索的行的表达式被拆分为选择子句和选择参数。 选择子句是逻辑和布尔表达式、列名和值的组合。 如果指定可替换参数? 而不是一个值，查询方法从选择参数数组中检索值。 防止恶意输入如果ContentProvider管理的数据在 SQL 数据库中，将外部不受信任的数据包含在原始 SQL 语句中可能会导致 SQL 注入。 12// Constructs a selection clause by concatenating the user&#x27;s input to the column namevar selectionClause = &quot;var = $mUserInput&quot; 如果这样做，就允许用户将恶意 SQL 连接到 SQL 语句中。 例如，用户可以输入“nothing; DROP TABLE *;” 对于 mUserInput，这将导致选择子句 var = nothing; DROP TABLE *;。由于选择子句被视为 SQL 语句，这可能会导致提供程序删除底层 SQLite 数据库中的所有表（除非provider设置为捕获 SQL 注入尝试）。 为避免此问题，请使用选择子句，该子句使用 ? 作为可替换参数和单独的选择参数数组。 执行此操作时，用户输入将直接绑定到查询，而不是被解释为 SQL 语句的一部分。因为它不被当作 SQL，所以用户输入不能注入恶意 SQL。 从查询结果中获取数据Cursor 实现包含几个“get”方法，用于从对象中检索不同类型的数据。它们还有一个 getType() 方法，该方法返回一个指示列的数据类型的值。 Content provider permissionprovider的应用程序可以指定其他应用程序必须具有的权限才能访问provider的数据。这些权限确保用户知道应用程序将尝试访问哪些数据。根据provider的要求，其他应用程序请求他们需要的权限以访问provider。最终用户在安装应用程序时会看到请求的权限。 如果provider的应用程序未指定任何权限，则其他应用程序无权访问提供者的数据，除非provider is exported。此外，provider应用程序中的组件始终具有完全的读写访问权限，而不管指定的权限如何。 为了获得访问provider所需的权限，应用程序在其清单文件中使用 &lt;uses-permission&gt; 元素来请求它们。当 Android 包管理器安装应用程序时，用户必须批准应用程序请求的所有权限。如果用户同意所有这些，包管理器将继续安装；如果用户不同意，包管理器会中止安装。 插入、更新和删除数据插入数据要将数据插入provider，调用 ContentResolver.insert() 方法。 此方法将新行插入provider并返回该行的content URI。 要从返回的 Uri 中获取 _ID 的值，调用 ContentUris.parseId()。 更新数据要更新行，可以像使用插入一样使用带有更新值的 ContentValues 对象，并像使用查询一样使用选择条件。 使用的客户端方法是 ContentResolver.update()。只需为要更新的列向 ContentValues 对象添加值。 如果要清除列的内容，请将值设置为 null。 删除数据删除行类似于检索行数据：为要删除的行指定选择标准，客户端方法返回已删除行的数量。 Provider 数据类型Provider 为他们定义的每个content URI 维护 MIME 数据类型信息。可以使用 MIME 类型信息来确定应用程序是否可以处理Provider提供的数据，或者根据 MIME 类型选择一种处理类型。当使用包含复杂数据结构或文件的provider时，通常需要 MIME 类型。例如，Contacts Provider 中的 ContactsContract.Data 表使用 MIME 类型来标记存储在每一行中的联系人数据的类型。要获取与content URI 对应的 MIME 类型，调用 ContentResolver.getType()。 provider访问的替代形式provider访问的三种替代形式在应用程序开发中很重要： Batch access(批量访问)：可以使用 ContentProviderOperation 类中的方法创建批量访问调用，然后使用 ContentResolver.applyBatch() 应用它们。 异步查询：应该在单独的线程中进行查询。 通过intent访问数据：虽然不能直接向provider发送意图，但可以向provider的应用程序发送intent，这通常是修改provider数据的最佳设备。 Batch access对provider的批量访问对于插入大量行，或在同一方法调用中在多个表中插入行，或通常用于跨进程边界执行一组操作作为事务（原子操作）很有用。 要以“批处理模式”访问提供者，需要创建一个 ContentProviderOperation 对象数组，然后使用 ContentResolver.applyBatch() 将它们分派给content provider。将content provider的 authority 传递给此方法，而不是特定的content URI。 这允许数组中的每个 ContentProviderOperation 对象针对不同的表工作。对 ContentResolver.applyBatch() 的调用会返回一个结果数组。 通过intent访问数据intent可以提供对content provider的间接访问。 即使应用程序没有访问权限，也允许用户访问provider中的数据，方法是从具有权限的应用程序返回结果intent，或者通过激活具有权限的应用程序并让用户在其中工作。 使用临时权限获取访问权限即使没有适当的访问权限，也可以访问content provider中的数据，方法是向具有权限的应用程序发送intent并接收包含“URI”权限的结果intent。这些是特定content URI 的权限，持续到接收它们的activity finish。 具有永久权限的应用程序通过在结果intent中设置标志来授予临时权限： Read permission: FLAG_GRANT_READ_URI_PERMISSION Write permission: FLAG_GRANT_WRITE_URI_PERMISSION 注意：这些标志不授予权限包含在content URI 中的provider的一般读取或写入访问权限。 访问仅针对 URI 本身。 当你将content URI 发送到另一个应用程序时，请至少包含这些标志中的一个。 这些标志为接收intent并以 Android 11（API 级别 30）或更高版本为目标的任何应用提供以下功能： 根据intent中包含的标志，读取或写入content URI 表示的数据。 获得对包含与 URI 权限匹配的content provider的应用程序的包可见性。 请注意，发送intent的应用程序和包含content provider的应用程序可能是两个不同的应用程序。 provider使用 &lt;provider&gt; 元素的 android:grantUriPermission 属性以及 &lt;provider&gt; 元素的 &lt;grant-uri-permission&gt; 子元素在其清单中定义content URI 的 URI 权限。 例如，即使没有 READ_CONTACTS 权限，也可以在 Contacts Provider 中检索联系人的数据。 可能希望在一个应用程序中执行此操作，该应用程序会在联系人生日时向其发送电子问候语。与请求 READ_CONTACTS 相比，它允许访问所有用户的联系人及其所有信息，您更愿意让用户控制应用程序使用哪些联系人。 为此，使用以下过程： 应用程序使用 startActivityForResult() 方法发送包含操作 ACTION_PICK 和“contacts”MIME 类型 CONTENT_ITEM_TYPE 的intent。 因为这个intent与 People 应用程序的“selection”activity的intent过滤器相匹配，所以activity将出现在前台。 在selection activity中，用户选择要更新的联系人。发生这种情况时，selection activity会调用 setResult(resultcode, intent) 来设置一个返回给您的应用程序的intent。intent包含用户选择的联系人的content URI，以及“extras”标志 FLAG_GRANT_READ_URI_PERMISSION。这些标志向您的应用授予 URI 权限，以读取内容 URI 指向的联系人的数据。然后，selection activity调用 finish() 以将控制权返回给您的应用程序。 您的activity返回到前台，系统调用您的activity的 onActivityResult() 方法。此方法接收由 People 应用程序中的selection activity创建的结果intent。 使用结果intent中的content URI，可以从Contacts Provider读取联系人的数据，即使没有在清单中请求对provider的永久读取访问权限。然后，可以获取联系人的生日信息或他们的电子邮件地址，然后发送电子贺卡。 使用另一个应用程序允许用户修改您没有访问权限的数据的一种简单方法是激活具有权限的应用程序并让用户在那里完成工作。 例如，日历应用程序接受一个 ACTION_INSERT intent，它允许您激活应用程序的insert UI。 可以在此intent中传递“extras”数据，应用程序使用这些数据来预填充 UI。 因为重复事件具有复杂的语法，将事件插入日历提供程序的首选方法是使用 ACTION_INSERT 激活日历应用程序，然后让用户在其中插入事件。 常量类常量类定义了帮助应用程序使用content URI、列名、intent action和content provider的其他功能的常量。 常量类不会自动包含在provider中；provider的开发者必须定义它们，然后将它们提供给其他开发者。 Android 平台包含的许多provider在 android.provider 包中都有相应的常量类。 MIME 类型参考Content provider可以返回标准 MIME 媒体类型或自定义 MIME 类型字符串，或两者兼而有之。 MIME 类型的格式为: 1type/subtype 自定义 MIME 类型字符串，也称为“vendor-specific”MIME 类型，具有更复杂的类型和子类型值。 type值总是 1vnd.android.cursor.dir 对于多行，或 1vnd.android.cursor.item 对于单行。 subtype是provider-specific。 Android 内置提供程序通常有一个简单的子类型。 例如，当联系人应用程序为电话号码创建一行时，它会在该行中设置以下 MIME 类型： 1vnd.android.cursor.item/phone_v2 其他provider开发人员可以根据provider的authority和表名创建自己的subtype模式。例如，考虑一个包含火车时刻表的provider。 provider的authority是 com.example.trains，它包含表 Line1、Line2 和 Line3。 响应content URI 1content://com.example.trains/Line1 对于表 Line1，provider返回 MIME 类型 1vnd.android.cursor.dir/vnd.example.line1 响应内容 URI 1content://com.example.trains/Line2/5 对于表 Line2 中的第 5 行，提供程序返回 MIME 类型 1vnd.android.cursor.item/vnd.example.line2 创建ContentProvider设计 content URI设计 authorityprovider通常只有一个authority，作为其 Android 内部名称。 为避免与其他provider发生冲突，应该使用 Internet 域所有权（反向）作为您的provider authority的基础。由于此建议也适用于 Android 包名称，因此可以将provider authority定义为包含provider的包名称的扩展。 例如，如果你的 Android 包名称是 com.example.，你应该给你的提供者权限 com.example..provider。 设计 path 结构通常通过附加指向各个表的路径来从authority创建内容 URI。 例如，如果您有两个表 table1 和 table2，则结合前面示例中的权限以生成内容 URI com.example..provider&#x2F;table1 和 com.example..provider&#x2F;table2。Path不限于单个段，并且path的每个级别都不是必须有一个表。 处理 content URI ID按照惯例，provider通过接受内容 URI 来提供对表中单行的访问，该内容 URI 具有 URI 末尾的行的 ID 值。 同样按照惯例，provider将 ID 值与表的 _ID 列匹配，并对匹配的行执行请求的访问。 content URI 模式为了帮助选择对传入content URI 采取的操作，provider API 包含便利类 UriMatcher，它将content URI“pattern”映射到整数值。可以在 switch 语句中使用整数值，为与特定模式匹配的content URI 或 URI 选择所需的操作。 content URI 模式使用通配符匹配内容 URI： *：匹配任意长度的任意有效字符的字符串。 #：匹配任意长度的数字字符串。 实现 ContentProvider 类所需方法抽象类 ContentProvider 定义了六个抽象方法，您必须将它们实现为您自己的具体子类的一部分。 除了 onCreate() 之外的所有这些方法都由试图访问您的内容提供者的客户端应用程序调用： query() 使用参数选择要查询的表、要返回的行和列以及结果的排序顺序。 将数据作为 Cursor 对象返回。 insert() 使用参数选择目标表并获取要使用的列值。 返回新插入行的内容 URI。 update() 使用参数选择要更新的表和行并获取更新的列值。 返回更新的行数。 delete() 使用参数选择要删除的表和行。 返回删除的行数。 getType() 返回与内容 URI 对应的 MIME 类型。 onCreate() 初始化 Provider。 Android 系统在创建 Provider 后立即调用此方法。 请注意，在 ContentResolver 对象尝试访问它之前，不会创建 Provider。实际测试结果是：应用进程启动时就会调用 onCreate()，在 Activity.onCreate() 之前调用。 对这些方法的实施应考虑以下因素： 除了 onCreate() 之外的所有这些方法都可以被多个线程同时调用，因此它们必须是线程安全的。 避免在 onCreate() 中执行冗长的操作。 推迟初始化任务，直到真正需要它们。 尽管必须实现这些方法，但您的代码除了返回预期的数据类型外无需执行任何操作。 例如，您可能希望阻止其他应用程序将数据插入某些表中。 为此，您可以忽略对 insert() 的调用并返回 0。 实现 query()ContentProvider.query() 方法必须返回一个 Cursor 对象，否则如果失败，则抛出异常。如果使用 SQLite 数据库作为数据存储，可以简单地返回由 SQLiteDatabase 类的 query() 方法之一返回的 Cursor。如果查询不匹配任何行，则应返回其 getCount() 方法返回 0 的 Cursor 实例。仅当查询过程中发生内部错误时才应返回 null。 如果不使用 SQLite 数据库作为数据存储，请使用 Cursor 的具体子类之一。例如，MatrixCursor 类实现了一个cursor，其中每一行都是一个 Object 数组。使用此类，使用 addRow() 添加新行。 请记住，Android 系统必须能够跨进程边界传递异常。 Android 可以针对以下可能有助于处理查询错误的异常执行此操作： IllegalArgumentException（如果您的提供者收到无效的内容 URI，您可以选择抛出此异常） NullPointerException 实现 insert()实现 delete()delete() 方法不必从数据存储中物理删除行。 如果您在提供程序中使用同步适配器，则应考虑使用“删除”标志标记已删除的行，而不是完全删除该行。 同步适配器可以检查已删除的行并将它们从服务器中删除，然后再从提供程序中删除它们。 实现 update()实现 onCreate()Android 系统在启动提供程序时调用 onCreate()。 您应该在此方法中只执行快速运行的初始化任务，并推迟数据库创建和数据加载，直到提供者实际收到对数据的请求。 如果您在 onCreate() 中执行冗长的任务，您将减慢提供程序的启动速度。 反过来，这将减慢提供程序对其他应用程序的响应。 实现 ContentProvider MIME TypesContentProvider 类有两种返回 MIME 类型的方法： getType() 必须为任何provider实现的必需方法之一。 getStreamTypes() 如果provider提供文件，应该实现的方法。 表的 MIME 类型getType() 方法返回一个 MIME 格式的String，该字符串描述了content URI 参数返回的数据类型。 Uri 参数可以是模式而不是特定的 URI； 在这种情况下，应该返回与匹配模式的content URI 关联的数据类型。 对于文本、HTML 或 JPEG 等常见数据类型，getType() 应返回该数据的标准 MIME 类型。 IANA MIME 媒体类型网站上提供了这些标准类型的完整列表。 对于指向一行或多行表数据的content URI，getType() 应返回 Android 供应商特定 MIME 格式的 MIME 类型 文件的 MIME 类型如果provider提供文件，请实现 getStreamTypes()。 该方法为provider可以为给定content URI 返回的文件返回 MIME 类型的 String 数组。应该通过 MIME 类型过滤器参数过滤提供的 MIME 类型，以便只返回客户端想要处理的那些 MIME 类型。 例如，考虑一个以 .jpg、.png 和 .gif 格式的文件提供照片图像的provider。 如果应用程序使用过滤器字符串 image&#x2F;*（即“图像”）调用 ContentResolver.getStreamTypes()，则 ContentProvider.getStreamTypes() 方法应返回数组： 1&#123; &quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;&#125; 如果应用只对 .jpg 文件感兴趣，那么它可以使用过滤字符串 *\\/jpeg 调用 ContentResolver.getStreamTypes()，并且 ContentProvider.getStreamTypes() 应该返回： 1&#123;&quot;image/jpeg&quot;&#125; 如果provider不提供过滤字符串中请求的任何 MIME 类型，则 getStreamTypes() 应返回 null。 实现权限所有应用程序都可以读取或写入您的provider，即使底层数据是私有的，因为默认情况下您的provider没有设置权限。要更改此设置，请使用 &lt;provider&gt; 元素的属性或子元素在清单文件中为provider设置权限。 可以设置适用于整个provider、某些表、甚至某些记录或所有三者的权限。 可以在清单文件中使用一个或多个 &lt;permission&gt; 元素为provider定义权限。 要使权限对provider来说是唯一的，请对 android:name 属性使用 Java 样式的范围。例如，将读取权限命名为 com.example.app.provider.permission.READ_PROVIDER。 Single read-write provider-level permission 一种控制对整个provider的读写访问的权限，由 &lt;provider&gt; 元素的 android:permission 属性指定。 Separate read and write provider-level permission 整个provider的读取权限和写入权限。 可以使用 &lt;provider&gt; 元素的 android:readPermission 和 android:writePermission 属性来指定它们。 它们优先于 android:permission 所需的权限。 Path-level permission provider中content URI 的读取、写入或读取&#x2F;写入权限。 可以使用 &lt;provider&gt; 元素的 &lt;path-permission&gt; 子元素指定要控制的每个 URI。对于指定的每个content URI，可以指定读&#x2F;写权限、读权限或写权限，或同时指定这三个。 读写权限优先于读&#x2F;写权限。 此外，Path级别的权限优先于provider级别的权限。 Temporary permission 要打开临时权限，请设置 &lt;provider&gt; 元素的 android:grantUriPermissions 属性，或者将一个或多个 &lt;grant-uri-permission&gt; 子元素添加到 &lt;provider&gt; 元素。如果使用临时权限，则每当从provider中删除对content URI 的支持并且content URI 与临时权限相关联时，都必须调用 Context.revokeUriPermission()。 该属性的值决定了您的provider有多少可以访问。 如果该属性设置为 true，那么系统将向您的整个provider授予临时权限，覆盖您的provider级别或路径级别权限所需的任何其他权限。 如果此标志设置为 false，那么您必须将 &lt;grant-uri-permission&gt; 子元素添加到您的 &lt;provider&gt; 元素。 每个子元素指定授予临时访问权限的内容 URI 或 URI。 要委托对应用程序的临时访问，意图必须包含 FLAG_GRANT_READ_URI_PERMISSION 或 FLAG_GRANT_WRITE_URI_PERMISSION 标志，或两者兼有。 这些是使用 setFlags() 方法设置的。 如果 android:grantUriPermissions 属性不存在，则假定为 false。 &lt;provider&gt; 元素Authority (android:authorities) 标识系统内整个提供者的符号名称 Provider class name ( android:name ) 实现 ContentProvider 的类 Permissions 指定其他应用程序必须具有的权限才能访问provider数据的属性 android:grantUriPermissions: Temporary permission flag. android:permission: Single provider-wide read&#x2F;write permission. android:readPermission: Provider-wide read permission. android:writePermission: Provider-wide write permission. Startup and control attributes 这些属性决定了 Android 系统启动提供程序的方式和时间、提供程序的进程特征以及其他运行时设置： android:enabled: 允许系统启动provider的标志。 android:exported: 允许其他应用程序使用此provider的标志。 android:initOrder：这个provider应该启动的顺序，相对于同一进程中的其他provider。 android:multiProcess: 允许系统在与调用客户端相同的进程中启动provider的标志。 android:process：provider应该在其中运行的进程的名称。 android:syncable: 指示provider的数据将与服务器上的数据同步的标志。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android -  fragment","slug":"Android-Fragment","date":"2022-09-01T02:24:19.000Z","updated":"2023-07-18T04:22:50.378Z","comments":true,"path":"2022/09/01/Android-Fragment/","link":"","permalink":"https://azxkenzo.github.io/2022/09/01/Android-Fragment/","excerpt":"","text":"fragment 是什么 fragment 代表应用程序 UI 的可重用部分。 fragment 定义和管理自己的布局，有自己的生命周期，并且可以处理自己的输入事件。 fragment 不能独立存在——它们必须由一个 activity 或另一个 fragment 托管。 fragment 的view层次成为宿主view层次的一部分或附加到宿主的view层次。 创建 fragment可以通过在 activity 的布局文件中定义 fragment 或在activity的布局文件中定义 fragment 容器，然后以编程方式从activity中添加 fragment 来将 fragment 添加到activity的view层次结构中。无论哪种情况，都需要添加一个 fragment ContainerView 来定义 fragment 应放置在 Activity 的view层次结构中的位置。 强烈建议始终使用 fragment ContainerView 作为 fragment 的容器，因为 fragment ContainerView 包含其他ViewGroup（例如 FrameLayout）不提供的特定于 fragment 的修复。 fragment transaction仅在 savedInstanceState 为 null 时创建。 这是为了确保在首次创建activity时只添加一次 fragment 。当配置发生变化并重新创建activity时，savedInstanceState 不再为空，并且不需要第二次添加 fragment ，因为 fragment 会自动从 savedInstanceState 恢复。 fragment manager fragment Manager 是负责对应用程序的 fragment 执行操作的类，例如添加、删除或替换它们，并将它们添加到返回栈。 访问 fragment Manager在 activity 中访问。每个 fragment Activity 及其子类，例如 AppCompatActivity，都可以通过 getSupport fragment Manager() 方法访问 fragment Manager。 在 fragment 中访问。 fragment 也能够托管一个或多个子 fragment 。 在 fragment 内部，可以通过 getChild fragment Manager() 获得对管理 fragment 子项的 fragment Manager 的引用。 如果需要访问它的宿主 fragment Manager，可以使用getParent fragment Manager()。 使用 fragment Manager fragment Manager 管理 fragment 返回栈。在运行时， fragment Manager 可以执行返回栈操作，例如添加或删除 fragment 以响应用户交互。每组更改作为一个单独的单元一起提交，称为 fragment Transaction。 当用户按下返回按钮，或者当调用 fragment Manager.popBackStack() 时，最顶层的 fragment 事务会从堆栈中弹出。如果堆栈上没有更多的 fragment 事务，并且你没有使用子 fragment ，则返回事件会冒泡到activity。 在transaction上调用 addToBackStack() 时，请注意transaction可以包含任意数量的操作，例如添加多个 fragment 、替换多个容器中的 fragment 等。当返回栈被弹出时，所有这些操作都被反转为单个原子操作。如果在调用 popBackStack() 之前提交了其他transaction，并且没有对transaction使用 addToBackStack()，则这些操作不会被撤消。 执行 transaction12345supportfragmentManager.commit &#123; replace&lt;Examplefragment&gt;(R.id.fragment_container) setReorderingAllowed(true) addToBackStack(&quot;name&quot;) // name can be null&#125; 在此示例中，Example fragment 替换当前位于由 R.id. fragment _container ID 标识的布局容器中的 fragment （如果有）。将 fragment 的类提供给 replace() 方法允许 fragment Manager 使用其 fragment Factory 处理实例化。 setReorderingAllowed(true) 优化transaction中涉及的 fragment 的状态变化，以便动画和过渡正常工作。 调用 addToBackStack() 将transaction提交到返回栈。 可以通过按“返回”按钮来撤销transaction并带回前一个 fragment 。如果在单个transaction中添加或删除了多个 fragment ，则所有这些操作都会在返回栈弹出时撤消。addToBackStack() 调用中提供的可选名称使能够使用 popBackStack() 弹回该特定transaction。 如果在执行删除 fragment 的transaction时不调用 addToBackStack()，则在提交transaction时删除的 fragment 将被销毁，并且用户无法导航回它。如果在删除 fragment 时确实调用了 addToBackStack()，那么 fragment 只会停止，然后在用户导航返回时恢复。 请注意，在这种情况下，它的view被销毁了。 查找现有 fragment可以使用 find fragment ById() 获取对布局容器中当前 fragment 的引用。 使用 find fragment ById() 从 XML inflate时通过给定 ID 查找 fragment ，或者在添加到 fragment Transaction 时通过容器 ID 查找 fragment 。 或者，可以为 fragment 分配唯一tag并使用 find fragment ByTag() 获取引用。可以使用 android:tag XML 属性在布局中定义的 fragment 上分配标签，或者在 fragment Transaction 中的 add() 或 replace() 操作期间分配tag。 子 fragment 和兄弟 fragment 的特殊注意事项在任何给定时间，只允许一个 fragment Manager 控制 fragment 返回栈。如果应用同时在屏幕上显示多个同级 fragment ，或者应用使用子 fragment ，则必须指定一个 fragment Manager 来处理应用的主导航。 要在 fragment 事务中定义主导航 fragment ，请在transaction上调用 setPrimaryNavigation fragment () 方法，传入其 child fragment Manager 应具有主控制权的 fragment 实例。 将导航结构视为一系列层，activity为最外层，将每一层子 fragment 包裹在其下。每个层都必须有一个主导航 fragment 。当 Back 事件发生时，最内层控制导航行为。一旦最内层不再有要从中弹回的 fragment 事务，控制权就会返回到下一层，并重复此过程，直到到达activity。 请注意，当同时显示两个或多个 fragment 时，只能将其中一个作为主导航 fragment 。将 fragment 设置为主导航 fragment 会删除前一个 fragment 的指定。 支持多返回栈 fragment Manager 允许使用 saveBackStack() 和 restoreBackStack() 方法支持多个返回栈。 这些方法允许通过保存一个返回栈并恢复另一个堆栈来在返回栈之间进行交换。 saveBackStack() 的工作方式与使用可选名称参数调用 popBackStack() 类似：弹出指定的事务及其在堆栈上之后的所有事务。 不同之处在于 saveBackStack() 保存了弹出事务中所有 fragment 的状态。 使用相同的名称参数调用 restoreBackStack() 来恢复所有弹出的事务和所有已保存的 fragment 状态 注意：只能将 saveBackStack() 与调用 setReorderingAllowed(true) 的事务一起使用，以确保可以将事务恢复为单个原子操作。 注意：除非使用 addToBackStack() 为 fragment 事务传递可选名称，否则不能使用 saveBackStack() 和 restoreBackStack()。 为 fragment 提供依赖默认情况下， fragment Manager 使用framework提供的 fragment Factory 来实例化 fragment 的新实例。 此默认工厂使用反射来查找和调用 fragment 的无参数构造函数。这意味着不能使用此默认工厂来为 fragment 提供依赖项。 这也意味着默认情况下，在第一次创建 fragment 时使用的任何自定义构造函数都不会在重新创建期间使用。 要为 fragment 提供依赖项，或使用任何自定义构造函数，必须改为创建自定义 fragment Factory 子类，然后重写 fragment Factory.instantiate。 然后，可以使用自定义工厂覆盖 fragment Manager 的默认工厂，然后使用该工厂来实例化 fragment 。 假设有一个 Desserts fragment 负责展示家乡流行的甜点。 假设 Desserts fragment 依赖于 DessertsRepository 类，该类为它提供了向用户显示正确 UI 所需的信息。 fragment Factory 的简单实现可能类似于以下内容： 1234567class MyFragmentFactory(val repository: DessertsRepository) : FragmentFactory() &#123; override fun instantiate(classLoader: ClassLoader, className: String): Fragment = when (loadFragmentClass(classLoader, className)) &#123; DessertsFragment::class.java -&gt; DessertsFragment(repository) else -&gt; super.instantiate(classLoader, className) &#125;&#125; 然后，可以通过在 fragment Manager 上设置属性，将 My fragment Factory 指定为构造应用程序 fragment 时使用的工厂。必须在activity的 super.onCreate() 之前设置此属性，以确保在重新创建 fragment 时使用 My fragment Factory。 123456class MealActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; supportFragmentManager.fragmentFactory = MyFragmentFactory(DessertsRepository.getInstance()) super.onCreate(savedInstanceState) &#125;&#125; 请注意，在activity中设置 fragment Factory 会覆盖整个activity的 fragment 层次结构中的 fragment 创建。换句话说，添加的任何子 fragment 的 child fragment Manager 都使用此处设置的自定义 fragment 工厂，除非在较低级别覆盖。 fragment transaction通过调用 beginTransaction() 从 fragment Manager 获取 fragment Transaction 的实例 允许对 fragment 状态更改重新排序每个 fragment Transaction 都应该使用 setReorderingAllowed(true)。 需要允许 fragment Manager 正确执行 fragment Transaction，特别是当它在返回栈上运行并运行动画和转换时。启用该标志可确保如果多个事务一起执行，任何中间 fragment （即添加然后立即替换的 fragment ）不会经历生命周期更改或执行其动画或转换。请注意，此标志会影响事务的初始执行和使用 popBackStack() 撤消事务。 添加和移除 fragment要将 fragment 添加到 fragment Manager，请在事务上调用 add()。 此方法接收 fragment 容器的 ID，以及希望添加的 fragment 的类名。添加的 fragment 被移动到 RESUMED 状态。 强烈建议容器是作为view层次结构一部分的 fragment ContainerView。 要从host中删除 fragment ，请调用 remove()，传入通过 find fragment ById() 或 find fragment ByTag() 从 fragment Manager检索到的 fragment 实例。如果 fragment 的view先前已添加到容器中，则此时view将从容器中删除。 移除的 fragment 被移动到 DESTROYED 状态。 使用 replace() 将容器中的现有 fragment 替换为提供的新 fragment 类的实例。 调用 replace() 等效于在容器中调用 remove() 并将新 fragment 添加到同一个容器。 commit 是异步的调用 commit() 不会立即执行事务。 相反，事务被安排在主 UI 线程上运行。 但是，如有必要，可以调用 commitNow() 立即在 UI 线程上运行片段事务。 请注意，commitNow 与 addToBackStack 不兼容。 或者，可以通过调用 executePendingTransactions() 来执行所有由 commit() 调用提交但尚未运行的挂起的 fragment Transaction。 这种方法与 addToBackStack 兼容。 操作顺序很重要在 fragment Transaction 中执行操作的顺序很重要，尤其是在使用 setCustomAnimations() 时。 此方法将给定的动画应用于其后的所有 fragment 操作。 限制 fragment 的生命周期 fragment Transactions 可以影响在事务范围内添加的各个 fragment 的生命周期状态。创建 fragment Transaction 时，setMaxLifecycle() 设置给定 fragment 的最大状态。例如，ViewPager2 使用 setMaxLifecycle() 将屏幕外片段限制为 STARTED 状态。 显示和隐藏 fragment 的view使用 fragment Transaction 方法 show() 和 hide() 显示和隐藏已添加到容器的 fragment 的view。这些方法设置 fragment view的可见性，而不影响 fragment 的生命周期。 虽然不需要使用 fragment 事务来切换 fragment 中view的可见性，但这些方法对于希望更改可见性状态与后台堆栈上的事务相关联的情况很有用。 附加和分离 fragment fragment Transaction 方法 detach() 将 fragment 与 UI 分离，销毁其view层次结构。 fragment 保持在与放入返回栈时相同的状态 (STOPPED)。这意味着 fragment 已从 UI 中删除，但仍由 fragment Manager管理。 attach() 方法重新附加之前分离的 fragment 。 这会导致其view层次结构被重新创建、附加到 UI 并显示。 由于 fragment Transaction 被视为单个原子操作集，因此在同一事务中对同一 fragment 实例的分离和附加调用有效地相互抵消，从而避免了 fragment UI 的破坏和立即重建。使用单独的事务，如果使用 commit()，则由 executePendingOperations() 分隔，如果要分离然后立即重新附加 fragment 。 注意：attach() 和 detach() 方法与 onAttach() 和 onDetach() 的 fragment 方法无关。 fragment 生命周期为了管理生命周期， fragment 实现了 LifecycleOwner，公开了一个 Lifecycle 对象，可以通过 getLifecycle() 方法访问该对象。 每个可能的生命周期状态都在 Lifecycle.State 枚举中表示。 INITIALIZED CREATED STARTED RESUMED DESTROYED fragment 类包括对应于 fragment 生命周期中的每个更改的回调方法。 这些包括 onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy()。 fragment 的view有一个单独的生命周期，该生命周期独立于 fragment 的生命周期进行管理。 fragment 为其view维护一个 LifecycleOwner，可以使用 getViewLifecycleOwner() 或 getViewLifecycleOwnerLiveData() 访问。访问view的生命周期对于感知生命周期的组件只应在片段视图存在时执行工作的情况很有用，例如观察仅应显示在屏幕上的 LiveData。 fragment 和 fragment Manager当一个 fragment 被实例化时，它开始于 INITIALIZED 状态。要让 fragment 在其生命周期的其余部分过渡，必须将其添加到 fragment Manager。 fragment Manager 负责确定其 fragment 应该处于什么状态，然后将它们移动到该状态。 除了 fragment 生命周期之外， fragment Manager 还负责将 fragment 附加到它们的宿主activity，并在 fragment 不再使用时将它们分离。 fragment 类有两个回调方法，onAttach() 和 onDetach()，可以在其中任何一个事件发生时重写它们以执行工作。 当 fragment 被添加到 fragment Manager 并附加到其宿主activity时，将调用 onAttach() 回调。此时， fragment 处于活动状态， fragment Manager 正在管理其生命周期状态。此时，find fragment ById() 等 fragment Manager 方法返回这个 fragment 。 onAttach() 总是在任何生命周期状态更改之前调用。 当 fragment 已从 fragment Manager 中移除并与其宿主activity分离时，将调用 onDetach() 回调。该 fragment 不再处于活动状态，无法再使用 find fragment ById() 检索。 onDetach() 总是在任何生命周期状态更改后调用。 fragment 生命周期状态和回调在确定 fragment 的生命周期状态时， fragment Manager 会考虑以下内容： fragment 的最大状态由其 fragment Manager 确定。 fragment 不能超出其 fragment Manager 的状态。 作为 fragment Transaction 的一部分，可以使用 setMaxLifecycle() 在 fragment 上设置最大生命周期状态。 fragment 的生命周期状态永远不能大于其父级。 例如，父 fragment 或activity必须在其子 fragment 之前启动。 同样，子 fragment 必须在其父 fragment 或activity之前停止。 注意：避免使用 &lt; fragment &gt; 标记来使用 XML 添加片段，因为 &lt; fragment &gt; 标记允许片段超出其 fragment Manager 的状态。 相反，始终使用 fragment ContainerView 来使用 XML 添加片段。 ![alt 属性文本](https://developer.android.google.cn/static/images/guide/ fragment s&#x2F; fragment -view-lifecycle.png) 向上状态转换fragment CREATED当 fragment 达到 CREATED 状态时，它已被添加到 fragment Manager 并且已调用 onAttach() 方法。 这将是通过 fragment 的 SavedStateRegistry 恢复与 fragment 本身关联的任何已保存状态的适当位置。 请注意，此时 fragment 的view尚未创建，并且与 fragment 的view关联的任何状态都应仅在view创建后才能恢复。 此转换调用 onCreate() 回调。 回调还接收一个 savedInstanceState Bundle 参数，其中包含以前由 onSaveInstanceState() 保存的任何状态。 请注意，第一次创建 fragment 时，savedInstanceState 的值为 null，但对于后续重新创建它始终为非 null，即使没有覆盖 onSaveInstanceState()。 fragment CREATED 和 View INITIALIZED只有当 fragment 提供有效的 View 实例时，才会创建 fragment 的view生命周期。 在大多数情况下，可以使用带有@LayoutId 的 fragment 构造函数，它会在适当的时间自动填充view。 还可以覆盖 onCreateView() 以编程方式填充或创建 fragment 的view。 当且仅当 fragment 的view使用非空view实例化时，该view被设置在 fragment 上并且可以使用 getView() 检索。 getViewLifecycleOwnerLiveData() 然后使用与 fragment 的view对应的新初始化的 LifecycleOwner 进行更新。 此时也会调用 onViewCreated() 生命周期回调。 这是设置view初始状态、开始观察其回调更新 fragment 的view的 LiveData 实例以及在 fragment 中view的任何 RecyclerView 或 ViewPager2 实例上设置适配器的合适位置。 fragment 和 View CREATED在 fragment 的view被创建之后，之前的view状态（如果有的话）会被恢复，然后view的生命周期会被移动到 CREATED 状态。view生命周期所有者也会向其观察者发出 ON_CREATE 事件。 在这里，应该恢复与 fragment 的view关联的任何其他状态。 此转换还调用 onViewStateRestored() 回调。 fragment 和 View STARTED强烈建议将 Lifecycle-aware 组件绑定到 fragment 的 STARTED 状态，因为该状态保证 fragment 的View是可用的（如果已创建），并且在 fragment 的子 fragment Manager 上执行 fragment Transaction 是安全的 .如果 fragment 的view不为空，则 fragment 的view生命周期会在 fragment 的生命周期移至 STARTED 后立即移至 STARTED。 当 fragment 变为 STARTED 时，将调用 onStart() 回调。 fragment 和 View RESUMED当 fragment 可见时，所有 Animator 和 Transition 效果都已完成，并且该 fragment 已准备好进行用户交互。 fragment 的生命周期移动到 RESUMED 状态，并调用 onResume() 回调。 过渡到 RESUMED 是表明用户现在可以与 fragment 交互的适当信号。 未 RESUMED 的 fragment 不应手动将焦点设置在其view上或尝试处理输入法可见性。 向下状态转换fragment 和 View STARTED当用户开始离开 fragment 并且 fragment 仍然可见时， fragment 及其view的 Lifecycles 将移回 STARTED 状态并向其观察者发出 ON_PAUSE 事件。 然后 fragment 调用其 onPause() 回调。 fragment 和 View CREATED一旦 fragment 不再可见， fragment 及其view的生命周期将移动到 CREATED 状态并向其观察者发出 ON_STOP 事件。这种状态转换不仅由停止的父activity或 fragment 触发，而且由父activity或 fragment 保存状态触发。此行为保证在保存 fragment 状态之前调用 ON_STOP 事件。 这使得 ON_STOP 事件成为可以安全地对子 fragment Manager 执行 fragment Transaction 的最后一点。 fragment CREATED 和 View DESTROYED在所有的退出动画和转换完成后， fragment 的view已经从窗口中分离出来， fragment 的view生命周期进入 DESTROYED 状态并向其观察者发出 ON_DESTROY 事件。该 fragment 然后调用其 onDestroyView() 回调。 此时， fragment 的view已到达其生命周期的末尾，getViewLifecycleOwnerLiveData() 返回一个空值。 此时，所有对 fragment view的引用都应该被删除，从而允许对 fragment view进行垃圾回收。 fragment DESTROYED如果 fragment 被删除，或者 fragment Manager 被销毁，则 fragment 的 Lifecycle 将进入 DESTROYED 状态并将 ON_DESTROY 事件发送给它的观察者。然后 fragment 调用其 onDestroy() 回调。 此时， fragment 已达到其生命周期的终点。 使用动画在 fragment 之间导航 fragment API 提供了两种在导航过程中使用运动效果和变换在视觉上连接 fragment 的方法。其中之一是 Animation Framework，它同时使用 Animation 和 Animator。 另一个是Transition Framework，其中包括共享元素过渡。 设置 animation首先，需要为进入和退出效果创建animation，这些动画在导航到新 fragment 时运行。 可以将animation定义为补间动画资源。 这些资源允许定义 fragment 在动画期间应如何旋转、拉伸、淡化和移动。 这些动画可以在 res&#x2F;anim 目录中定义： 1234567&lt;!-- res/anim/fade_out.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;@android:integer/config_shortAnimTime&quot; android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; android:fromAlpha=&quot;1&quot; android:toAlpha=&quot;0&quot; /&gt; 1234567&lt;!-- res/anim/slide_in.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;@android:integer/config_shortAnimTime&quot; android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; android:fromXDelta=&quot;100%&quot; android:toXDelta=&quot;0%&quot; /&gt; 注意：强烈建议对涉及一种以上animation类型的效果使用transition，因为使用嵌套 AnimationSet 实例存在已知问题。 还可以为弹出返回堆栈时运行的进入和退出效果指定动画，这可能在用户点击向上或返回按钮时发生。 这些被称为 popEnter 和 popExit 动画。 定义动画后，通过调用 fragment Transaction.setCustomAnimations() 来使用它们，并通过资源 ID 传入动画资源，如下例所示: 1234567891011val fragment = FragmentB()supportFragmentManager.commit &#123; setCustomAnimations( enter = R.anim.slide_in, exit = R.anim.fade_out, popEnter = R.anim.fade_in, popExit = R.anim.slide_out ) replace(R.id.fragment_container, fragment) addToBackStack(null)&#125; 注意： fragment Transaction.setCustomAnimations() 将自定义动画应用于 fragment Transaction 中的所有未来 fragment 操作。 事务中的先前操作不受影响。 设置 transition还可以使用transition来定义进入和退出效果。 这些转换可以在 XML 资源文件中定义。 123&lt;!-- res/transition/fade.xml --&gt;&lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;@android:integer/config_shortAnimTime&quot;/&gt; 1234&lt;!-- res/transition/slide_right.xml --&gt;&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;@android:integer/config_shortAnimTime&quot; android:slideEdge=&quot;right&quot; /&gt; 一旦定义了transition，通过在进入 fragment 上调用 setEnterTransition() 和在退出 fragment 上调用 setExitTransition() 来应用它们，通过它们的资源 ID 传递inflated transition资源，如以下示例所示： 123456789101112131415class FragmentA : Fragment() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val inflater = TransitionInflater.from(requireContext()) exitTransition = inflater.inflateTransition(R.transition.fade) &#125;&#125;class FragmentB : Fragment() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val inflater = TransitionInflater.from(requireContext()) enterTransition = inflater.inflateTransition(R.transition.slide_right) &#125;&#125; fragment 支持 AndroidX transition。 虽然 fragment 也支持framework transition，但强烈建议使用 AndroidX transition，因为它们在 API 级别 14 及更高级别中受支持，并且包含旧版本的framework transition中不存在的错误修复。 使用共享元素 transition作为Transition Framework的一部分，共享元素transition确定了相应view在 fragment 过渡期间如何在两个 fragment 之间移动。 在高层次上，以下是如何使用共享元素进行 fragment transition： 为每个共享元素view 分配一个唯一的transition名称。 将共享元素view和transition名称添加到 fragment Transaction。 设置共享元素transition动画。 首先，必须为每个共享元素view分配一个唯一的transition名称，以允许view从一个 fragment 映射到下一个 fragment 。使用 ViewCompat.setTransitionName() 为每个 fragment 布局中的共享元素设置transition名称. 123456789101112131415class FragmentA : Fragment() &#123; override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; ... val itemImageView = view.findViewById&lt;ImageView&gt;(R.id.item_image) ViewCompat.setTransitionName(itemImageView, “item_image”) &#125;&#125;class FragmentB : Fragment() &#123; override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; ... val heroImageView = view.findViewById&lt;ImageView&gt;(R.id.hero_image) ViewCompat.setTransitionName(heroImageView, “hero_image”) &#125;&#125; 要将共享元素包含在 fragment transition中， fragment Transaction 必须知道每个共享元素的view如何从一个 fragment 映射到下一个 fragment 。通过调用 fragment Transaction.addSharedElement() 将每个共享元素添加到 fragment Transaction，并在下一个 fragment 中传入view和相应view的transition名称，如下例所示： 1234567val fragment = FragmentB()supportFragmentManager.commit &#123; setCustomAnimations(...) addSharedElement(itemImageView, “hero_image”) replace(R.id. fragment _container, fragment ) addToBackStack(null)&#125; 要指定共享元素如何从一个 fragment 过渡到下一个 fragment ，必须在被导航到的 fragment 上设置 enter transition。在 fragment 的 onCreate() 方法中调用 fragment .setSharedElementEnterTransition()，如下例所示： 1234567class FragmentB : Fragment() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) sharedElementEnterTransition = TransitionInflater.from(requireContext()) .inflateTransition(R.transition.shared_image) &#125;&#125; shared_image 转换定义如下： 1234&lt;!-- res/transition/shared_image.xml --&gt;&lt;transitionSet&gt; &lt;changeImageTransform /&gt;&lt;/transitionSet&gt; 默认情况下，共享元素的 enter transition 也用作共享元素的return transition。 Return transition确定当 fragment 事务从回栈弹出时共享元素如何转换回前一个 fragment 。如果想指定不同的return transition，可以在 fragment 的 onCreate() 方法中使用 fragment .setSharedElementReturnTransition() 来实现。 推迟 transition在某些情况下，可能需要将 fragment transition推迟一小段时间。 例如，可能需要等到进入 fragment 中的所有view都被测量和布局，以便 Android 可以准确地捕获它们的开始和结束状态以进行转换。 此外，你的转换可能需要推迟到加载了一些必要的数据。 例如，可能需要等到为共享元素加载图像。 否则，如果图像在过渡期间或之后完成加载，则过渡可能会不和谐。 要推迟转换，必须首先确保 fragment transaction允许对 fragment 状态更改进行重新排序。 要允许重新排序 fragment 状态更改，请调用 fragment Transaction.setReorderingAllowed()。 要推迟 enter transition，在进入 fragment 的 onViewCreated() 方法中调用 fragment .postponeEnterTransition()： 加载数据并准备好开始transition后，调用 fragment .startPostponedEnterTransition()。 以下示例使用 Glide 库将图像加载到共享的 ImageView 中，将相应的transition推迟到图像加载完成。 12345678910111213141516171819class FragmentB : Fragment() &#123; override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; ... Glide.with(this) .load(url) .listener(object : RequestListener&lt;Drawable&gt; &#123; override fun onLoadFailed(...): Boolean &#123; startPostponedEnterTransition() return false &#125; override fun onResourceReady(...): Boolean &#123; startPostponedEnterTransition() return false &#125; &#125;) .into(headerImage) &#125;&#125; 在处理用户互联网连接缓慢等情况时，可能需要在一定时间后开始延迟transition，而不是等待所有数据加载完毕。对于这些情况，可以改为在进入 fragment 的 onViewCreated() 方法中调用 fragment .postponeEnterTransition(long, TimeUnit)，并传入持续时间和时间单位。 一旦指定的时间过去，延迟就会自动开始。 将共享元素transition与 RecyclerView 一起使用使用 fragment 保存状态为了保证用户的状态被保存，Android框架会自动保存和恢复 fragment 和返回栈。 因此，需要确保 fragment 中的任何数据也被保存和恢复。 下表概述了导致 fragment 丢失状态的操作，以及各种类型的状态是否在这些更改中持续存在。 表中提到的状态类型如下： 变量： fragment 中的局部变量。 view状态： fragment 中一个或多个view所拥有的任何数据。 SavedState：此 fragment 实例固有的数据，应保存在 onSaveInstanceState() 中。 NonConfig：从外部源（例如服务器或本地存储库）提取的数据，或一旦提交就发送到服务器的用户创建的数据。 操作 变量 view状态 SavedState NonConfig 添加到返回栈 ✓ ✓ x ✓ 配置更改 x ✓ ✓ ✓ 进程死亡&#x2F;重新创建 x ✓ ✓ ✓ Removed not added to back stack x x x x Host finished x x x x View StateView负责管理自己的状态。所有 Android 框架提供的View都有自己的 onSaveInstanceState() 和 onRestoreInstanceState() 实现，因此不必在 fragment 中管理view state。 注意：为确保在配置更改期间正确处理，应该为创建的任何自定义View实现 onSaveInstanceState() 和 onRestoreInstanceState()。 View需要一个 ID 来保持其状态。 此 ID 在 fragment 及其View层次结构中必须是唯一的。 没有 ID 的View无法保留其状态。 SavedState fragment 负责管理 fragment 功能不可或缺的少量动态状态。 可以使用 fragment .onSaveInstanceState(Bundle) 保留易于序列化的数据。 与 Activity.onSaveInstanceState(Bundle) 类似，放置在 bundle 中的数据通过配置更改和进程死亡和重新创建来保留，并且在 fragment 的 onCreate(Bundle)、onCreateView(LayoutInflater、ViewGroup、Bundle) 和 onViewCreated(View, Bundle) 方法中可用。 注意：onSaveInstanceState(Bundle) 仅在 fragment 的宿主activity调用它自己的 onSaveInstanceState(Bundle) 时调用。 NonConfigNonConfig 数据应放置在 fragment 之外，例如在 ViewModel 中。 ViewModel 类固有地允许数据在配置更改（例如屏幕旋转）后保留下来，并在 fragment 被放置在返回栈时保留在内存中。在进程死亡和重新创建之后，ViewModel 被重新创建。 将 SavedState 模块添加到 ViewModel 允许 ViewModel 通过进程死亡和重新创建来保留简单状态。 与 fragment 通信为了正确响应用户事件或共享状态信息，通常需要在activity及其 fragment 之间或两个或多个 fragment 之间建立通信通道。为了保持 fragment 自包含，不应该让 fragment 直接与其他 fragment 或其宿主activity通信。 fragment 库提供了两个通信选项：共享 ViewModel 和 fragment Result API。推荐的选项取决于用例。要与任何自定义 API 共享持久数据，应该使用 ViewModel。对于可以放置在 Bundle 中的数据的一次性结果，应该使用 fragment Result API。 使用 ViewModel 共享数据当需要在多个 fragment 之间或 fragment 与其宿主activity之间共享数据时，ViewModel 是一个理想的选择。 ViewModel 对象存储和管理 UI 数据。 与宿主activity共享数据 fragment 及其宿主activity都可以通过将activity传递给 ViewModelProvider 构造函数来检索具有activity范围的 ViewModel 的共享实例。ViewModelProvider 处理实例化 ViewModel 或检索它（如果它已经存在）。 123456789101112class MainActivity : AppCompatActivity() &#123; // Using the viewModels() Kotlin property delegate from the activity-ktx // artifact to retrieve the ViewModel in the activity scope private val viewModel: ItemViewModel by viewModels()&#125;class ListFragment : Fragment() &#123; // Using the activityViewModels() Kotlin property delegate from the // fragment -ktx artifact to retrieve the ViewModel in the activity scope private val viewModel: ItemViewModel by activityViewModels()&#125; 注意：请务必使用 ViewModelProvider 的适当范围。 在上面的示例中，MainActivity 被用作 MainActivity 和 List fragment 的范围，因此它们都提供了相同的 ViewModel。 如果 List fragment 将其自身用作范围，则会提供与 MainActivity 不同的 ViewModel。 在 fragment 之间共享数据同一activity中的两个或多个 fragment 通常需要相互通信。 例如，假设一个 fragment 显示一个列表，另一个 fragment 允许用户对列表应用各种过滤器。如果没有 fragment 直接通信，这种情况可能并不容易实现，这意味着它们不再是独立的。 此外，两个 fragment 都必须处理另一个 fragment 尚未创建或不可见的情况。 这些 fragment 可以使用它们的activity范围共享一个 ViewModel 来处理这种通信。 通过这种方式共享 ViewModel， fragment 之间不需要相互了解，activity 也不需要做任何事情来方便通信。 在父 fragment 和子 fragment 之间共享数据要在这些 fragment 之间共享数据，请将父 fragment 用作 ViewModel 范围。 123456789101112class ListFragment : Fragment() &#123; // Using the viewModels() Kotlin property delegate from the fragment -ktx // artifact to retrieve the ViewModel private val viewModel: ListViewModel by viewModels()&#125;class ChildFragment : Fragment() &#123; // Using the viewModels() Kotlin property delegate from the fragment -ktx // artifact to retrieve the ViewModel using the parent fragment &#x27;s scope private val viewModel: ListViewModel by viewModels(&#123;requireParentFragment()&#125;) ...&#125; 使用 fragment Result API 获取结果在某些情况下，可能希望在两个 fragment 之间或 fragment 与其宿主activity之间传递一次性值。 例如，可能有一个读取 QR 码的 fragment ，将数据传递回之前的 fragment 。在 fragment 1.3.0 及更高版本中，每个 fragment Manager 都实现了 fragment ResultOwner。 这意味着 fragment Manager 可以充当 fragment 结果的中央存储。此更改允许组件通过设置 fragment 结果并侦听这些结果来相互通信，而无需这些组件相互直接引用。 在 fragment 之间传递结果要将数据从 fragment B 传递回 fragment A，首先在 fragment A（接收结果的 fragment ）上设置结果侦听器。在 fragment A 的 fragment Manager 上调用 set fragment ResultListener()，如下例所示： 123456789override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) // Use the Kotlin extension in the fragment -ktx artifact setFragmentResultListener(&quot;requestKey&quot;) &#123; requestKey, bundle -&gt; // We use a String here, but any type that can be put in a Bundle is supported val result = bundle.getString(&quot;bundleKey&quot;) // Do something with the result &#125;&#125; ![](https://developer.android.google.cn/static/images/guide/ fragment s&#x2F; fragment -a-to-b.png) 在产生结果的 fragment B 中，必须使用相同的 requestKey 在相同的 fragment Manager 上设置结果。 通过使用 set fragment Result() API 来做到这一点： 12345button.setOnClickListener &#123; val result = &quot;result&quot; // Use the Kotlin extension in the fragment -ktx artifact setFragmentResult(&quot;requestKey&quot;, bundleOf(&quot;bundleKey&quot; to result))&#125; 然后 fragment A 接收结果并在 fragment STARTED后执行侦听器回调。 对于给定的key ，只能有一个侦听器和结果。 如果对同一个key多次调用 set fragment Result()，并且如果侦听器未 STARTED，则系统会用更新的结果替换任何待处理的结果。如果设置了一个没有对应监听器接收的result，result会存储在 fragment Manager 中，直到你设置了具有相同 key 的监听器。 一旦侦听器收到result并触发 on fragment Result() 回调，result就会被清除。 这种行为有两个主要含义： 返回栈上的 fragment 在弹出并 STARTED 之前不会收到result。 如果在设置结果时侦听结果的 fragment 处于 STARTED，则立即触发侦听器的回调。 在父和子 fragment 之间传递数据要将结果从子 fragment 传递给父 fragment ，父 fragment 在调用 set fragment ResultListener() 时应使用 getChild fragment Manager() 而不是 getParent fragment Manager()。 在宿主activity中接收结果要在宿主activity中接收 fragment 结果，使用 getSupport fragment Manager() 在 fragment manager上设置结果侦听器。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - AIDL","slug":"Android-AIDL","date":"2022-08-31T13:01:48.000Z","updated":"2023-07-14T04:40:17.261Z","comments":true,"path":"2022/08/31/Android-AIDL/","link":"","permalink":"https://azxkenzo.github.io/2022/08/31/Android-AIDL/","excerpt":"","text":"AIDL 是什么Android Interface Definition Language (AIDL) 允许定义客户端和服务都同意的编程接口，以便使用进程间通信 (IPC) 相互通信。在 Android 上，一个进程不能正常访问另一个进程的内存。 所以说，他们需要将他们的对象分解为操作系统可以理解的原语，并将对象编组跨越该边界。 注意：仅当允许来自不同应用程序的客户端访问您的 IPC 服务并希望在您的服务中处理多线程时，才需要使用 AIDL。如果不需要跨不同应用程序执行并发 IPC，则应通过实现 Binder 创建接口，或者如果想执行 IPC 但不需要处理多线程，则使用 Messenger 实现接口。 在开始设计 AIDL 接口之前，请注意对 AIDL 接口的调用是直接函数调用。 不应该对发生调用的线程做出假设。 根据调用是来自本地进程中的线程还是远程进程，发生的情况会有所不同。 具体来说： 从本地进程进行的调用在进行调用的同一线程中执行。 如果这是主 UI 线程，则该线程将继续在 AIDL 接口中执行。如果它是另一个线程，那就是在服务中执行代码的线程。 因此，如果只有本地线程正在访问服务，可以完全控制在其中执行哪些线程（但如果是这种情况，那么根本不应该使用 AIDL，而应该通过实现 Binder 创建接口 ）。 来自远程进程的调用是从平台在您自己的进程内部维护的线程池中分派的。 您必须为来自未知线程的传入呼叫做好准备，同时发生多个呼叫。换句话说，AIDL 接口的实现必须是完全线程安全的。 从同一远程对象上的一个线程发出的调用按顺序到达接收端。 oneway 关键字修改远程调用的行为。 使用时，远程调用不会阻塞； 它只是发送交易数据并立即返回。 接口的实现最终从Binder线程池接收这个作为常规调用作为常规远程调用。如果 oneway 与本地调用一起使用，则没有影响，调用仍然是同步的。 定义 AIDL 接口必须使用 Java 语法在 .aidl 文件中定义 AIDL 接口，然后将其保存在托管服务的应用程序和绑定到服务的任何其他应用程序的源代码中（在 src&#x2F; 目录中）。 在构建每个包含 .aidl 文件的应用程序时，Android SDK 工具会根据 .aidl 文件生成一个 IBinder 接口，并将其保存在项目的 gen&#x2F; 目录中。 服务必须适当地实现 IBinder 接口。 然后客户端应用程序可以绑定到服务并从 IBinder 调用方法来执行 IPC。 要使用 AIDL 创建 bounded 服务，请执行以下步骤： 创建 .aidl 文件。 该文件定义了带有方法签名的编程接口。 实现接口。Android SDK 工具会根据您的 .aidl 文件以 Java 编程语言生成接口。 此接口有一个名为 Stub 的内部抽象类，它扩展 Binder 并实现 AIDL 接口中的方法。 您必须扩展 Stub 类并实现方法。 向客户端公开接口。实现一个 Service 并覆盖 onBind() 以返回 Stub 类的实现。 创建 .aidl 文件AIDL 使用一种简单的语法，允许使用一个或多个可以接受参数和返回值的方法来声明接口。 参数和返回值可以是任何类型，甚至是其他 AIDL 生成的接口。 必须使用 Java 语言构建 .aidl 文件。 每个 .aidl 文件必须定义一个接口，并且只需要接口声明和方法签名。 默认情况下，AIDL 支持以下数据类型： Java 中的所有基本类型（如 int、long、char、boolean 等） 原始类型数组，例如 int[] String CharSequence List List 中的所有元素必须是此列表中受支持的数据类型之一，或者是您声明的其他 AIDL 生成的接口或 parcelables 之一。 List 可以选择用作参数化类型类（例如，List）。 对方接收到的实际具体类始终是一个 ArrayList，尽管生成该方法是为了使用 List 接口。 Map Map 中的所有元素必须是此列表中支持的数据类型之一，或者是您声明的其他 AIDL 生成的接口或 parcelables 之一。 不支持参数化类型映射（例如 Map&lt;String,Integer&gt; 形式的映射）。 对方接收到的实际具体类始终是HashMap，虽然生成方法是为了使用Map接口。 考虑使用 Bundle 作为 Map 的替代品。 必须为上面未列出的每个附加类型包含一个 import 语句，即使它们与您的接口在同一个包中定义。 定义服务接口时，请注意： 方法可以接受零个或多个参数，并返回一个值或 void。 所有非原始参数都需要一个方向标签来指示数据的走向。 in、out或inout。警告：应该将方向限制为真正需要的方向，因为编组参数很昂贵。 .aidl 文件中包含的所有代码注释都包含在生成的 IBinder 接口中（除了 import 和 package 语句之前的注释）。 可以在 AIDL 接口中定义 String 和 int 常量。 例如：const int VERSION &#x3D; 1;。 方法调用由 transact() 代码分派，该代码通常基于接口中的方法索引。 因为这使得版本控制变得困难，您可以手动将事务代码分配给一个方法：void method() &#x3D; 10;。 可以为 Null 的参数和返回类型必须使用 @nullable 进行注释。 只需将 .aidl 文件保存在项目的 src&#x2F; 目录中，当构建应用程序时，SDK 工具会在项目的 gen&#x2F; 目录中生成 IBinder 接口文件。 生成的文件名与 .aidl 文件名匹配，但具有 .java 扩展名（例如，IRemoteService.aidl 生成 IRemoteService.java）。 实现接口当您构建应用程序时，Android SDK 工具会生成一个以您的 .aidl 文件命名的 .java 接口文件。 生成的接口包括一个名为 Stub 的子类，它是其父接口的抽象实现，并声明了 .aidl 文件中的所有方法。 注意：Stub 还定义了一些辅助方法，最值得注意的是 asInterface()，它接受一个 IBinder（通常是传递给客户端的 onServiceConnected() 回调方法的那个）并返回一个 stub 接口的实例。 在实现 AIDL 接口时，您应该注意一些规则： 传入调用不能保证在主线程上执行，因此您需要从一开始就考虑多线程并正确构建您的服务以实现线程安全。 默认情况下，RPC 调用是同步的。 如果您知道该服务需要多于几毫秒来完成一个请求，您不应该从 Activity 的主线程调用它，因为它可能会挂起应用程序（Android 可能会显示“应用程序未响应”对话框）——您应该 通常从客户端中的单独线程调用它们。 只有 Parcel.writeException() 的参考文档中列出的异常类型会被发送回调用者。 客户端还必须能够访问接口类，因此如果客户端和服务位于不同的应用程序中，那么客户端的应用程序必须在其 src&#x2F; 目录中拥有 .aidl 文件的副本（生成 android.os.Binder 接口） — 提供客户端访问 AIDL 方法）。 当客户端在 onServiceConnected() 回调中收到 IBinder 时，必须调用 YourServiceInterface.Stub.asInterface(service) 将返回的参数转换为 YourServiceInterface 类型。 通过 IPC 传递对象在 Android 10（API 级别 29）中，可以直接在 AIDL 中定义 Parcelable 对象。 这里也支持作为 AIDL 接口参数和其他 parcelables 支持的类型。 这避免了手动编写编组代码和自定义类的额外工作。 但是，这也会创建一个裸结构。 如果需要自定义访问器或其他功能，则应实现 Parcelable。 您还可以通过 IPC 接口将自定义类从一个进程发送到另一个进程。 但是，您必须确保您的类的代码可用于 IPC 通道的另一端，并且您的类必须支持 Parcelable 接口。 支持 Parcelable 接口很重要，因为它允许 Android 系统将对象分解为可以跨进程编组的基元。 Stub类的声明： 1public static abstract class Stub extends Binder implements IRemoteService Stub.asInterface() 的实现： 12345678910111213141516171819public static IRemoteService asInterface(IBinder obj) &#123; if (obj==null) &#123; return null; &#125; IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if ((iin!=null) &amp;&amp; (iin instanceof IRemoteService)) &#123; return ((IRemoteService)iin); &#125; // return new IRemoteService.Stub.Proxy(obj);&#125;public @Nullable IInterface queryLocalInterface(@NonNull String descriptor) &#123; if (mDescriptor != null &amp;&amp; mDescriptor.equals(descriptor)) &#123; return mOwner; &#125; return null;&#125; Stub.Proxy 中方法的实现： 123456789101112131415161718192021android.os.Parcel _data = android.os.Parcel.obtain();android.os.Parcel _reply = android.os.Parcel.obtain();try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(anInt); _data.writeLong(aLong); _data.writeInt(((aBoolean)?(1):(0))); _data.writeFloat(aFloat); _data.writeDouble(aDouble); _data.writeString(aString); // boolean _status = mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0); if (!_status &amp;&amp; getDefaultImpl() != null) &#123; getDefaultImpl().basicTypes(anInt, aLong, aBoolean, aFloat, aDouble, aString); return; &#125; _reply.readException();&#125; finally &#123; _reply.recycle(); _data.recycle();&#125; Binder.transact() 的实现： 12345678910111213public final boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException &#123; if (false) Log.v(&quot;Binder&quot;, &quot;Transact: &quot; + code + &quot; to &quot; + this); if (data != null) &#123; data.setDataPosition(0); &#125; boolean r = onTransact(code, data, reply, flags); if (reply != null) &#123; reply.setDataPosition(0); &#125; return r;&#125; Stub.onTransact() 的实现： 123456789101112131415161718192021222324252627282930313233String descriptor = DESCRIPTOR;switch (code)&#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(descriptor); return true; &#125; case TRANSACTION_basicTypes: &#123; data.enforceInterface(descriptor); int _arg0; _arg0 = data.readInt(); long _arg1; _arg1 = data.readLong(); boolean _arg2; _arg2 = (0!=data.readInt()); float _arg3; _arg3 = data.readFloat(); double _arg4; _arg4 = data.readDouble(); String _arg5; _arg5 = data.readString(); // this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); reply.writeNoException(); return true; &#125; default: &#123; return super.onTransact(code, data, reply, flags); &#125;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - Service","slug":"Android-Service","date":"2022-08-31T07:57:09.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/08/31/Android-Service/","link":"","permalink":"https://azxkenzo.github.io/2022/08/31/Android-Service/","excerpt":"","text":"Service 是什么Service 是一个App组件，可以在后台执行长时间运行的操作。它不提供用户界面。一旦启动，Service 可能会继续运行一段时间，即使在用户切换到另一个App之后也是如此。此外，组件可以绑定到 Service 以与其交互，甚至执行进程间通信 (IPC)。 例如，Service 可以在后台处理网络事务、播放音乐、执行文件 I&#x2F;O 或与ContentProvider交互。 Service 的类型Service 有3种不同类型： Foreground 前台服务执行一些用户可以注意到的操作。 前台服务必须显示通知。 即使用户没有与应用程序交互，前台服务也会继续运行。当使用前台服务时，您必须显示通知，以便用户主动知道该服务正在运行。 除非服务停止或从前台删除，否则无法关闭此通知。 注意：WorkManager API 提供了一种灵活的任务调度方式，并且能够在需要时将这些Job作为前台服务运行。 在许多情况下，使用 WorkManager 比直接使用前台服务更可取。 Background 后台服务执行用户不直接注意到的操作。 例如，如果App使用服务来压缩其存储空间，那通常是后台服务。 Bound 当App组件通过调用 bindService() 绑定到服务时，服务被绑定。 绑定服务提供客户端-服务器接口，允许组件与服务交互、发送请求、接收结果，甚至通过进程间通信 (IPC) 跨进程执行此操作。绑定服务仅在另一个App组件绑定到它时运行。 多个组件可以一次绑定到服务，但是当所有组件都解除绑定时，服务将被销毁。 基础应该重写的最重要的回调方法： onStartCommand() 当另一个组件请求启动服务时，系统通过调用 startService() 来调用此方法。 当这个方法执行时，服务就会启动并且可以无限期地在后台运行。 如果实现了这个，有责任在服务完成时通过调用 stopSelf() 或 stopService() 来停止服务。 onBind() 当另一个组件想要与服务绑定时，系统通过调用 bindService() 来调用此方法。 在此方法的实现中，必须通过返回一个 IBinder 来提供客户端用来与服务通信的接口。 必须始终实现此方法； 但是，如果不想允许绑定，则应返回 null。 onCreate() 系统在最初创建服务时（在调用 onStartCommand() 或 onBind() 之前）调用此方法来执行一次性设置过程。 如果服务已在运行，则不调用此方法。 onDestroy() 当服务不再使用并且正在被销毁时，系统会调用此方法。 应该实现它以清理任何资源，例如线程、注册的侦听器或接收器。 这是服务收到的最后一个调用。 如果组件通过调用 startService() 启动服务（这会导致调用 onStartCommand()），则服务会继续运行，直到它通过 stopSelf() 自行停止或另一个组件通过调用 stopService() 停止它。 如果组件调用 bindService() 来创建服务并且未调用 onStartCommand()，则服务仅在组件绑定到它时运行。 在服务与其所有客户端解除绑定后，系统将其销毁。 Android 系统仅在内存不足，并且必须为具有用户焦点的activity恢复系统资源时才停止服务。 如果服务绑定到具有用户焦点的activity，则它被杀死的可能性较小；如果服务被声明在前台运行，它很少被杀死。 如果服务已启动并长时间运行，系统会随着时间的推移降低其在后台任务列表中的位置，并且该服务变得非常容易被杀死。如果系统终止了服务，它会在资源可用时立即重新启动它，但这也取决于从 onStartCommand() 返回的值。 创建 started servicestarted service是另一个组件通过调用 startService() 启动的服务，这会导致调用服务的 onStartCommand() 方法。 当服务启动时，它的生命周期独立于启动它的组件。该服务可以无限期地在后台运行，即使启动它的组件已被销毁。因此，服务应该在其作业完成时通过调用 stopSelf() 自行停止，或者另一个组件可以通过调用 stopService() 来停止它。 注意：服务在与声明它的应用程序相同的进程中运行，并且默认情况下在该应用程序的主线程中运行。 注意 onStartCommand() 方法必须返回一个整数。 该整数描述了在系统终止服务的情况下系统应如何继续服务。 onStartCommand() 的返回值必须是以下常量之一： START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止服务，不会重新创建服务，除非有待交付的intent。 START_STICKY 如果系统在 onStartCommand() 返回后终止服务，则重新创建服务并调用 onStartCommand()，但不会重新传递最后一个intent。 相反，系统会以空intent调用 onStartCommand() ，除非有待启动的intent来启动服务。在这种情况下，这些intent就会被传递。 这适用于不执行命令但无限期运行并等待作业的媒体播放器（或类似服务）。 START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止服务，请重新创建服务并使用传递给服务的最后一个intent调用 onStartCommand()。依次传递任何未决intent。 这适用于正在积极执行应立即恢复的作业的服务，例如下载文件。 注意：如果应用需要创建前台服务，应用应该调用 startForegroundService()。 该方法创建了一个后台服务，但该方法向系统发出信号，该服务将把自己提升到前台。 创建服务后，服务必须在五秒内调用其 startForeground() 方法。 已启动的服务必须管理自己的生命周期。也就是说，系统不会停止或销毁服务，除非它必须恢复系统内存并且服务在 onStartCommand() 返回后继续运行。该服务必须通过调用 stopSelf() 来停止它自己，或者另一个组件可以通过调用 stopService() 来停止它。 一旦使用 stopSelf() 或 stopService() 请求停止，系统会尽快销毁服务。 如果服务同时处理对 onStartCommand() 的多个请求，则在处理完启动请求后不应停止服务，因为您可能收到了新的启动请求（在第一个请求结束时停止会终止第二个）。为避免此问题，可以使用 stopSelf(int) 来确保您停止服务的请求始终基于最近的启动请求。也就是说，当调用 stopSelf(int) 时，传递的是停止请求对应的启动请求的 ID（传递给 onStartCommand() 的 startId）。然后，如果服务在能够调用 stopSelf(int) 之前收到新的启动请求，则 ID 不匹配并且服务不会停止。 创建 bound service要创建绑定服务，请实现 onBind() 回调方法以返回定义与服务通信的接口的 IBinder。然后其他应用程序组件可以调用 bindService() 来检索接口并开始调用服务上的方法。服务只为绑定到它的应用程序组件服务，所以当没有组件绑定到服务时，系统会销毁它。 要创建绑定服务，必须定义指定客户端如何与服务通信的接口。服务和客户端之间的接口必须是 IBinder 的实现，并且是服务必须从 onBind() 回调方法返回的内容。客户端收到 IBinder 后，就可以通过该接口开始与服务交互。 多个客户端可以同时绑定到服务。当客户端完成与服务的交互时，它调用 unbindService() 来解除绑定。当没有客户端绑定到该服务时，系统会销毁该服务。 前台服务使用前台服务的应用必须请求 FOREGROUND_SERVICE 权限。 要从前台删除服务，请调用 stopForeground()。 此方法采用布尔值，指示是否也删除状态栏通知。 请注意，该服务将继续运行。 bound service可以同时将多个客户端连接到一个服务。 但是，系统缓存了IBinder服务通信通道。 换句话说，只有在第一个客户端绑定时，系统才会调用服务的 onBind() 方法来生成 IBinder。 然后系统将相同的 IBinder 传递给绑定到相同服务的所有其他客户端，而无需再次调用 onBind()。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Android - Activity","slug":"Android-Activity","date":"2022-08-28T07:43:51.000Z","updated":"2023-07-18T03:58:41.829Z","comments":true,"path":"2022/08/28/Android-Activity/","link":"","permalink":"https://azxkenzo.github.io/2022/08/28/Android-Activity/","excerpt":"","text":"Activity 是什么Activity 是与用户交互的入口点。它代表具有用户界面的单个屏幕。 Activity 的生命周期当用户浏览、离开和返回 App 时，App 中的 Activity 实例会在其生命周期中通过不同的状态进行转换。Activity 类提供了许多回调，允许 Activity 知道状态已更改。 Activity 类提供了一组核心的6个回调： onCreate() onStart() onResume() onPause() onStop() onDestroy() 生命周期回调onCreate()该回调在系统首次创建 Activity 时触发。在该方法中，应该执行基本的 App 启动逻辑，该逻辑在 Activity 的整个生命周期内只发生一次。该方法接收参数 savedInstanceState，它是一个包含 Activity 先前保存状态的 Bundle 对象。如果 Activity 以前从未存在过，则 Bundle 对象的值为 null。 onStart()onStart() 调用使 Activity对用户可见。 onResume()当 activity 进入 Resumed 状态时，它来到前台，然后系统调用 onResume() 回调。这是App与用户交互的状态，App会一直保持这种状态。 onPause()系统调用此方法作为用户离开 Activity 的第一个指示；它表示 Activity 不再在前台。使用 onPause() 方法暂停或调整在 Activity 处于暂停状态时不应继续并且希望很快恢复的操作。 Activity 进入该状态的原因有多种： 某些事件会中断App执行，如 onResume() 部分所述。 多个App以多窗口模式运行。由于任何时候只有一个App（窗口）具有焦点，因此系统会暂停其他所有App。 一个新的、半透明的 Activity（如 dialog）打开。只要 Activity 仍然部分可见但不在焦点上，它就会保持暂停状态。 onStop()当 activity 不再对用户可见，它会进入 Stopped 状态，然后系统调用 onStop() 回调。在该方法中，app应该释放或调整在app对用户不可见时不需要的资源。 还应该使用 onStop() 来执行相对CPU密集型的关闭操作。例如，可以在 onStop() 期间将数据保存到数据库。 当 Activity 进入 Stopped 状态时，Activity 对象一直驻留在内存中：它维护所有状态和成员信息，但不附加到窗口管理器。 一旦 activity 停止，如果系统需要恢复内存，系统可能会销毁包含 activity 的进程。 即使系统在 Activity 停止时销毁进程，系统仍将 View 对象的状态（例如 EditText 小部件中的文本）保留在 Bundle（键值对的 blob）中，如果用户 导航回活动。 从 Stopped 状态，activity 要么返回与用户交互，要么 activity 完成运行并离开。 如果 activity 返回，系统调用 onRestart()。 如果 Activity 运行完毕，系统会调用 onDestroy()。 onDestroy()onDestroy() 在 activity 被销毁之前被调用。系统调用此回调是因为： activity 正在结束（由于用户完全关闭 activity 或由于在 activity 上调用了 finish()），或者 由于配置更改（例如设备旋转或多窗口模式），系统正在临时销毁 activity onDestroy() 回调应该释放所有尚未被早期回调（例如 onStop()）释放的资源。 Activity 状态和从内存中弹出系统在需要释放RAM时终止进程；系统杀死给定进程的可能性取决于当时进程的状态。反过来，进程状态取决于进程中运行的 Activity 的状态。 下表显示了进程状态、activity状态和系统杀死进程的可能性之间的相关性。 被杀掉的可能性 进程状态 最终 Activity 状态 最小 前台（已经或即将获得焦点） Resumed 更小 可见 (没有焦点) Started &#x2F; paused 更多 后台 (不可见) Stopped 最大 空的 Destroyed 系统从不直接杀死 activity 以释放内存。 相反，它会杀死 activity 运行的进程，不仅会销毁 activity，还会销毁进程中运行的所有其他内容。 保存和恢复瞬时UI状态当发生配置更改时，系统会默认销毁 activity，从而清除 activity 实例中存储的任何 UI 状态。当 Activity 由于系统限制而被销毁时，应该使用 ViewModel、onSaveInstanceState() 和&#x2F;或本地存储的组合来保留用户的瞬态 UI 状态。 实例状态如果系统由于系统约束（例如配置更改或内存压力）而销毁了 Activity，那么尽管实际的 Activity 实例已经消失，但系统会记住它存在。 如果用户试图导航回 activity，系统会使用一组保存的数据创建该 activity 的新实例，这些数据描述 activity 被销毁时的状态。 系统用来恢复之前状态的保存数据称为 instance state，是存储在 Bundle 对象中的键值对的集合。 默认情况下，系统使用 Bundle 实例状态来保存有关 activity 布局中每个 View 对象的信息（例如输入到 EditText 小部件中的文本值）。 因此，如果 activity 实例被销毁并重新创建，则布局的状态将恢复到之前的状态，而不需要任何代码。 但是，activity 可能有更多想要恢复的状态信息，例如跟踪用户在 activity 中的进度的成员变量。 注意：为了让系统恢复 Activity 中 view 的状态，每个view必须有一个唯一的 ID，由 android:id 属性提供。 Bundle 对象不适合保存大量数据，因为它需要在主线程上进行序列化并消耗系统进程内存。 使用 onSaveInstanceState() 保存简单的、轻量级的UI状态当 activity 开始停止时，系统会调用 onSaveInstanceState() 方法，以便 activity 可以将状态信息保存到 instance state bundle。 此方法的默认实现保存有关 activity view 层次结构状态的临时信息，例如 EditText 小部件中的文本或 ListView 小部件的滚动位置。 要为 Activity 保存其他实例状态信息，必须重写 onSaveInstanceState() 并将键值对添加到 Bundle 对象中。 使用保存的 instance state 恢复 activity UI 状态当 Activity 在之前被销毁后重新创建时，可以从系统传递给 Activity 的 Bundle 中恢复保存的实例状态。 onCreate() 和 onRestoreInstanceState() 回调方法都接收包含实例状态信息的同一个 Bundle 可以选择实现 onRestoreInstanceState()，而不是在 onCreate() 期间恢复状态，系统在 onStart() 方法之后调用它。 系统只有在有保存状态需要恢复时才会调用onRestoreInstanceState()，所以不需要检查Bundle是否为null。注意：始终调用 onRestoreInstanceState() 的超类实现，以便默认实现可以恢复view层次结构的状态。 协调 activity当两个 activity 在同一个进程（app）中并且一个正在启动另一个时。 以下是 Activity A 启动 Activity B 时发生的操作顺序： Activity A 的 onPause() 方法执行 Activity B 的 onCreate()、onStart() 和 onResume() 方法依次执行。 （activity B 现在具有用户焦点。） 然后，如果 Activity A 在屏幕上不再可见，则执行其 onStop() 方法。 处理 Activity 状态更改发生配置更改触发配置更改的事件有：设备旋转、更改语言或输入设备等等。配置更改发生时，activity 会被销毁并重新创建 处理多窗口当App进入多窗口模式时，系统会通知当前运行的 activity 有配置更改。如果调整了已经处于多窗口模式的app的大小，也会发生此行为。 在多窗口模式下，虽然有两个app对用户可见，但只有用户正在与之交互的app处于前台并具有焦点。该 activity 处于 Resumed 状态，另一个窗口中的 activity 处于 Paused 状态。 Activity 或 dialog 出现在前台如果前台出现新的 activity 或 dialog，获得焦点并部分覆盖正在进行的 activity，则被覆盖的 activity 失去焦点并进入 Paused 状态。 如果前台出现新的 activity 或 dialog，获得焦点并完全覆盖正在进行的 activity，则被覆盖的 activity 失去焦点并进入 Stopped 状态 当被覆盖 activity 的同一个实例回到前台时，系统会在 activity 上调用 onRestart()、onStart() 和 onResume()。 如果是被覆盖activity的新实例来到后台，系统不会调用onRestart()，只调用onStart()和onResume()。 用户按下或手势返回如果一个 activity 在前台，并且用户按下或手势返回，activity 将通过 onPause()、onStop() 和 onDestroy() 回调进行转换。 除了被销毁之外，该 activity 还从后台堆栈中移除。 系统杀掉App进程如果app在后台并且系统需要为前台app释放额外的内存，则系统可以杀死后台app以释放更多内存。 Task 和 back stackTask 是用户在app中尝试执行某些操作时与之交互的 activity 的集合。 这些activity按每个activity的打开顺序排列在一个堆栈（back stack）中。 Task 和其 返回栈 的生命周期设备主屏幕是大多数Task的起始位置。 当用户在应用启动器（或主屏幕）中触摸应用或快捷方式的图标时，该应用的Task就会出现在前台。如果app不存在任何Task（该应用程序最近未使用过），则会创建一个新Task，并且该app的主 Activity 作为堆栈中的根 Activity 打开。 当当前activity开始另一个activity时，新activity被推到堆栈顶部并获得焦点。前一个activity保留在堆栈中，但已停止。当activity停止时，系统会保留其用户界面的当前状态。 当用户执行返回操作时，当前activity从栈顶弹出（activity被销毁）并恢复前一个activity（其 UI 的先前状态被恢复）。堆栈中的 Activity 永远不会重新排列，只会从堆栈中压入和弹出——由当前 Activity 启动时压入堆栈，并在用户使用后退按钮或手势离开时弹出。 因此，返回栈作为后进先出对象结构运行。 如果用户继续按下或手势返回，则堆栈中的每个activity都会弹出以显示前一个activity，直到用户返回主屏幕（或返回到Task开始时正在运行的任何activity）。 当所有activity都从堆栈中删除时，该Task不再存在。 根启动器activity的返回行为根启动器activity是使用 ACTION_MAIN 和 CATEGORY_LAUNCHER 声明 Intent 过滤器的activity。 这些activity充当从应用启动器进入应用的入口点，并用于启动Task。 当用户从根启动器activity按下或手势返回时，系统会根据设备运行的 Android 版本以不同方式处理事件。在Android 11及更低版本上，系统会finish activity；在Android 12及更高版本上，系统将activity及其Task移至后台，而不是finish activity。 如果重写 onBackPressed() 以处理返回导航并finish activity，请调用 super.onBackPressed() 而不是finish。 调用 super.onBackPressed() 在适当的时候将activity及其Task移至后台，并为跨app的用户提供更一致的导航体验。 后台和前台Task多Activity实例多窗口环境当app在多窗口环境中同时运行时，系统为每个窗口单独管理Task； 每个窗口可能有多个Task。 管理Task可以使用 &lt;activity&gt; 清单元素中的属性和传递给 startActivity() 的intent中的flag来执行这些以及更多操作。 可以使用的主要 &lt;activity&gt; 属性： taskAffinity launchMode allowTaskReparenting clearTaskOnLaunch alwaysRetainTaskState finishOnTaskLaunch 可以使用的主要intent flag： FLAG_ACTIVITY_NEW_TASK FLAG_ACTIVITY_CLEAR_TOP FLAG_ACTIVITY_SINGLE_TOP 定义启动模式启动模式允许定义activity的新实例如何与当前Task相关联。可以用清单文件和intent flag两个方式定义不同的启动模式。 如果两个activity都定义了activity B 应如何与Task关联，则activity A 的请求（如intent中所定义）优先于activity B 的请求（如其清单中所定义）。 使用&lt;activity&gt;元素的launchMode属性指定activity应如何与Task关联。 standard 默认模式。系统在启动它的Task中创建一个新的activity实例，并将intent路由到它。 Activity可以被实例化多次，每个实例可以属于不同的Task，一个Task可以有多个实例。 singleTop如果 activity 的实例已经存在于当前Task的顶部，则系统通过调用其 onNewIntent() 方法将intent路由到该实例，而不是创建activity的新实例。 singleTask系统在新Task的根部创建activity，或将activity定位在具有相同affinity的现有Task上。如果 Activity 的实例已经存在并且位于Task的根目录，则系统通过调用其 onNewIntent() 方法将intent路由到现有实例，而不是创建新实例。 同时，它上面的所有其他activity都被销毁了。 singleInstance与singleTask相同，只是系统不会在持有该实例的Task中启动任何其他activity。 activity始终是其Task中唯一且唯一的成员； 由这个启动的任何activity都在单独的Task中打开。 singleInstancePerTaskActivity 只能作为Task的根 Activity 运行，即创建Task的第一个 Activity，因此任务中只会有该 Activity 的一个实例。与 singleTask 启动模式相比，如果设置了 FLAG_ACTIVITY_MULTIPLE_TASK 或 FLAG_ACTIVITY_NEW_DOCUMENT 标志，则可以在不同Task的多个实例中启动此activity。 onNewIntent() 在 onStart() 之后、onResume() 之前调用 使用intent flag定义启动模式： FLAG_ACTIVITY_NEW_TASK在新Task中启动activity。 如果正在启动的 Activity 的Task已经在运行，则该Task将被带到前台并恢复其最后状态，并且该 Activity 在 onNewIntent() 中接收新intent。这会产生与singleTask的launchMode值相同的行为。 FLAG_ACTIVITY_SINGLE_TOP如果正在启动的activity是当前activity，则现有实例会收到对 onNewIntent() 的调用，而不是创建activity的新实例。 FLAG_ACTIVITY_CLEAR_TOP如果正在启动的 Activity 已经在当前Task中运行，那么不会启动该 Activity 的新实例，而是将其之上的所有其他 Activity 销毁，并将此 Intent 传递给该 Activity 的恢复实例，通过 onNewIntent())。FLAG_ACTIVITY_CLEAR_TOP 最常与 FLAG_ACTIVITY_NEW_TASK 结合使用。 当一起使用时，这些标志是一种在另一个Task中定位现有Activity并将其放置在可以响应intent的位置的方法。 注意：如果指定Activity的启动模式是standard，它也会从堆栈中删除，并在其位置启动一个新实例以处理传入的intent。这是因为当启动模式为standard时，总是会为新intent创建一个新实例。 处理 affinityaffinity 指示 activity 更喜欢属于哪个Task。使用 &lt;activity&gt; 元素的 taskAffinity 属性修改任何给定activity的affinity. taskAffinity 属性采用字符串值，该值必须与 &lt;manifest&gt; 元素中声明的默认包名称不同，因为系统使用该名称来标识app的默认 task affinity。 affinity 在两种情况下发挥作用： 当启动 activity 的intent包含 FLAG_ACTIVITY_NEW_TASK 标志时。默认情况下，新activity会启动到调用 startActivity() 的activity的Task中。它被推入与调用者相同的返回栈。但是，如果intent包含 FLAG_ACTIVITY_NEW_TASK 标志，系统会寻找不同的Task来容纳新activity。通常，这是一项新Task。但是，它不一定是。如果已经存在与新activity具有相同affinity的现有task，则该activity将启动到该task中。如果没有，它会开始一个新Task。 当 Activity 的 allowTaskReparenting 属性设置为“true”时。在这种情况下，当该Task来到前台时，活动可以从它启动的task移动到它具有affinity的task。 清除返回栈如果用户长时间离开一个task，系统会清除该task除根Activity之外的所有Activity。 当用户再次返回task时，仅恢复根activity。 可以使用一些 activity 属性来修改此行为： alwaysRetainTaskState如果在Task的根 activity 中将此属性设置为“true”，则不会发生上述的默认行为。 即使经过很长时间，该task也会将所有activity保留在其堆栈中。 clearTaskOnLaunch如果在task的根activity中将此属性设置为“true”，则每当用户离开task并返回到它时，该task就会被清除到根activity。换句话说，它与 alwaysRetainTaskState 正好相反。 用户总是以初始状态返回task，即使离开task仅片刻。注意：如果未设置 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，则忽略此属性。 finishOnTaskLaunch此属性类似于 clearTaskOnLaunch，但它作用于单个activity，而不是整个task。 它还可以导致任何activity finish，除了根activity。当它设置为“true”时，activity仅在当前会话中保留为task的一部分。 如果用户离开然后返回到task，它就不再存在。注意：如果未设置 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，则忽略此属性。 进程和应用的生命周期进程生命周期错误的一个常见示例是 BroadcastReceiver，它在其 BroadcastReceiver.onReceive() 方法中接收到 Intent 时启动线程，然后从函数返回。一旦它返回，系统就认为 BroadcastReceiver 不再处于活动状态，因此不再需要它的托管进程（除非其他应用程序组件在其中处于活动状态）。因此，系统可能随时终止进程以回收内存，并在这样做时终止进程中运行的衍生线程。 这个问题的解决方案通常是从 BroadcastReceiver 调度一个 JobService，这样系统就知道在这个过程中仍然有活动的工作正在完成。 为了确定在内存不足时应该杀死哪些进程，Android 会根据其中运行的组件和这些组件的状态将每个进程放入“重要性层次结构”中。 这些进程类型是（按重要性排序）： 前台进程是用户当前正在执行的操作所必需的进程。 各种应用程序组件可能会导致其包含的进程以不同的方式被视为前台。 如果满足以下任何条件，则认为进程处于前台： 它正在与用户交互的屏幕顶部运行一个 Activity（它的 onResume() 方法已被调用）。 它有一个当前正在运行的 BroadcastReceiver（它的 BroadcastReceiver.onReceive() 方法正在执行）。 它有一个 service，当前正在其回调之一（Service.onCreate()、Service.onStart() 或 Service.onDestroy()）中执行代码。 系统中只会有几个这样的进程，如果内存太低以至于这些进程都无法继续运行，这些进程只会作为最后的手段被杀死。 通常，此时设备已达到内存分页状态，因此需要此操作以保持用户界面响应。 可见进程正在做用户当前知道的工作，因此杀死它会对用户体验产生明显的负面影响。 在以下情况下，进程被视为可见： 它正在运行一个用户在屏幕上可见但在前台不可见的 Activity（它的 onPause() 方法已被调用）。 例如，如果前台 Activity 显示为允许在其后面看到前一个 Activity 的对话框，则可能会发生这种情况。 它有一个作为前台服务运行的 Service，通过 Service.startForeground() （它要求系统将服务视为用户知道的东西，或者对他们基本上可见）。 它托管系统用于用户知道的特定功能的服务，例如动态壁纸、输入法服务等。 系统中运行的这些进程的数量没有前台进程那么有限，但仍然相对受控。 这些进程被认为非常重要并且不会被杀死，除非需要这样做以保持所有前台进程运行。 服务进程是一个持有已使用 startService() 方法启动的 Service 的进程。 虽然这些进程对用户来说是不直接可见的，但它们一般都在做用户关心的事情（比如后台网络数据上传或下载），所以系统会一直保持这些进程运行，除非没有足够的内存来保留所有前台和可见进程。 已经运行了很长时间（例如 30 分钟或更长时间）的服务的重要性可能会被降级，以允许它们的进程下降到下面描述的缓存列表中。 这有助于避免长时间运行的服务使用过多资源（例如，通过泄漏内存）阻止系统提供良好的用户体验的情况。 缓存进程是当前不需要的进程，因此当其他地方需要内存等资源时，系统可以根据需要自由地终止它。 在正常运行的系统中，这些是唯一涉及资源管理的进程：运行良好的系统将有多个缓存进程始终可用（以便更有效地在应用程序之间切换）并根据需要定期杀死最旧的进程。 只有在非常危急（且不受欢迎）的情况下，系统才会到达所有缓存进程都被杀死并且必须开始杀死服务进程的地步。 这些进程通常持有一个或多个当前对用户不可见的 Activity 实例（已调用并返回 onStop() 方法）。 如果他们正确实现了 Activity 生命周期，当系统终止此类进程时，它不会影响用户返回该应用程序时的体验：它可以在新的进程重新创建关联的 Activity 时恢复先前保存的状态 。 这些进程保存在一个列表中。 在此列表中排序的确切策略是平台的实现细节，但通常它会尝试在其他类型的进程之前保留更多有用的进程（一个托管用户的主应用程序，他们看到的最后一个活动等）。 也可以应用其他杀死进程的策略：对允许的进程数量的硬限制，对进程可以持续缓存的时间量的限制等。 进程的优先级也可以基于进程对其的其他依赖关系而增加。 例如，如果进程 A 已绑定到带有 Context.BIND_AUTO_CREATE 标志的服务，或者正在进程 B 中使用 ContentProvider，那么进程 B 的分类将始终至少与进程 A 的分类一样重要。 Parcelable 和 BundleParcelable 和 Bundle 对象旨在用于跨进程边界（例如 IPC&#x2F;Binder 事务）、具有intent的activity之间以及跨配置更改存储瞬态状态。 注意：Parcel 不是一种通用的序列化机制，不应该将任何 Parcel 数据存储在磁盘上或通过网络发送。 在 activity 之间发送数据OS将intent的底层 Bundle 打包(parcel)。 然后，OS创建新的activity，解包(un-parcel)数据，并将intent传递给新的活动。 建议使用 Bundle 类在 Intent 对象上设置OS已知的原语。 Bundle 类针对使用parcel的编组和解组进行了高度优化。 在某些情况下，可能需要一种机制来跨activity发送复合或复杂对象。 在这种情况下，自定义类应该实现 Parcelable，并提供适当的 writeToParcel(android.os.Parcel, int) 方法。 它还必须提供一个名为 CREATOR 的非空字段，该字段实现 Parcelable.Creator 接口，其 createFromParcel() 方法用于将 Parcel 转换回当前对象。 通过 Intent 发送数据时，应小心将数据大小限制为几KB。 发送过多数据会导致系统抛出 TransactionTooLargeException 异常。 在进程间发送数据在进程之间发送数据类似于在activity之间发送数据。 但是，在进程之间发送时，建议不要使用自定义 Parcelables。 如果将自定义 Parcelable 对象从一个应用程序发送到另一个应用程序，需要确保发送和接收应用程序上都存在完全相同版本的自定义类。 通常，这可能是跨两个应用程序使用的通用库。 如果您的应用程序尝试将自定义 Parcelable 发送到系统，则可能会发生错误，因为系统无法解组它不知道的类。 Binder 事务缓冲区有一个有限的固定大小，目前为 1MB，由进程正在进行的所有事务共享。 由于此限制是在进程级别而不是在每个活动级别，因此这些事务包括应用程序中的所有绑定事务，例如 onSaveInstanceState、startActivity 以及与系统的任何交互。 当超出大小限制时，会引发 TransactionTooLargeException。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Kotlin - Coroutine","slug":"Kotlin-Coroutine","date":"2022-05-28T02:00:21.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/05/28/Kotlin-Coroutine/","link":"","permalink":"https://azxkenzo.github.io/2022/05/28/Kotlin-Coroutine/","excerpt":"","text":"原文 前言Kotlin 只在标准库中提供了最低级别的API以使各种其他库能够利用协程。在 kotlin 中，async 和 await 不是关键字，而且甚至不是标准库的一部分。此外，与 futures and promises 相比，Kotlin 的挂起函数概念为异步操作提供了更安全且不易出错的抽象。 kotlinx.coroutines 是由 JetBrains 开发的丰富的协程库。 它包含本指南涵盖的许多支持协程的高级原语，包括launch、async等。 协程基础协程是可挂起计算的一个实例。 它在概念上类似于线程，因为它需要一个与其余代码同时工作的代码块来运行。但是，协程并不绑定到任何特定的线程。 它可以在一个线程中暂停执行并在另一个线程中恢复。 1234567fun main() = runBlocking &#123; // this: CoroutineScope launch &#123; // launch a new coroutine and continue delay(1000L) // non-blocking delay for 1 second (default time unit is ms) println(&quot;World!&quot;) // print after delay &#125; println(&quot;Hello&quot;) // main coroutine continues while a previous one is delayed&#125; launch 是一个协程构建器。 它与其余代码同时启动一个新的协程，该协程继续独立工作。 这就是首先打印 Hello 的原因。 delay 是一个特殊的挂起函数。 它将协程暂停特定时间。 挂起协程不会阻塞底层线程，但允许其他协程运行并使用底层线程来执行它们的代码。 runBlocking 也是一个协程构建器，它将常的 fun main() 的非协程世界与 runBlocking &#123; ... &#125; 花括号内的协程代码联系起来。 这在 IDE 中通过以下方式突出显示：在 runBlocking 左大括号之后的 this: CoroutineScope 提示。 runBlocking 的名称意味着运行它的线程在调用期间被阻塞，直到 runBlocking &#123; ... &#125; 中的所有协程完成执行。 你会经常看到在应用程序的最顶层使用 runBlocking，而在实际代码中很少见，因为线程是昂贵的资源，阻塞它们效率低下，通常是不希望的。 结构化并发协程遵循结构化并发原则，这意味着新的协程只能在限定协程生命周期的特定 CoroutineScope 中启动。 上面的例子表明 runBlocking 建立了相应的范围，这就是为什么前面的例子等到 World! 在延迟一秒后打印，然后才退出。 在实际应用程序中，您将启动大量协程。 结构化并发确保它们不会丢失并且不会泄漏。 在其所有子协程完成之前，外部作用域无法完成。 结构化并发还确保正确报告代码中的任何错误并且永远不会丢失。 挂起函数可以像常规函数一样在协程中使用，但它们的附加特性是它们可以反过来使用其他挂起函数（如本例中的delay）来挂起协程的执行。 Scope 构建器除了不同构建器提供的协程作用域外，还可以使用 coroutineScope 构建器声明自己的作用域。 它创建了一个协程范围，并且在所有启动的子进程完成之前不会完成。 runBlocking 和 coroutineScope 构建器可能看起来很相似，因为它们都在等待自己的 body 及其所有子节点完成。 主要区别在于 runBlocking 方法阻塞当前线程等待，而 coroutineScope 只是挂起，释放底层线程用于其他用途。 由于这个区别，runBlocking 是一个常规函数，而 coroutineScope 是一个挂起函数。 Scope 构建器 和 并发可以在任何挂起函数中使用 coroutineScope 构建器来执行多个并发操作 显式 joblaunch协程构建器返回一个 Job 对象，该对象是已启动协程的句柄，可用于显式等待其完成。 取消和超时取消协程执行在长时间运行的应用程序中，可能需要对后台协程进行细粒度控制。 例如，用户可能已经关闭了启动协程的页面，现在不再需要其结果并且可以取消其操作。 launch 函数返回一个 Job 可以用来取消正在运行的协程： 取消是合作的协程取消是合作的。 协程代码必须合作才能取消。 kotlinx.coroutines 中的所有挂起函数都是可以取消的。 他们检查协程的取消并在取消时抛出 CancellationException。 但是，如果协程在计算中工作并且不检查取消，则无法取消。 使计算代码可取消有两种方法可以使计算代码可取消。 第一个是定期调用检查取消的挂起函数。 有一个 yield 函数，它是一个很好的选择。另一种是显式检查取消状态。isActive 是通过 CoroutineScope 对象在协程内部可用的扩展属性。 使用 finally 关闭资源可取消的挂起函数在取消时会抛出 CancellationException，这可以按通常的方式处理。 例如，try &#123;...&#125; finally &#123;...&#125; 表达式和 Kotlin use 函数在协程被取消时正常执行它们的终结操作 运行不可取消的代码块任何在上一个示例的 finally 块中使用挂起函数的尝试都会导致 CancellationException，因为运行此代码的协程被取消。通常，这不是问题，因为所有行为良好的关闭操作（关闭文件、取消job或关闭任何类型的通信通道）通常都是非阻塞的，并且不涉及任何挂起功能。但是，在极少数情况下，当需要在取消的协程中挂起时，可以使用 withContext 函数和 NonCancellable 上下文将相应的代码包装在 withContext(NonCancellable) &#123;...&#125; 中。 超时取消协程执行的最明显的实际原因是因为它的执行时间已经超过了一些超时。 虽然可以手动跟踪对相应 Job 的引用并启动一个单独的协程以在延迟后取消跟踪的协程，但有一个准备使用的 withTimeout 函数可以做到这一点。 withTimeout 抛出的 TimeoutCancellationException 是 CancellationException 的子类。 我们之前没有在控制台上看到它的堆栈跟踪。 那是因为在取消的协程内部 CancellationException 被认为是协程完成的正常原因。 然而，在这个例子中，我们在 main 函数中使用了 withTimeout。 由于取消只是一个异常，所有资源都以通常的方式关闭。 如果需要专门针对任何类型的超时执行一些附加操作，可以可以将超时代码包装在 try &#123;...&#125; catch (e: TimeoutCancellationException) &#123;...&#125; 块中，或使用 withTimeoutOrNull 函数，它类似于 withTimeout ，但在超时时返回 null 而不是抛出异常 异步超时和资源withTimeout 中的超时事件相对于在其块中运行的代码是异步的，并且可能随时发生，甚至在从超时块内部返回之前。 如果您在块内打开或获取一些需要在块外关闭或释放的资源，请记住这一点。 组合挂起函数默认是顺序的协程中的代码，就像在常规代码中一样，默认是顺序的 使用 async 来并发从概念上讲，async 就像 launch。 它启动一个单独的协程，它是一个轻量级线程，可与所有其他协程同时工作。 不同之处在于，launch 返回一个 Job 并且不携带任何结果值，而 async 返回一个 Deferred - 一个轻量级的非阻塞future，表示稍后提供结果的承诺。 可以在deferred值上使用 .await() 来获得其最终结果，但 Deferred 也是一个 job，因此可以在需要时取消它。 懒启动的 async可选地，可以通过将其 start 参数设置为 CoroutineStart.LAZY 来使 async 变得惰性。 在这种模式下，它仅在 await 需要其结果或调用其 Job 的 start 函数时才启动协程。 异步风格的函数","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://azxkenzo.github.io/tags/Kotlin/"},{"name":"Coroutine","slug":"Coroutine","permalink":"https://azxkenzo.github.io/tags/Coroutine/"}]},{"title":"Android - Handler 和 Looper","slug":"Android-Handler-和-Looper","date":"2022-05-28T00:22:24.000Z","updated":"2023-07-18T04:22:50.326Z","comments":true,"path":"2022/05/28/Android-Handler-和-Looper/","link":"","permalink":"https://azxkenzo.github.io/2022/05/28/Android-Handler-%E5%92%8C-Looper/","excerpt":"","text":"LooperLooper 是用于为线程运行消息循环的类。 默认情况下，线程没有与之关联的消息循环； 要创建一个，需要在要运行循环的线程中调用prepare，然后循环让它处理消息，直到循环停止。大多数与消息循环的交互都是通过 Handler 类进行的。这是一个Looper线程实现的典型例子，使用prepare和loop的分离来创建一个初始的Handler来与Looper进行通信。 123456789101112131415class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler(Looper.myLooper()) &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; 构造方法1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; prepare()1234567891011121314151617181920212223private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();// ThreadLocal.javapublic T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 在 prepare 中，会先通过 ThreadLocal 查询当前线程是否已经创建了相关联的 Looper，如果没有，就创建一个 Looper 并存到 ThreadLocal 中。否则，抛出 RuntimeException 所以，一个线程中 prepare 只能调用一次 myLooper()123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; loop()123456789101112131415161718192021222324252627282930313233public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; if (me.mInLoop) &#123; Slog.w(TAG, &quot;Loop again would have the queued messages be executed&quot; + &quot; before this one completed.&quot;); &#125; me.mInLoop = true; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27; final int thresholdOverride = SystemProperties.getInt(&quot;log.looper.&quot; + Process.myUid() + &quot;.&quot; + Thread.currentThread().getName() + &quot;.slow&quot;, 0); me.mSlowDeliveryDetected = false; for (;;) &#123; if (!loopOnce(me, ident, thresholdOverride)) &#123; return; &#125; &#125;&#125; 先检查线程的 Looper 是否已创建，然后循环调用 loopOnce 来处理消息，待到 loopOnce 返回 false 时，停止循环 loopOnce12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394private static boolean loopOnce(final Looper me, final long ident, final int thresholdOverride) &#123; Message msg = me.mQueue.next(); // 这里会一直阻塞线程，直到收到消息。否则，直接返回 null 就会结束循环 if (msg == null) &#123; // No message indicates that the message queue is quitting. return false; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; // Make sure the observer won&#x27;t change while processing a transaction. final Observer observer = sObserver; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) &#123; slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; &#125; final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) &#123; token = observer.messageDispatchStarting(); &#125; long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try &#123; msg.target.dispatchMessage(msg); // 把 msg 交由 发送方 Handler 处理 if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logSlowDelivery) &#123; if (me.mSlowDeliveryDetected) &#123; if ((dispatchStart - msg.when) &lt;= 10) &#123; Slog.w(TAG, &quot;Drained&quot;); me.mSlowDeliveryDetected = false; &#125; &#125; else &#123; if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;, msg)) &#123; // Once we write a slow delivery log, suppress until the queue drains. me.mSlowDeliveryDetected = true; &#125; &#125; &#125; if (logSlowDispatch) &#123; showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg); &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&#x27;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); return true;&#125; getMainLooper()1234567891011121314151617public static Looper getMainLooper() &#123; synchronized (Looper.class) &#123; return sMainLooper; &#125;&#125;// The main looper for your application is created by the Android environment, so you should never need to call this function yourself.@Deprecatedpublic static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125;&#125; MessageQueuenext()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; A Message is added to the queue for example in response to input events, as frame rendering callback or even your own Handler.post calls. Sometimes the main thread has no work to do (that is, no messages in the queue), which may happen e.g. just after finishing rendering single frame (the thread has just drawn one frame and is ready for the next one, just waits for a proper time). Two Java methods in the MessageQueue class are interesting to us: Message next() and boolean enqueueMessage(Message, long). Message next(), as its name suggest, takes and returns the next Message from the queue.If the queue is empty (and there’s nothing to return), the method calls native void nativePollOnce(long, int) which blocks until a new message is added.At this point you might ask how does nativePollOnce know when to wake up. That’s a very good question. When a Message is added to the queue, the framework calls the enqueueMessage method, which not only inserts the message into the queue, but also calls native static void nativeWake(long), if there’s need to wake up the queue. The core magic of nativePollOnce and nativeWake happens in the native (actually, C++) code. Native MessageQueue utilizes a Linux system call named epoll, which allows to monitor a file descriptor for IO events. nativePollOnce calls epoll_wait on a certain file descriptor, whereas nativeWake writes to the descriptor, which is one of the IO operations, epoll_wait waits for.The kernel then takes out the epoll-waiting thread from the waiting state and the thread proceeds with handling the new message. If you’re familiar with Java’s Object.wait() and Object.notify() methods, you can imagine that nativePollOnce is a rough equivalent for Object.wait() and nativeWake for Object.notify(), except they’re implemented completely differently: nativePollOnce uses epoll and Object.wait() uses futex Linux call. It’s worth noticing that neither nativePollOnce nor Object.wait() waste CPU cycles, as when a thread enters either method, it becomes disabled for thread scheduling purposes (quoting the javadoc for the Object class).However, some profilers may mistakenly recognize epoll-waiting (or even Object-waiting) threads as running and consuming CPU time, which is incorrect.If those methods actually wasted CPU cycles, all idle apps would use 100% of the CPU, heating and slowing down the device. enqueueMessage()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; synchronized (this) &#123; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&#x27;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); // 唤醒队列获取消息 &#125; &#125; return true;&#125; Handler构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Deprecatedpublic Handler() &#123; this(null, false);&#125;@Deprecatedpublic Handler(@Nullable Callback callback) &#123; this(callback, false);&#125;@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)public Handler(boolean async) &#123; this(null, async);&#125;public Handler(@Nullable Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&#x27;t create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125;public Handler(@NonNull Looper looper) &#123; this(looper, null, false);&#125;public Handler(@NonNull Looper looper, @Nullable Callback callback) &#123; this(looper, callback, false);&#125;@UnsupportedAppUsagepublic Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 发送消息调用 sendXX() 发送消息 1234567891011121314151617181920212223242526272829303132public final boolean sendMessage(@NonNull Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; // 用 Message.target 记录发送方Handler msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 处理消息Looper 从 MessageQueue 中拿到 Message 后，调用 Handler.dispatchMessage() 123456789101112public void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; HandlerThreadHandlerThread 是持有 Looper 的 Thread 1234567891011121314151617public class HandlerThread extends Thread &#123; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; &#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"}]},{"title":"Kotlin - 泛型","slug":"Kotlin-泛型","date":"2022-05-27T23:09:42.000Z","updated":"2023-07-18T04:22:50.342Z","comments":true,"path":"2022/05/28/Kotlin-泛型/","link":"","permalink":"https://azxkenzo.github.io/2022/05/28/Kotlin-%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"原文 Kotlin 中的类可以有类型参数，就像在 Java 中一样： 123class Box&lt;T&gt;(t: T) &#123; var value = t&#125; 要创建此类的实例，只需提供类型参数： 1val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1) 但是如果参数可以推断出来，例如，从构造函数参数，可以省略类型参数： 1val box = Box(1) // 1 has type Int, so the compiler figures out that it is Box&lt;Int&gt; 差异Java 类型系统最棘手的方面之一是通配符类型。 Kotlin 没有这些。相反，Kotlin 具有声明站点差异和类型预测。 思考一下为什么 Java 需要这些神秘的通配符。首先，Java 中的泛型类型是不变的，这意味着 List&lt;String&gt; 不是 List&lt;Object&gt; 的子类型。如果 List 不是不变的，它不会比 Java 的数组好，因为下面的代码会编译但在运行时会导致异常： 1234List&lt;String&gt; strs = new ArrayList&lt;String&gt;();List&lt;Object&gt; objs = strs; // !!! A compile-time error here saves us from a runtime exception later.objs.add(1); // Put an Integer into a list of StringsString s = strs.get(0); // !!! ClassCastException: Cannot cast Integer to String Java 禁止此类事情以保证运行时安全。但这有影响。例如，考虑 Collection 接口中的 addAll() 方法。这个方法的签名是什么？直观地说，会这样写： 123interface Collection&lt;E&gt; ... &#123; void addAll(Collection&lt;E&gt; items);&#125; 但是，将无法执行以下操作（这是非常安全的）： 12345void copyAll(Collection&lt;Object&gt; to, Collection&lt;String&gt; from) &#123; to.addAll(from); // !!! Would not compile with the naive declaration of addAll: // Collection&lt;String&gt; is not a subtype of Collection&lt;Object&gt;&#125; 这就是为什么 addAll() 的实际签名如下： 123interface Collection&lt;E&gt; ... &#123; void addAll(Collection&lt;? extends E&gt; items);&#125; 通配符类型参数 ? extends E 表示此方法接受 E 的对象集合或 E 的子类型的对象集合，而不仅仅是 E 本身。这意味着您可以安全地从 items 中读取 E（此集合的元素是 E 的子类的实例），但不能写入它，因为不知道哪些对象符合 E 的未知子类型。作为此限制的回报，会得到所需的行为： Collection&lt;String&gt; 是 Collection&lt;? extends Object&gt; 的子类型。换句话说，带有扩展绑定（上限）的通配符使类型 协变。 理解其工作原理的关键相当简单：如果只能从集合中获取 item，那么使用字符串集合并从中读取 object 就可以了。相反，如果只能将 item 放入集合中，则可以将 object 的集合放入其中：在 Java 中有 List&lt;? super String&gt;，是 List&lt;Object&gt; 的超类型。 后者称为 逆变，只能在 List&lt;? super String&gt; 上调用将 String 作为参数的方法。（例如，可以调用 add(String) 或 set(int, String)）。如果你在 List 中调用返回 T 的东西，你不会得到一个字符串，而是一个 object。 声明站点差异假设有一个通用接口 Source&lt;T&gt; 没有任何将 T 作为参数的方法，只有返回 T 的方法： 123interface Source&lt;T&gt; &#123; T nextT();&#125; 然后，将 Source&lt;String&gt; 实例的引用存储在 Source&lt;Object&gt; 类型的变量中是完全安全的 - 无需调用消费者方法。但是 Java 不知道这一点，并且仍然禁止它： 1234void demo(Source&lt;String&gt; strs) &#123; Source&lt;Object&gt; objects = strs; // !!! Not allowed in Java // ...&#125; 要解决此问题，应该声明 Source&lt;? extends Object&gt;。这样做是没有意义的，因为可以像以前一样在这样的变量上调用所有相同的方法，因此更复杂的类型不会增加任何值。但是编译器不知道这一点。 在 Kotlin 中，有一种方法可以向编译器解释这类事情。这称为 声明站点差异：可以对 Source 的类型参数 T 进行注释，以确保它仅从 Source&lt;T&gt; 的成员返回（产生），而不会被消费。为此，请使用 out 修饰符： 12345678interface Source&lt;out T&gt; &#123; fun nextT(): T&#125;fun demo(strs: Source&lt;String&gt;) &#123; val objects: Source&lt;Any&gt; = strs // This is OK, since T is an out-parameter // ...&#125; 一般规则是：当类 C 的类型参数 T 被声明为 out 时，它可能只出现在 C 的成员中的 out 位置，但作为回报，C&lt;Base&gt; 可以安全地成为 C&lt;Derived&gt; 的超类型。 换句话说，可以说类 C 在参数 T 中是 协变 的，或者说 T 是协变类型参数。可以将 C 视为 T 的生产者，而不是 T 的消费者。 out 修饰符称为差异注释，由于它是在类型参数声明站点提供的，因此它提供了声明站点差异。这与 Java 的使用站点差异形成对比，其中类型使用中的通配符使类型协变。 除了 out，Kotlin 还提供了一个互补的差异注解：in。它使类型参数 逆变，这意味着它只能被消费而不能被生产。逆变类型的一个很好的例子是 Comparable： 123456789interface Comparable&lt;in T&gt; &#123; operator fun compareTo(other: T): Int&#125;fun demo(x: Comparable&lt;Number&gt;) &#123; x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number // Thus, you can assign x to a variable of type Comparable&lt;Double&gt; val y: Comparable&lt;Double&gt; = x // OK!&#125; in 和 out 这两个词似乎是不言自明的（因为它们已经在 C# 中成功使用了一段时间），所以上面提到的助记符并不是真正需要的。事实上，它可以在更高的抽象层次上重新表述： 类型预测使用站点差异：类型预测很容易将类型参数 T 声明为 out 并避免在使用站点上进行子类型化的麻烦，但实际上某些类不能被限制为只返回 T！ Array 就是一个很好的例子： 1234class Array&lt;T&gt;(val size: Int) &#123; operator fun get(index: Int): T &#123; ... &#125; operator fun set(index: Int, value: T) &#123; ... &#125;&#125; 这个类在 T 中既不能是协变的，也不能是逆变的。这会带来一定的不灵活性。考虑以下函数： 12345fun copy(from: Array&lt;Any&gt;, to: Array&lt;Any&gt;) &#123; assert(from.size == to.size) for (i in from.indices) to[i] = from[i]&#125; 此函数应该将item从一个数组复制到另一个数组。让我们尝试在实践中应用它： 1234val ints: Array&lt;Int&gt; = arrayOf(1, 2, 3)val any = Array&lt;Any&gt;(3) &#123; &quot;&quot; &#125;copy(ints, any)// ^ type is Array&lt;Int&gt; but Array&lt;Any&gt; was expected 在这里会遇到同样熟悉的问题：Array&lt;T&gt; 在 T 中是不变的，因此 Array&lt;Int&gt; 和 Array&lt;Any&gt; 都不是另一个的子类型。为什么不？同样，这是因为 copy 可能有意外的行为，例如，它可能会尝试将 String 写入 from，如果实际上在那里传递了一个 Int 数组，稍后将抛出 ClassCastException。 To prohibit the copy function from writing to from, you can do the following: 1fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) &#123; ... &#125; 这是类型预测，这意味着 from 不是一个简单的数组，而是一个受限（预测）数组。只能调用返回类型参数 T 的方法，这意味着只能调用 get()。这是我们使用站点差异的方法，它对应于 Java 的 Array&lt;? extends Object&gt;，同时稍微简单一些。 您也可以使用 in 预测类型： 1fun fill(dest: Array&lt;in String&gt;, value: String) &#123; ... &#125; Array&lt;in String&gt; 对应 Java 的 Array&lt;? super String&gt;。这意味着可以将 CharSequence 数组或 Object 数组传递给 fill() 函数。 Star-projections有时你想说你对类型参数一无所知，但你仍然想以一种安全的方式使用它。这里安全的方法是定义泛型类型的投影，该泛型类型的每个具体实例化都将是该投影的子类型。 Kotlin provides so-called star-projection syntax for this: 对于 Foo&lt;out T : TUpper&gt;，其中 T 是具有上限 TUpper 的协变类型参数，Foo&lt;*&gt; 等效于 Foo&lt;out TUpper&gt;。这意味着当 T 未知时，可以安全地从 Foo&lt;*&gt; 读取 TUpper 的值。 对于 Foo&lt;in T&gt;，其中 T 是逆变类型参数，Foo&lt;*&gt; 等效于 Foo&lt;in Nothing&gt;。这意味着当 T 未知时，无法以安全的方式向 Foo&lt;*&gt; 写入任何内容。 对于 Foo&lt;T : TUpper&gt;，其中 T 是具有上限 TUpper 的不变类型参数，Foo&lt;*&gt; 等效于读取值的 Foo&lt;out TUpper&gt; 和写入值的 Foo&lt;in Nothing&gt;。 如果泛型类型有多个类型参数，则每个类型参数都可以独立投影。例如，如果类型声明为接口 Function&lt;in T, out U&gt; 可以使用以下星形投影： Function&lt;*, String&gt; means Function&lt;in Nothing, String&gt;. Function&lt;Int, *&gt; means Function&lt;Int, out Any?&gt;. Function&lt;*, *&gt; means Function&lt;in Nothing, out Any?&gt;. 泛型函数1234567fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; &#123; // ...&#125;fun &lt;T&gt; T.basicToString(): String &#123; // extension function // ...&#125; 泛型约束可以替代给定类型参数的所有可能类型的集合可能受到泛型约束的限制。 上界最常见的约束类型是上界，它对应于 Java 的 extends 关键字： 1fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) &#123; ... &#125; 冒号后指定的类型为上界，表示只能用 Comparable&lt;T&gt; 的子类型替换 T。例如： 12sort(listOf(1, 2, 3)) // OK. Int is a subtype of Comparable&lt;Int&gt;sort(listOf(HashMap&lt;Int, String&gt;())) // Error: HashMap&lt;Int, String&gt; is not a subtype of Comparable&lt;HashMap&lt;Int, String&gt;&gt; 默认上限（如果没有指定）是 Any?。在尖括号内只能指定一个上界。如果同一类型参数需要多个上界，则需要单独的 where 子句： 12345fun &lt;T&gt; copyWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;String&gt; where T : CharSequence, T : Comparable&lt;T&gt; &#123; return list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;&#125; 传递的类型必须同时满足 where 子句的所有条件。在上面的例子中，T 类型必须同时实现 CharSequence 和 Comparable。 类型擦除Kotlin 对泛型声明使用执行的类型安全检查是在编译时完成的。在运行时，泛型类型的实例不包含有关其实际类型参数的任何信息。类型信息已被擦除。例如，Foo&lt;Bar&gt; 和 Foo&lt;Baz?&gt; 的实例被擦除为 Foo&lt;*&gt;。 因此，没有通用的方法来检查泛型类型的实例是否在运行时使用某些类型参数创建，并且编译器禁止此类 is-检查。 无法在运行时检查到具有具体类型参数的泛型类型的类型转换，例如，作为 List&lt;String&gt; 的 foo。当高级程序逻辑暗示类型安全但编译器无法直接推断时，可以使用这些未经检查的强制转换。编译器对未检查的强制转换发出警告，并且在运行时，仅检查非泛型部分（相当于 foo as List&lt;*&gt;）。 泛型函数调用的类型参数也只在编译时检查。在函数体内，类型参数不能用于类型检查，并且类型转换为类型参数（foo as T）是未检查的。但是，inline函数的reified类型参数在调用站点被内联函数体中的实际类型参数替换，因此可用于类型检查和强制转换，对泛型类型的实例具有与上述相同的限制。","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://azxkenzo.github.io/tags/Kotlin/"}]},{"title":"Kotlin - 操作符重载","slug":"Kotlin-操作符重载","date":"2022-05-26T23:52:02.000Z","updated":"2023-07-18T04:22:50.374Z","comments":true,"path":"2022/05/27/Kotlin-操作符重载/","link":"","permalink":"https://azxkenzo.github.io/2022/05/27/Kotlin-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"","text":"Kotlin 允许为类型上预定义的一组运算符提供自定义实现。这些运算符具有预定义的符号表示（如 + 或 *）和优先级。要实现运算符，请为相应类型提供具有特定名称的成员函数或扩展函数。这种类型成为二元运算的左侧类型和一元运算的参数类型。 要重载运算符，请使用运算符修饰符标记相应的函数： 123interface IndexedContainer &#123; operator fun get(index: Int)&#125; 重写运算符重载时，可以省略运算符： 123class OrdersList: IndexedContainer &#123; override fun get(index: Int) &#123; /*...*/ &#125;&#125; 一元运算一元前缀运算符 表达式 转换为 +a a.unaryPlus() -a a.unaryMinus() !a a.not() 该表表明，当编译器处理例如表达式 +a 时，它会执行以下步骤： 确定a的类型，设为T 查找带有操作符修饰符且没有接收器 T 参数的函数 unaryPlus()，这意味着成员函数或扩展函数。 如果函数不存在或不明确，则为编译错误。 如果函数存在且其返回类型为 R，则表达式 +a 的类型为 R。 这些操作以及所有其他操作都针对基本类型进行了优化，并且不会为它们引入函数调用的开销。 二元运算算术运算符 表达式 转换为 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a &#x2F; b a.div(b) a % b a.rem(b) a..b a.rangeTo(b) in 操作符 表达式 转换为 a in b b.contains(a) a !in b !b.contains(a) 索引访问运算符 表达式 转换为 a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, …, i_n] a.get(i_1, …, i_n) a[i] &#x3D; b a.set(i, b) a[i, j] &#x3D; b a.set(i, j, b) a[i_1, …, i_n] &#x3D; b a.set(i_1, …, i_n, b) invoke 操作符 表达式 转换为 a() a.invoke() a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_1, …, i_n) a.invoke(i_1, …, i_n) 增强赋值 表达式 转换为 a +&#x3D; b a.plusAssign(b) a -&#x3D; b a.minusAssign(b) a *&#x3D; b a.timesAssign(b) a &#x2F;&#x3D; b a.divAssign(b) a %&#x3D; b a.remAssign(b) 在 Kotlin 中，赋值不是表达式 等式和不等式运算符 表达式 转换为 a &#x3D;&#x3D; b a?.equals(b) ?: (b &#x3D;&#x3D;&#x3D; null) a !&#x3D; b !(a?.equals(b) ?: (b &#x3D;&#x3D;&#x3D; null)) 这些运算符仅适用于函数 equals(other: Any?): Boolean，可以重写该函数以提供自定义相等检查实现。任何其他具有相同名称的函数（如 equals(other: Foo)）都不会被调用。 &#x3D;&#x3D;&#x3D; 和 !&#x3D;&#x3D; （身份检查）不可重载，因此不存在它们的约定。 &#x3D;&#x3D; 操作很特殊：它被转换为一个复杂的表达式，用于筛选空值。 null &#x3D;&#x3D; null 始终为真，非 null x 的 x &#x3D;&#x3D; null 始终为假，不会调用 x.equals() 比较操作符 表达式 转换为 a &gt; b a.compareTo(b) &gt; 0 a &lt; b a.compareTo(b) &lt; 0 a &gt;&#x3D; b a.compareTo(b) &gt;&#x3D; 0 a &lt;&#x3D; b a.compareTo(b) &lt;&#x3D; 0 命名函数的中缀调用可以使用中缀函数调用来模拟自定义中缀操作。 OkioOkio 是一个库，它补充了 java.io 和 java.nio，使访问、存储和处理数据变得更加容易。 ByteStrings and BuffersOkio 围绕两种类型构建，将大量功能打包到一个简单的 API 中： ByteString 是一个不可变的字节序列。 对于字符数据，String 是基础。 ByteString 是 String 失散多年的兄弟，可以很容易地将二进制数据视为一个值。 这个类符合人体工程学：它知道如何将自己编码和解码为 hex、base64 和 UTF-8。 Buffer 是一个可变的字节序列。 与 ArrayList 一样，不需要提前调整 buffer 的大小。 将 buffer 作为队列读写：将数据写入末尾并从前面读取。 在内部，ByteString 和 Buffer 做了一些聪明的事情来节省 CPU 和内存。 如果将 UTF-8 字符串编码为 ByteString，它会缓存对该字符串的引用，这样如果稍后对其进行解码，就无需执行任何操作。 Buffer 被实现为 segment 的链表。 当将数据从一个 buffer 移动到另一个 buffer 时，它会重新分配 segment 的所有权，而不是复制数据。 这种方法对多线程程序特别有用：与网络对话的线程可以与工作线程交换数据，而无需任何复制或仪式。 Sources and Sinksjava.io 设计的一个优雅部分是如何对 stream 进行分层以进行加密和压缩等转换。 Okio 包含自己的 stream 类型，称为 Source 和 Sink，它们的工作方式类似于 InputStream 和 OutputStream，但有一些关键区别： 超时。 这些 stream 提供对底层 I&#x2F;O 机制超时的访问。 与 java.io 套接字 stream 不同，read() 和 write() 调用均会超时。 易于实施。 Source 声明了三个方法：read()、close() 和 timeout()。 没有诸如 available() 或单字节读取之类的危害会导致正确性和性能意外。 便于使用。 尽管 Source 和 Sink 的实现只有三个方法可以编写，但调用者可以使用 BufferedSource 和 BufferedSink 接口获得丰富的 API。 这些接口在一处提供所需的一切。 没有人为区分字节流和字符流。 它们都是数据。 以字节、UTF-8 字符串、big-endian 32 位整数、little-endian shorts 的形式读写它； 任何你想要的。 没有更多的 InputStreamReader！ 易于测试。 Buffer 类同时实现了 BufferedSource 和 BufferedSink，因此测试代码简单明了。 Okio读写流程逐行读取文本文件使用 FileSystem.source(Path) 打开 source stream 以读取文件。 返回的 Source 接口很小，用途有限。 相反，用 buffer 包装源代码。 这有两个好处： 它使 API 更强大。 BufferedSource 没有提供 Source 提供的基本方法，而是有几十种方法可以简洁地解决最常见的问题。 它使程序运行得更快。 Buffer 允许 Okio 用更少的 I&#x2F;O 操作完成更多的工作。 每个打开的 Source 都需要关闭。 打开流的代码负责确保它已关闭。 这用于自动关闭流。 这可以防止资源泄漏，即使抛出异常也是如此。 123456789101112fun readLines(path: Path) &#123; FileSystem.SYSTEM.source(path).use &#123; fileSource -&gt; fileSource.buffer().use &#123; bufferedFileSource -&gt; while (true) &#123; val line = bufferedFileSource.readUtf8Line() ?: break if (&quot;square&quot; in line) &#123; println(line) &#125; &#125; &#125; &#125;&#125; readUtf8Line() API 读取所有数据，直到下一个行分隔符——\\n、\\r\\n 或文件末尾。 它将数据作为字符串返回，省略末尾的定界符。 当它遇到空行时，该方法将返回一个空字符串。 如果没有更多数据可供读取，它将返回 null。 可以使用 FileSystem.read() 在 block 之前缓冲 source，在之后关闭 source。 在 block 的主体中，this 是一个 BufferedSource。 1234567fun readLines1(path: Path) &#123; FileSystem.SYSTEM.read(path) &#123; while (true) &#123; val line = readUtf8Line() ?: break &#125; &#125;&#125; readUtf8Line() 方法适用于解析大多数文件。 对于某些用例，还可以考虑 readUtf8LineStrict()。 它是相似的，但它要求每行以 \\n 或 \\r\\n 结束。 如果在此之前遇到文件末尾，它将抛出 EOFException。 strict 变体还允许字节限制以防止格式错误的输入。 写文本文件上面使用了 Source 和 BufferedSource 来读取文件。 为了写入，使用 Sink 和 BufferedSink。 缓冲的优点是相同的：更强大的 API 和更好的性能。 12345678910111213public void writeEnv(Path path) throws IOException &#123; try (Sink fileSink = FileSystem.SYSTEM.sink(path); BufferedSink bufferedSink = Okio.buffer(fileSink)) &#123; for (Map.Entry&lt;String, String&gt; entry : System.getenv().entrySet()) &#123; bufferedSink.writeUtf8(entry.getKey()); bufferedSink.writeUtf8(&quot;=&quot;); bufferedSink.writeUtf8(entry.getValue()); bufferedSink.writeUtf8(&quot;\\n&quot;); &#125; &#125;&#125; 没有用于编写一行输入的 API； 相反，手动插入自己的换行符。 大多数程序应该将“\\n”硬编码为换行符。 在极少数情况下，可以使用 System.lineSeparator() 而不是“\\n”：它在 Windows 上返回“\\r\\n”，在其他任何地方返回“\\n”。 可以使用 FileSystem.write() 在我们的块之前缓冲 sink 并在之后关闭 sink。 在块的主体中，this 是一个 BufferedSink。 12345678910fun writeEnv(path: Path) &#123; FileSystem.SYSTEM.write(path) &#123; for ((key, value) in System.getenv()) &#123; writeUtf8(key) writeUtf8(&quot;=&quot;) writeUtf8(value) writeUtf8(&quot;\\n&quot;) &#125; &#125;&#125; 在上面的代码中，对 writeUtf8() 进行了四次调用。 进行四次调用比下面的代码更有效，因为 VM 不必创建和垃圾收集临时字符串。sink.writeUtf8(entry.getKey() + &quot;=&quot; + entry.getValue() + &quot;\\n&quot;); // Slower! UTF-8在上面的 API 中可以看到 Okio 非常喜欢 UTF-8。 早期的计算机系统存在许多不兼容的字符编码：ISO-8859-1、ShiftJIS、ASCII、EBCDIC 等。编写支持多字符集的软件非常糟糕，我们甚至没有表情符号！ 今天我们很幸运，世界各地都在 UTF-8 上进行了标准化，在遗留系统中很少使用其他字符集。 如果需要其他字符集，可以使用 readString() 和 writeString()。 这些方法要求指定一个字符集。 否则可能会不小心创建只能由本地计算机读取的数据。 大多数程序应该只使用 UTF-8 方法。 在对字符串进行编码时，需要注意字符串表示和编码的不同方式。 当字形具有重音或其他装饰时，它可以表示为单个复杂代码点 (é) 或简单代码点 (e) 后跟其修饰符 (´)。 当整个字形是单个代码点时, 称为 NFC； 当它是多个时，它是 NFD。 尽管在 I&#x2F;O 中读取或写入字符串时都使用 UTF-8，但当它们在内存中时，Java 字符串使用称为 UTF-16 的过时字符编码。 这是一种糟糕的编码，因为它对大多数字符使用 16 位 char，但有些字符不适合。 特别是，大多数表情符号使用两个 Java 字符。 这是有问题的，因为 String.length() 返回了一个令人惊讶的结果：UTF-16 字符的数量而不是字形的自然数量。 在大多数情况下，Okio 让您忽略这些问题并专注于您的数据。 但是当您需要它们时，可以使用方便的 API 来处理低级 UTF-8 字符串。 使用 Utf8.size() 计算将字符串编码为 UTF-8 而不实际编码所需的字节数。 这在像协议缓冲区这样的长度前缀编码中很方便。 使用 BufferedSource.readUtf8CodePoint() 读取单个可变长度代码点，使用 BufferedSink.writeUtf8CodePoint() 写入一个。 12345678fun dumpStringData(s: String) &#123; println(&quot; &quot; + s) println(&quot; String.length: &quot; + s.length) println(&quot;String.codePointCount: &quot; + s.codePointCount(0, s.length)) println(&quot; Utf8.size: &quot; + s.utf8Size()) println(&quot; UTF-8 bytes: &quot; + s.encodeUtf8().hex()) println()&#125; 写二进制文件编码二进制文件与编码文本文件没有什么不同。 Okio 对两者使用相同的 BufferedSink 和 BufferedSource 字节。 这对于包含字节和字符数据的二进制格式很方便。 编写二进制数据比文本更危险，因为如果犯了错误，通常很难诊断。 通过小心这些陷阱来避免此类错误： 每个字段的宽度。 这是使用的字节数。 Okio 不包含发出部分字节的机制。 如果你需要，需要在写入之前进行自己的位移和屏蔽。 每个字段的字节顺序。 所有超过一个字节的字段都具有字节顺序：字节是按从最重要到最不重要（大端）还是从最不重要到最重要（小端）排序。 Okio 对 little-endian 方法使用 Le 后缀； 没有后缀的方法是大端法。 签名与未签名。 Java 没有无符号原始类型（除了 char！），所以处理这个问题通常发生在应用程序层。 为了使这更容易一些，Okio 接受 writeByte() 和 writeShort() 的 int 类型。 你可以传递一个“无符号”字节，比如 255，Okio 会做正确的事情。 此代码按照 BMP 文件格式对位图进行编码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344fun encode(bitmap: Bitmap, sink: BufferedSink) &#123; val height = bitmap.height val width = bitmap.width val bytesPerPixel = 3 val rowByteCountWithoutPadding = bytesPerPixel * width val rowByteCount = (rowByteCountWithoutPadding + 3) / 4 * 4 val pixelDataSize = rowByteCount * height val bmpHeaderSize = 14 val dibHeaderSize = 40 // BMP Header sink.writeUtf8(&quot;BM&quot;) // ID. sink.writeIntLe(bmpHeaderSize + dibHeaderSize + pixelDataSize) // File size. sink.writeShortLe(0) // Unused. sink.writeShortLe(0) // Unused. sink.writeIntLe(bmpHeaderSize + dibHeaderSize) // Offset of pixel data. // DIB Header sink.writeIntLe(dibHeaderSize) sink.writeIntLe(width) sink.writeIntLe(height) sink.writeShortLe(1) // Color plane count. sink.writeShortLe(bytesPerPixel * Byte.SIZE_BITS) sink.writeIntLe(0) // No compression. sink.writeIntLe(16) // Size of bitmap data including padding. sink.writeIntLe(2835) // Horizontal print resolution in pixels/meter. (72 dpi). sink.writeIntLe(2835) // Vertical print resolution in pixels/meter. (72 dpi). sink.writeIntLe(0) // Palette color count. sink.writeIntLe(0) // 0 important colors. // Pixel data. for (y in height - 1 downTo 0) &#123; for (x in 0 until width) &#123; sink.writeByte(bitmap.blue(x, y)) sink.writeByte(bitmap.green(x, y)) sink.writeByte(bitmap.red(x, y)) &#125; // Padding for 4-byte alignment. for (p in rowByteCountWithoutPadding until rowByteCount) &#123; sink.writeByte(0) &#125; &#125;&#125; 该程序最棘手的部分是格式所需的填充。 BMP 格式要求每一行都以 4 字节为边界开始，因此有必要添加零以保持对齐。 编码其他二进制格式通常非常相似。 一些技巧： 编写具有黄金价值的测试！ 确认您的程序发出预期结果可以使调试更容易。 使用 Utf8.size() 计算编码字符串的字节数。 这对于以长度为前缀的格式是必不可少的。 使用 Float.floatToIntBits() 和 Double.doubleToLongBits() 对浮点值进行编码。 在套接字上通信通过网络发送和接收数据有点像写入和读取文件。 使用 BufferedSink 对输出进行编码，使用 BufferedSource 对输入进行解码。 与文件一样，网络协议可以是文本、二进制或两者的混合。 但是网络和文件系统之间也有一些实质性的区别。 源码分析Source &amp; Sink12345678910111213141516171819202122232425262728293031interface Source : Closeable &#123; /** * Removes at least 1, and up to `byteCount` bytes from this and appends them to `sink`. Returns * the number of bytes read, or -1 if this source is exhausted. */ @Throws(IOException::class) fun read(sink: Buffer, byteCount: Long): Long /** Returns the timeout for this source. */ fun timeout(): Timeout /** * Closes this source and releases the resources held by this source. It is an error to read a * closed source. It is safe to close a source more than once. */ @Throws(IOException::class) override fun close()&#125;actual interface Sink : Closeable, Flushable &#123; @Throws(IOException::class) actual fun write(source: Buffer, byteCount: Long) @Throws(IOException::class) actual override fun flush() actual fun timeout(): Timeout @Throws(IOException::class) actual override fun close()&#125; Source 和 Sink 是 Okio 中最基础的两个接口，分别对应 java.io 中的 InputStream 和 OutputStream。 BufferedSource &amp; BufferedSinkBufferedSource 和 BufferedSink 接口对 Source 和 Sink 进行了扩展，并添加了缓冲的能力。 Segment 和 SegmentPoolBuffer 中的每个 segment 都是一个循环链表节点，引用 Buffer 中的前后 segment。池中的每个 segment 都是一个单链表节点，引用池中的其余 segment。segment 的底层字节数组可以在 Buffer 和字节串之间共享。 当一个 segment 的字节数组被共享时，该 segment 不能被回收，它的字节数据也不能被改变。 唯一的例外是允许所有者 segment 追加到该 segment，以限制或超出限制写入数据。 每个字节数组都有一个拥有的 segment。 不共享位置、限制、上一个和下一个参考。 Buffer","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://azxkenzo.github.io/tags/Kotlin/"}]},{"title":"Kotlin - String 类 API","slug":"Kotlin-String-类-API","date":"2022-05-26T23:24:30.000Z","updated":"2023-07-18T04:22:50.382Z","comments":true,"path":"2022/05/27/Kotlin-String-类-API/","link":"","permalink":"https://azxkenzo.github.io/2022/05/27/Kotlin-String-%E7%B1%BB-API/","excerpt":"","text":"compareTo将此对象与指定对象进行比较以进行排序。如果此对象等于指定的其他对象，则返回零，如果小于 other，则返回负数，如果大于 other，则返回正数。 1operator fun compareTo(other: String): Int contains检查原字符串中时候包含给定字符或字符串或正则表达式 12345inline operator fun CharSequence.contains(regex: Regex): Booleanoperator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Booleanoperator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean drop返回移除了前 n 个字符的字符串 123fun String.drop(n: Int): String&quot;4321&quot;.drop(2) // 21 length获取字符串的长度 123val length: Int // 定义&quot;123&quot;.length plus返回通过将此字符串与给定其他对象的字符串表示形式连接获得的字符串。 123operator fun plus(other: Any?): String // 定义&quot;123&quot;.plus(&quot;312&quot;) or &quot;123&quot; + &quot;321&quot; repeat返回将原字符串重复 n 次后的新字符串。当 n &#x3D; 0 时，返回空字符串 1actual fun CharSequence.repeat(n: Int): String split使用指定模式或字符串或字符分割原字符串 1234567fun CharSequence.split(regex: Pattern, limit: Int = 0)fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List&lt;String&gt;fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List&lt;String&gt;inline fun CharSequence.split(regex: Regex, limit: Int = 0): List&lt;String&gt; int 常用函数 dec(): 返回此值减一。 inc(): 返回此值加一 div(int): 将此值除以另一个值，将结果截断为更接近零的整数 minus(int): 从这个值中减去另一个值。 plus(int): 将其他值添加到此值。 rem(int): 计算此值除以其他值的截断余数 coerceAtLeast(min): 确保此值不小于指定的最小值 coerceAtMost(max): 确保此值不大于指定的最大值","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://azxkenzo.github.io/tags/Kotlin/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2022-05-26T22:45:49.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/05/27/Markdown语法/","link":"","permalink":"https://azxkenzo.github.io/2022/05/27/Markdown%E8%AF%AD%E6%B3%95/","excerpt":"","text":"MarkDown 介绍Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 标题Markdown 标题有两种格式。 1、使用 &#x3D; 和 - 标记一级和二级标题12345我展示的是一级标题=================我展示的是二级标题----------------- 显示效果如下: 我展示的是一级标题我展示的是二级标题2、使用 # 号标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。 段落Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。当然也可以在段落后面使用一个空行来表示重新开始一个段落。 字体Markdown 可以使用以下几种字体： 123456*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___ 斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本 分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 123456789**** * ******- - ----------- 删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下： 12GOOGLE.COM~~BAIDU.COM~~ GOOGLE.COMBAIDU.COM 下划线下划线可以通过 HTML 的 &lt;u&gt; 标签来实现： 1&lt;u&gt;带下划线文本&lt;/u&gt; 带下划线文本 脚注脚注是对文本的补充说明。Markdown 脚注的格式如下: 1[^要注明的文本] 以下实例演示了脚注的用法： 123创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！ 创建脚注格式类似这样 [^RUNOOB]。 [^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！ 列表Markdown 支持有序列表和无序列表。 无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容： 有序列表使用数字并加上 . 号来表示 列表嵌套列表嵌套只需在子列表中的选项前面添加四个空格即可： 区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号： 123&gt; 区块引用&gt; 菜鸟教程&gt; 学的不仅是技术更是梦想 区块引用菜鸟教程学的不仅是技术更是梦想 另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推 区块中使用列表123456&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项 列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。 列表中使用区块实例如下： 1234* 第一项 &gt; 菜鸟教程 &gt; 学的不仅是技术更是梦想* 第二项 代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来 (&#96;) 代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。 也可以用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定） 链接链接使用方法如下： 12345[链接名称](链接地址)或者&lt;链接地址&gt; 高级链接可以通过变量来设置一个链接，变量赋值在文档末尾进行： 123456这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [runoob]: http://www.runoob.com/ 图片Markdown 图片语法格式如下： 123![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;) 也可以像网址那样对图片网址使用变量： 1234这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾为变量赋值（网址）[1]: http://static.runoob.com/images/runoob-logo.png Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。语法格式如下： 1234| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 对齐方式可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 高级技巧支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符 Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\\ 反斜线` 反引号* 星号_ 下划线&#123;&#125; 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号 公式Markdown Preview Enhanced 使用 KaTeX 或者 MathJax 来渲染数学表达式。 KaTeX 拥有比 MathJax 更快的性能，但是它却少了很多 MathJax 拥有的特性。你可以查看 KaTeX supported functions&#x2F;symbols 来了解 KaTeX 支持那些符号和函数。 默认下的分隔符： $…$ 或者 (…) 中的数学表达式将会在行内显示。 $$…$$ 或者 […] 或者 &#96;&#96;&#96;math 中的数学表达式将会在块内显示。","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://azxkenzo.github.io/tags/Markdown/"}]},{"title":"Github + Hexo 搭建博客","slug":"Github-Hexo-搭建博客","date":"2022-05-25T23:56:14.000Z","updated":"2023-07-14T04:40:17.265Z","comments":true,"path":"2022/05/26/Github-Hexo-搭建博客/","link":"","permalink":"https://azxkenzo.github.io/2022/05/26/Github-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"一、准备工作1. 安装 Node.jsNode.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本点此下载安装程序 2. 安装 Git3. 安装 Hexo在 Node.js 安装好后，使用 npm 安装 Hexo 1$ npm install -g hexo-cli 注意：在 macOS 上，该命令需要在 root 环境下运行 二、建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 以下是目录下各个文件的描述： _config.yml网站的 配置 信息，可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，可以自由移除。 scaffolds模版 文件夹。当新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果修改scaffold&#x2F;post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 三、网站配置可以在 _config.yml 中修改大部分的配置。 网站title 网站标题 subtitle 网站副标题 description 网站描述 keywords 网站的关键词。支持多个关键词。 author 您的名字 language 网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。 timezone 网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America&#x2F;New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia&#x2F;Shanghai。 四、命令init1$ hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 本命令相当于执行了以下几步： Git clone hexo-starter 和 hexo-theme-landscape 主题到当前目录或指定目录。 使用 Yarn 1、pnpm 或 npm 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js 安装。 new1$ hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 参数： -p, –path 自定义新文章的路径 -r, –replace 如果存在同名文章，将其替换 -s, –slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录： 1$ hexo new page --path about/me &quot;About me&quot; 以上命令会创建一个 source&#x2F;about&#x2F;me.md 文件，同时 Front Matter 中的 title 为 “About me” 注意！title 是必须指定的！如果你这么做并不能达到你的目的： 1$ hexo new page --path about/me 此时 Hexo 会创建 source&#x2F;_posts&#x2F;about&#x2F;me.md，同时 me.md 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。 generate1$ hexo generate 生成静态文件 -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 -b, –bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, –force 强制重新生成文件。Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, –concurrency 最大同时生成文件的数量，默认无限制 该命令可以简写为： 1$ hexo g publish1$ hexo publish [layout] &lt;filename&gt; 发表草稿 server1$ hexo server 启动服务器 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 deploy1$ hexo deploy 部署网站。 -g, –generate 部署之前预先生成静态文件 该命令可以简写为： 1$ hexo d render1$ hexo render &lt;file1&gt; [file2] ... 渲染文件。 clean1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list1$ hexo list &lt;type&gt; 列出网站资料。 version1$ hexo version 五、写作可以执行下列命令来创建一篇新文章或者新的页面。 1$ hexo new [layout] &lt;title&gt; 布局（Layout）Hexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。 布局 路径 post source&#x2F;_posts page source draft source&#x2F;_drafts If you don’t want an article (post&#x2F;page) to be processed with a theme, set layout: false in its front-matter. Refer to this section for more details. 文件名称Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。 草稿刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source&#x2F;_drafts 文件夹，可通过 publish 命令将草稿移动到 source&#x2F;_posts 文件夹，该命令的使用方式与 new 十分类似，也可在命令中指定 layout 来指定布局。 1$ hexo publish [layout] &lt;title&gt; 模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1$ hexo new photo &quot;My Gallery&quot; 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是可以在模版中使用的变量： layout 布局 title 标题 date 文件建立日期 六、Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说： 1234---title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，可在模板中使用这些参数值并加以利用。 layout 布局 config.default_layout title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 excerpt Page excerpt in plain text. Use this plugin to format the text disableNunjucks Disable rendering of Nunjucks tag and tag plugins when enabled lang Set the language to override auto-detection Inherited from _config.yml 布局The default layout is post, in accordance to the value of default_layout setting in _config.yml. When the layout is disabled (layout: false) in an article, it will not be processed with a theme. However, it will still be rendered by any available renderer: if an article is written in Markdown and a Markdown renderer (like the default hexo-renderer-marked) is installed, it will be rendered to HTML. Tag plugins are always processed regardless of layout, unless disabled by the disableNunjucks setting or renderer. 分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 七、部署使用 Travis CI 将 Hexo 博客部署到 GitHub Pages 上。Travis CI 对于开源 repository 是免费的，但是这意味着你的站点文件将会是公开的。 新建一个 repository。如果你希望你的站点能通过域名 &lt;你的 GitHub 用户名&gt;.github.io 访问，你的 repository 应该直接命名为 &lt;你的 GitHub 用户名&gt;.github.io。 将你的 Hexo 站点文件夹推送到 repository 中。默认情况下 public 目录将不会（也不应该）被推送到 repository 中，你应该检查 .gitignore 文件中是否包含 public 一行，如果没有请加上。 将 Travis CI 添加到你的 GitHub 账户中。 前往 GitHub 的 Applications settings，配置 Travis CI 权限，使其能够访问你的 repository。 你应该会被重定向到 Travis CI 的页面。如果没有，请 手动前往。 在浏览器内新建一个标签页，前往 GitHub 新建 Personal Access Token，只勾选 repo 的权限并生成一个新的 Token。Token 生成后请复制并保存好。 回到 Travis CI，前往你的 repository 的设置页面，在 Environment Variables 下新建一个环境变量，Name 为 GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token。确保 DISPLAY VALUE IN BUILD LOG 保持 不被勾选 避免你的 Token 泄漏。点击 Add 保存。 在你的 Hexo 站点文件夹中新建一个 .travis.yml 文件： 将 .travis.yml 推送到 repository 中。Travis CI 应该会自动开始运行，并将生成的文件推送到同一 repository 下的 gh-pages 分支下 在 GitHub 中前往你的 repository 的设置页面，修改 GitHub Pages 的部署分支为 gh-pages。 前往 https:&#x2F;&#x2F;&lt;你的 GitHub 用户名&gt;.github.io 查看你的站点是否可以访问。这可能需要一些时间。 一键部署Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 1$ hexo deploy 在开始之前，必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12deploy: type: git Git1 安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 2 修改配置 12345deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 3 生成站点文件并推送至远程库。执行 hexo clean &amp;&amp; hexo deploy。 · You will be prompted with username and password of the target repository, unless you authenticate with a token or ssh key. · hexo-deployer-git does not store your username and password. Use git-credential-cache to store them temporarily. 4 登入 Github，请在库设置（Repository Settings）中将默认分支设置为_config.yml配置中的分支名称。稍等片刻，您的站点就会显示在您的Github Pages中。 这一切是如何发生的？当执行 hexo deploy 时，Hexo 会将 public 目录中的文件和目录推送至 _config.yml 中指定的远端仓库和分支中，并且完全覆盖该分支下的已有内容。 Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://azxkenzo.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://azxkenzo.github.io/tags/Github/"}]}],"categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://azxkenzo.github.io/tags/Android/"},{"name":"JVM","slug":"JVM","permalink":"https://azxkenzo.github.io/tags/JVM/"},{"name":"Compose","slug":"Compose","permalink":"https://azxkenzo.github.io/tags/Compose/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://azxkenzo.github.io/tags/Kotlin/"},{"name":"Material3","slug":"Material3","permalink":"https://azxkenzo.github.io/tags/Material3/"},{"name":"Coroutine","slug":"Coroutine","permalink":"https://azxkenzo.github.io/tags/Coroutine/"},{"name":"Markdown","slug":"Markdown","permalink":"https://azxkenzo.github.io/tags/Markdown/"},{"name":"Hexo","slug":"Hexo","permalink":"https://azxkenzo.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://azxkenzo.github.io/tags/Github/"}]}